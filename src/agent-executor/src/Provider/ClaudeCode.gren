module Provider.ClaudeCode exposing
    ( provider
    , Config
    )

{-| Claude Code provider implementation.

This provider spawns the Claude CLI directly to communicate with Claude.
It implements the Provider interface for LLM communication.
-}

import Bytes
import ChildProcess
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Agent.Spec exposing (AgentSpec)
import Provider
    exposing
        ( Provider
        , ProviderError(..)
        , Response
        , Session
        , SessionId
        , ToolCall
        , ToolResult
        )
import Task


-- CONFIGURATION


{-| Configuration for the Claude Code provider.
-}
type alias Config =
    { childProcessPermission : ChildProcess.Permission
    , fileToolsPath : String
    }



-- PROVIDER


{-| The Claude Code provider.

This implements the Provider interface by spawning the claude CLI.
-}
provider : Config -> Provider msg
provider config =
    { validateEnvironment = validateEnvironment config
    , createSession = createSession config
    , sendMessage = sendMessage config
    , submitToolResults = submitToolResults config
    , resumeSession = resumeSession config
    }



-- ENVIRONMENT VALIDATION


{-| Validate that required prerequisites are available.

Checks:
- claude CLI is installed and accessible
- file-tools binary exists at configured path
-}
validateEnvironment :
    Config
    -> (Result ProviderError {} -> msg)
    -> Cmd msg
validateEnvironment config toMsg =
    -- Check claude CLI by running "claude --version" with stdin redirected
    -- We use bash -c to redirect stdin from /dev/null to prevent hanging
    let
        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 1024
            , runDuration = ChildProcess.Milliseconds 5000
            }

        claudeCmd =
            "claude --version </dev/null"

        fileToolsCmd =
            config.fileToolsPath ++ " --help </dev/null"
    in
    ChildProcess.run config.childProcessPermission "bash" [ "-c", claudeCmd ] options
        |> Task.andThen
            (\_ ->
                -- Claude CLI found, now check file-tools
                ChildProcess.run config.childProcessPermission "bash" [ "-c", fileToolsCmd ] options
                    |> Task.map (\_ -> {})
            )
        |> Task.mapError
            (\runError ->
                when runError is
                    ChildProcess.InitError { errorCode } ->
                        if String.contains "ENOENT" errorCode then
                            EnvironmentError
                                { message = "claude CLI not found in PATH. Install from https://claude.ai/code"
                                }
                        else
                            EnvironmentError
                                { message = "Failed to run claude CLI: " ++ errorCode
                                }

                    ChildProcess.ProgramError { exitCode, stderr } ->
                        let
                            stderrStr =
                                stderr |> Bytes.toString |> Maybe.withDefault ""
                        in
                        EnvironmentError
                            { message = "claude CLI check failed (exit " ++ String.fromInt exitCode ++ "): " ++ stderrStr
                            }
            )
        |> Task.attempt toMsg



-- SESSION OPERATIONS


{-| Create a new session by invoking the claude CLI.

The session ID is extracted from the system.init message in the response.
-}
createSession :
    Config
    -> AgentSpec
    -> String
    -> (Result ProviderError Session -> msg)
    -> Cmd msg
createSession config agentSpec workspaceRoot toMsg =
    -- For session creation, we send an initial "hello" message to establish the session
    -- The CLI will return a session_id in the system.init message
    let
        cliArgs =
            { systemPrompt = Just agentSpec.systemPrompt
            , resumeSessionId = Nothing
            , workspaceRoot = workspaceRoot
            , fileToolsPath = config.fileToolsPath
            , message = "Session initialized. Awaiting instructions."
            }

        -- Build shell command with stdin redirected from /dev/null
        -- This is necessary because Gren's ChildProcess.run uses execFile which
        -- inherits stdin, causing the claude CLI to hang waiting for input
        shellCommand =
            buildShellCommand cliArgs

        args =
            [ "-c", shellCommand ]

        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 1024 * 1024  -- 1MB
            , runDuration = ChildProcess.Milliseconds 120000  -- 2 minutes
            }
    in
    ChildProcess.run config.childProcessPermission "bash" args options
        |> Task.mapError (cliErrorToProviderError (buildCliArgs cliArgs))
        |> Task.andThen
            (\result ->
                let
                    output =
                        result.stdout |> Bytes.toString |> Maybe.withDefault ""
                in
                when parseSessionId output is
                    Just sessionId ->
                        Task.succeed
                            { id = sessionId
                            , agentSpec = agentSpec
                            }

                    Nothing ->
                        Task.fail (InvalidResponseError { message = "Could not extract session ID from CLI output" })
            )
        |> Task.attempt toMsg


{-| Send a message in an existing session.
-}
sendMessage :
    Config
    -> Session
    -> String
    -> (Result ProviderError Response -> msg)
    -> Cmd msg
sendMessage config session message toMsg =
    let
        cliArgs =
            { systemPrompt = Nothing
            , resumeSessionId = Just session.id
            , workspaceRoot = ""  -- Not needed for resume
            , fileToolsPath = config.fileToolsPath
            , message = message
            }

        -- Build shell command with stdin redirected from /dev/null
        shellCommand =
            buildShellCommand cliArgs

        args =
            [ "-c", shellCommand ]

        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 10 * 1024 * 1024  -- 10MB
            , runDuration = ChildProcess.Milliseconds 600000  -- 10 minutes for longer tasks
            }
    in
    ChildProcess.run config.childProcessPermission "bash" args options
        |> Task.mapError (cliErrorToProviderError (buildCliArgs cliArgs))
        |> Task.andThen
            (\result ->
                let
                    output =
                        result.stdout |> Bytes.toString |> Maybe.withDefault ""
                in
                when parseCliResponse output is
                    Ok response ->
                        Task.succeed response

                    Err errMsg ->
                        Task.fail (InvalidResponseError { message = errMsg })
            )
        |> Task.attempt toMsg


{-| Submit tool results - with CLI, tools are executed internally.

The Claude CLI handles tool execution internally, so this function
should not normally be called. It's provided for interface compatibility.
-}
submitToolResults :
    Config
    -> Session
    -> Array ToolResult
    -> (Result ProviderError Response -> msg)
    -> Cmd msg
submitToolResults config session results toMsg =
    -- The CLI handles tool execution internally, so we don't need to submit results.
    -- This function exists for interface compatibility.
    -- If called, we return an error explaining the situation.
    Task.fail
        (InvalidResponseError
            { message = "Tool results are handled internally by the claude CLI. This function should not be called."
            }
        )
        |> Task.attempt toMsg


{-| Resume an existing session.
-}
resumeSession :
    Config
    -> SessionId
    -> (Result ProviderError (Maybe Session) -> msg)
    -> Cmd msg
resumeSession config sessionId toMsg =
    -- We can't easily verify if a session exists without making a call.
    -- For now, we assume the session exists and let sendMessage handle any errors.
    Task.succeed
        (Just
            { id = sessionId
            , agentSpec =
                { name = "Resumed"
                , systemPrompt = ""  -- Not available on resume
                }
            }
        )
        |> Task.attempt toMsg



-- CLI ARGUMENT BUILDING


{-| Arguments for building CLI command.
-}
type alias CliArgs =
    { systemPrompt : Maybe String
    , resumeSessionId : Maybe String
    , workspaceRoot : String
    , fileToolsPath : String
    , message : String
    }


{-| Build command line arguments for the claude CLI.
-}
buildCliArgs : CliArgs -> Array String
buildCliArgs args =
    let
        baseArgs =
            [ "-p"  -- Non-interactive mode
            , "--output-format", "json"  -- Use batch JSON for simpler parsing
            ]

        sessionArgs =
            when args.resumeSessionId is
                Just sessionId ->
                    [ "--resume", sessionId ]

                Nothing ->
                    []

        promptArgs =
            when args.systemPrompt is
                Just prompt ->
                    [ "--system-prompt", prompt ]

                Nothing ->
                    []

        toolArgs =
            [ "--tools", "Bash"
            , "--allowedTools", "Bash(file-tools *)"
            , "--permission-mode", "bypassPermissions"
            ]

        dirArgs =
            if String.isEmpty args.workspaceRoot then
                []
            else
                [ "--add-dir", args.workspaceRoot ]

        -- Use "--" to separate options from the message argument
        messageArg =
            [ "--", args.message ]
    in
    Array.flatten
        [ baseArgs
        , sessionArgs
        , promptArgs
        , toolArgs
        , dirArgs
        , messageArg
        ]


{-| Build a shell command string for the claude CLI.

This builds a command that redirects stdin from /dev/null to prevent
the CLI from hanging when waiting for input. Arguments are properly
escaped for shell execution.
-}
buildShellCommand : CliArgs -> String
buildShellCommand args =
    let
        -- Escape a string for use in single quotes
        -- Single quotes prevent all expansion except for single quotes themselves
        -- To include a single quote, we: end the single-quoted string, add an escaped single quote, start a new single-quoted string
        escapeForShell : String -> String
        escapeForShell str =
            "'" ++ String.replace "'" "'\\''" str ++ "'"

        baseArgs =
            "claude -p --output-format json"

        sessionArgs =
            when args.resumeSessionId is
                Just sessionId ->
                    " --resume " ++ escapeForShell sessionId

                Nothing ->
                    ""

        promptArgs =
            when args.systemPrompt is
                Just prompt ->
                    " --system-prompt " ++ escapeForShell prompt

                Nothing ->
                    ""

        toolArgs =
            " --tools Bash --allowedTools " ++ escapeForShell "Bash(file-tools *)" ++ " --permission-mode bypassPermissions"

        dirArgs =
            if String.isEmpty args.workspaceRoot then
                ""
            else
                " --add-dir " ++ escapeForShell args.workspaceRoot

        messageArg =
            " -- " ++ escapeForShell args.message

        -- Redirect stdin from /dev/null to prevent hanging
        stdinRedirect =
            " </dev/null"
    in
    baseArgs ++ sessionArgs ++ promptArgs ++ toolArgs ++ dirArgs ++ messageArg ++ stdinRedirect



-- RESPONSE PARSING


{-| Extract session ID from CLI output.

Looks for the session_id in the JSON result message.
-}
parseSessionId : String -> Maybe String
parseSessionId output =
    let
        decoder =
            Decode.field "session_id" Decode.string
    in
    when Decode.decodeString decoder output is
        Ok sessionId ->
            Just sessionId

        Err _ ->
            -- Try parsing as NDJSON (stream format) and look for system.init
            output
                |> String.lines
                |> Array.mapAndKeepJust
                    (\line ->
                        when Decode.decodeString systemInitDecoder line is
                            Ok sid ->
                                Just sid

                            Err _ ->
                                Nothing
                    )
                |> Array.first


{-| Decoder for system.init message session_id.
-}
systemInitDecoder : Decoder String
systemInitDecoder =
    Decode.map2
        (\msgType subtype ->
            { msgType = msgType
            , subtype = subtype
            }
        )
        (Decode.field "type" Decode.string)
        (Decode.maybe (Decode.field "subtype" Decode.string))
        |> Decode.andThen
            (\info ->
                if info.msgType == "system" && info.subtype == Just "init" then
                    Decode.field "session_id" Decode.string
                else
                    Decode.fail "Not a system.init message"
            )


{-| Parse CLI response into Response type.
-}
parseCliResponse : String -> Result String Response
parseCliResponse output =
    let
        -- For batch JSON output, parse the result message
        resultDecoder =
            Decode.map4
                (\msgType isError result sessionId ->
                    { msgType = msgType
                    , isError = isError
                    , result = result
                    , sessionId = sessionId
                    }
                )
                (Decode.field "type" Decode.string)
                (Decode.field "is_error" Decode.bool)
                (Decode.field "result" Decode.string)
                (Decode.field "session_id" Decode.string)
    in
    when Decode.decodeString resultDecoder output is
        Ok parsed ->
            if parsed.isError then
                Err ("CLI returned error: " ++ parsed.result)
            else
                Ok
                    { text = parsed.result
                    , toolCalls = []  -- Tools are executed internally by CLI
                    , isComplete = True  -- CLI completes tool execution before returning
                    }

        Err decodeError ->
            -- Try parsing as stream-json format
            parseStreamJsonResponse output


{-| Parse streaming JSON (NDJSON) response.
-}
parseStreamJsonResponse : String -> Result String Response
parseStreamJsonResponse output =
    let
        lines =
            String.lines output

        -- Find the result message (last message of type "result")
        resultLine =
            lines
                |> Array.reverse
                |> Array.mapAndKeepJust
                    (\line ->
                        let
                            typeDecoder =
                                Decode.field "type" Decode.string
                        in
                        when Decode.decodeString typeDecoder line is
                            Ok "result" ->
                                Just line

                            _ ->
                                Nothing
                    )
                |> Array.first
    in
    when resultLine is
        Nothing ->
            -- No result message found, try to extract text from assistant messages
            extractAssistantText lines

        Just line ->
            let
                resultDecoder =
                    Decode.map2
                        (\isError result ->
                            { isError = isError
                            , result = result
                            }
                        )
                        (Decode.field "is_error" Decode.bool)
                        (Decode.field "result" Decode.string)
            in
            when Decode.decodeString resultDecoder line is
                Ok parsed ->
                    if parsed.isError then
                        Err ("CLI returned error: " ++ parsed.result)
                    else
                        Ok
                            { text = parsed.result
                            , toolCalls = []
                            , isComplete = True
                            }

                Err _ ->
                    Err "Could not parse result message"


{-| Extract text from assistant messages when no result message is found.
-}
extractAssistantText : Array String -> Result String Response
extractAssistantText lines =
    let
        textContentDecoder =
            Decode.map2
                (\contentType text ->
                    { contentType = contentType
                    , text = text
                    }
                )
                (Decode.field "type" Decode.string)
                (Decode.field "text" Decode.string)

        contentDecoder =
            Decode.field "message"
                (Decode.field "content"
                    (Decode.array textContentDecoder)
                )

        assistantDecoder =
            Decode.field "type" Decode.string
                |> Decode.andThen
                    (\msgType ->
                        if msgType == "assistant" then
                            contentDecoder
                        else
                            Decode.fail "Not an assistant message"
                    )

        extractedTexts =
            lines
                |> Array.mapAndKeepJust
                    (\line ->
                        when Decode.decodeString assistantDecoder line is
                            Ok contents ->
                                contents
                                    |> Array.mapAndKeepJust
                                        (\c ->
                                            if c.contentType == "text" then
                                                Just c.text
                                            else
                                                Nothing
                                        )
                                    |> String.join "\n"
                                    |> Just

                            Err _ ->
                                Nothing
                    )
    in
    if Array.isEmpty extractedTexts then
        Err "No assistant response found in CLI output"
    else
        Ok
            { text = String.join "\n" extractedTexts
            , toolCalls = []
            , isComplete = True
            }



-- ERROR HANDLING


{-| Convert CLI execution errors to ProviderError.

The args parameter is included in error messages for debugging.
-}
cliErrorToProviderError : Array String -> ChildProcess.FailedRun -> ProviderError
cliErrorToProviderError args runError =
    let
        argsDebug =
            "CLI args: claude " ++ String.join " " args
    in
    when runError is
        ChildProcess.InitError { errorCode } ->
            if String.contains "ENOENT" errorCode then
                EnvironmentError
                    { message = "claude CLI not found. Install from https://claude.ai/code"
                    }
            else
                NetworkError
                    { message = "Failed to start claude CLI: " ++ errorCode ++ " | " ++ argsDebug
                    }

        ChildProcess.ProgramError { exitCode, stderr } ->
            let
                stderrStr =
                    stderr |> Bytes.toString |> Maybe.withDefault ""
            in
            if String.contains "auth" (String.toLower stderrStr) || String.contains "unauthorized" (String.toLower stderrStr) then
                AuthenticationError
                    { message = stderrStr ++ " | " ++ argsDebug
                    }
            else if String.contains "rate limit" (String.toLower stderrStr) then
                RateLimitError
                    { message = stderrStr ++ " | " ++ argsDebug
                    }
            else
                InvalidResponseError
                    { message = "CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr ++ " | " ++ argsDebug
                    }
