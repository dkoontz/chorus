module Main exposing (main)

{-| CLI entry point for the agent executor.

Usage:
    agent-executor <agent_spec> <workspace_root> [session_id]

Arguments:
    agent_spec      Path to agent markdown file (e.g., agents/developer.md)
    workspace_root  Directory for file operations
    session_id      Optional: resume an existing session

The executor reads initial parameters from stdin as JSON:
    {
      "TASK_FILE": "tasks/feature-a.md",
      "STATUS_FILE": "workspaces/feature-a/status.md",
      "REPORT_FILE": "workspaces/feature-a/reports/developer-1.md"
    }

Example:
    echo '{"TASK_FILE":"tasks/example.md"}' | agent-executor agents/developer.md ./workspace
-}

import Agent.Executor as Executor
import Agent.Spec as Spec exposing (AgentSpec)
import Bytes
import ChildProcess
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Init
import Json.Decode as Decode
import Json.Encode as Encode
import Node
import Provider exposing (providerErrorToString)
import Provider.ClaudeCode as ClaudeCode
import Stream
import Task exposing (Task)


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { executor : Executor.Model
    , config : Maybe ExecutorConfig
    , env : Maybe Node.Environment
    , fsPermission : Maybe FileSystem.Permission
    , cpPermission : Maybe ChildProcess.Permission
    , stdinContent : Maybe String
    , initialMessage : Maybe String
    , status : Status
    }


type Status
    = Initializing
    | WaitingForStdin
    | Running
    | Done
    | Error String


type alias ExecutorConfig =
    { workspaceRoot : String
    , agentSpecPath : Path
    , sessionId : Maybe String
    , fileToolsPath : String
    }


type alias Parameters =
    { taskFile : String
    , statusFile : String
    , reportFile : String
    , reviewReport : Maybe String
    , qaReport : Maybe String
    }



-- MSG


type Msg
    = ExecutorMsg Executor.Msg
    | StdinRead (Result Stream.Error String)
    | AgentSpecLoaded (Result Spec.ParseError AgentSpec)
    | OutputWritten
    | SessionSaved (Result String {})
    | ExitCodeSet


initialModel : Model
initialModel =
    { executor = Executor.Loading
    , config = Nothing
    , env = Nothing
    , fsPermission = Nothing
    , cpPermission = Nothing
    , stdinContent = Nothing
    , initialMessage = Nothing
    , status = Initializing
    }



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    when parseArgs env.args is
        Err errorMsg ->
            -- For argument errors, we use Init directly
            Init.await FileSystem.initialize <|
                \_ ->
                    Node.startProgram
                        { model = { initialModel | status = Error errorMsg, env = Just env }
                        , command = outputErrorAndExit env errorMsg
                        }

        Ok config ->
            Init.await FileSystem.initialize <|
                \fsPermission ->
                    Init.await ChildProcess.initialize <|
                        \cpPermission ->
                            Node.startProgram
                                { model =
                                    { initialModel
                                        | config = Just config
                                        , env = Just env
                                        , fsPermission = Just fsPermission
                                        , cpPermission = Just cpPermission
                                        , status = WaitingForStdin
                                    }
                                , command =
                                    -- Start reading stdin and loading agent spec in parallel
                                    Cmd.batch
                                        [ Stream.readBytesAsString env.stdin
                                            |> Task.attempt StdinRead
                                        , Executor.init fsPermission config.agentSpecPath
                                            |> Task.attempt AgentSpecLoaded
                                        ]
                                }


parseArgs : Array String -> Result String ExecutorConfig
parseArgs args =
    -- Args: [node, script, agent_spec, workspace_root, ?session_id]
    when args is
        [ _, _, agentSpecStr, workspaceRoot ] ->
            Ok
                { workspaceRoot = workspaceRoot
                , agentSpecPath = Path.fromPosixString agentSpecStr
                , sessionId = Nothing
                , fileToolsPath = getFileToolsPath args
                }

        [ _, _, agentSpecStr, workspaceRoot, sessionId ] ->
            Ok
                { workspaceRoot = workspaceRoot
                , agentSpecPath = Path.fromPosixString agentSpecStr
                , sessionId = Just sessionId
                , fileToolsPath = getFileToolsPath args
                }

        _ ->
            Err "Usage: agent-executor <agent_spec> <workspace_root> [session_id]"


{-| Get the file-tools binary path.

Looks for file-tools in the same directory as the executor binary.
Falls back to just "file-tools" (which will be found via PATH).
-}
getFileToolsPath : Array String -> String
getFileToolsPath args =
    -- args[1] is the path to the current script (process.argv[1])
    when Array.get 1 args is
        Just scriptPath ->
            let
                scriptDir =
                    Path.fromPosixString scriptPath
                        |> Path.parentPath
                        |> Maybe.map Path.toPosixString
                        |> Maybe.withDefault ""
            in
            if String.isEmpty scriptDir then
                "file-tools"
            else
                scriptDir ++ "/file-tools"

        Nothing ->
            "file-tools"



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        StdinRead result ->
            when result is
                Err _ ->
                    -- Stdin read failed - this could mean no input was provided
                    -- Use empty JSON as default
                    handleStdinContent model "{}"

                Ok content ->
                    handleStdinContent model content

        AgentSpecLoaded result ->
            when { result = result, config = model.config, cpPermission = model.cpPermission } is
                { result = Err parseError } ->
                    let
                        errorMsg =
                            Spec.parseErrorToString parseError
                    in
                    when model.env is
                        Just env ->
                            { model = { model | status = Error errorMsg }
                            , command = outputErrorAndExit env errorMsg
                            }

                        Nothing ->
                            { model = { model | status = Error errorMsg }
                            , command = Cmd.none
                            }

                { result = Ok agentSpec, config = Just cfg, cpPermission = Just cpPerm } ->
                    -- Create provider and forward to executor
                    let
                        provider =
                            createProvider cfg cpPerm

                        executorConfig =
                            createExecutorConfig cfg provider

                        wrapper =
                            { model = model.executor
                            , cmd = Cmd.none
                            , toMsg = ExecutorMsg
                            }

                        executorResult =
                            Executor.update
                                (Executor.AgentSpecLoaded (Ok agentSpec))
                                model.executor
                                executorConfig
                                wrapper
                    in
                    { model =
                        { model
                            | executor = executorResult.model
                            , status = Running
                        }
                    , command = executorResult.cmd
                    }

                _ ->
                    -- Missing config or permission
                    { model = model
                    , command = Cmd.none
                    }

        ExecutorMsg executorMsg ->
            when { config = model.config, cpPermission = model.cpPermission } is
                { config = Just cfg, cpPermission = Just cpPerm } ->
                    let
                        provider =
                            createProvider cfg cpPerm

                        executorConfig =
                            createExecutorConfig cfg provider

                        wrapper =
                            { model = model.executor
                            , cmd = Cmd.none
                            , toMsg = ExecutorMsg
                            }

                        executorResult =
                            Executor.update
                                executorMsg
                                model.executor
                                executorConfig
                                wrapper

                        updatedModel =
                            { model | executor = executorResult.model }
                    in
                    -- Check for state transitions
                    handleExecutorStateTransition updatedModel executorResult.cmd cfg

                _ ->
                    { model = model
                    , command = Cmd.none
                    }

        OutputWritten ->
            { model = model
            , command = Cmd.none
            }

        SessionSaved _ ->
            -- Session save is fire-and-forget
            { model = model
            , command = Cmd.none
            }

        ExitCodeSet ->
            { model = model
            , command = Cmd.none
            }


{-| Handle stdin content after it's been read.
-}
handleStdinContent : Model -> String -> { model : Model, command : Cmd Msg }
handleStdinContent model content =
    let
        trimmedContent =
            String.trim content

        -- Parse parameters from stdin
        parametersResult =
            if String.isEmpty trimmedContent then
                Ok Nothing
            else
                Decode.decodeString parametersDecoder trimmedContent
                    |> Result.map Just

        initialMessage =
            when parametersResult is
                Ok (Just params) ->
                    buildInitialMessage params

                _ ->
                    -- No parameters or parse error, use a default message
                    "Please begin working on the task."
    in
    { model =
        { model
            | stdinContent = Just content
            , initialMessage = Just initialMessage
        }
    , command = Cmd.none
    }


{-| Build the initial message from parameters.
-}
buildInitialMessage : Parameters -> String
buildInitialMessage params =
    let
        reviewSection =
            when params.reviewReport is
                Just path ->
                    "\nREVIEW_REPORT: " ++ path

                Nothing ->
                    ""

        qaSection =
            when params.qaReport is
                Just path ->
                    "\nQA_REPORT: " ++ path

                Nothing ->
                    ""
    in
    "TASK_FILE: "
        ++ params.taskFile
        ++ "\nSTATUS_FILE: "
        ++ params.statusFile
        ++ "\nREPORT_FILE: "
        ++ params.reportFile
        ++ reviewSection
        ++ qaSection
        ++ "\n\nRead your instructions from the TASK_FILE, then execute your workflow using the parameters above."


{-| Decode parameters from stdin JSON.
-}
parametersDecoder : Decode.Decoder Parameters
parametersDecoder =
    Decode.map5
        (\taskFile statusFile reportFile reviewReport qaReport ->
            { taskFile = taskFile
            , statusFile = statusFile
            , reportFile = reportFile
            , reviewReport = reviewReport
            , qaReport = qaReport
            }
        )
        (Decode.field "TASK_FILE" Decode.string)
        (Decode.field "STATUS_FILE" Decode.string)
        (Decode.field "REPORT_FILE" Decode.string)
        (Decode.maybe (Decode.field "REVIEW_REPORT" Decode.string))
        (Decode.maybe (Decode.field "QA_REPORT" Decode.string))


{-| Handle executor state transitions to trigger appropriate side effects.
-}
handleExecutorStateTransition :
    Model
    -> Cmd Msg
    -> ExecutorConfig
    -> { model : Model, command : Cmd Msg }
handleExecutorStateTransition model executorCmd config =
    when model.executor is
        Executor.Active state ->
            -- When we transition to Active, send the initial message if we haven't yet
            when { initialMessage = model.initialMessage, config = model.config, cpPermission = model.cpPermission } is
                { initialMessage = Just message, config = Just cfg, cpPermission = Just cpPerm } ->
                    let
                        provider =
                            createProvider cfg cpPerm
                    in
                    { model = { model | initialMessage = Nothing }  -- Clear to avoid re-sending
                    , command =
                        Cmd.batch
                            [ executorCmd
                            , provider.sendMessage
                                state.session
                                message
                                (\r -> ExecutorMsg (Executor.MessageSent r))
                            ]
                    }

                _ ->
                    { model = model
                    , command = executorCmd
                    }

        Executor.Complete { session, finalResponse } ->
            when { env = model.env, fsPermission = model.fsPermission } is
                { env = Just env, fsPermission = Just fsPerm } ->
                    { model = { model | status = Done }
                    , command =
                        Cmd.batch
                            [ executorCmd
                            , outputResponse env finalResponse
                            , saveSession fsPerm config.workspaceRoot session.id
                            ]
                    }

                _ ->
                    { model = model
                    , command = executorCmd
                    }

        Executor.Failed { error } ->
            let
                errorMsg =
                    Executor.executorErrorToString error
            in
            when model.env is
                Just env ->
                    { model = { model | status = Error errorMsg }
                    , command =
                        Cmd.batch
                            [ executorCmd
                            , outputErrorAndExit env errorMsg
                            ]
                    }

                Nothing ->
                    { model = model
                    , command = executorCmd
                    }

        _ ->
            -- Other states: just pass through the executor command
            { model = model
            , command = executorCmd
            }



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



-- HELPER FUNCTIONS


{-| Create a provider from config and child process permission.

This centralizes provider creation to avoid duplication across multiple handlers.
-}
createProvider : ExecutorConfig -> ChildProcess.Permission -> Provider.Provider Msg
createProvider cfg cpPerm =
    let
        providerConfig =
            { childProcessPermission = cpPerm
            , fileToolsPath = cfg.fileToolsPath
            }
    in
    ClaudeCode.provider providerConfig


{-| Create an executor config from our config and a provider.
-}
createExecutorConfig : ExecutorConfig -> Provider.Provider Msg -> Executor.Config Msg
createExecutorConfig cfg provider =
    { provider = provider
    , workspaceRoot = cfg.workspaceRoot
    , fileToolsPath = cfg.fileToolsPath
    }



-- OUTPUT HELPERS


{-| Output the final response to stdout and exit with code 0.
-}
outputResponse : Node.Environment -> String -> Cmd Msg
outputResponse env response =
    let
        outputJson =
            Encode.object
                [ { key = "status", value = Encode.string "complete" }
                , { key = "response", value = Encode.string response }
                ]
                |> Encode.encode 0
    in
    Stream.writeLineAsBytes outputJson env.stdout
        |> Task.onError (\_ -> Task.succeed env.stdout)
        |> Task.andThen (\_ -> Node.setExitCode 0)
        |> Task.map (\_ -> ExitCodeSet)
        |> Task.perform identity


{-| Output an error to stderr and exit with code 1.
-}
outputErrorAndExit : Node.Environment -> String -> Cmd Msg
outputErrorAndExit env errorMsg =
    let
        errorJson =
            Encode.object
                [ { key = "error", value = Encode.string errorMsg }
                ]
                |> Encode.encode 0
    in
    Stream.writeLineAsBytes errorJson env.stderr
        |> Task.onError (\_ -> Task.succeed env.stderr)
        |> Task.andThen (\_ -> Node.setExitCode 1)
        |> Task.map (\_ -> ExitCodeSet)
        |> Task.perform identity


{-| Save the session ID to the workspace.
-}
saveSession : FileSystem.Permission -> String -> String -> Cmd Msg
saveSession fsPermission workspaceRoot sessionId =
    let
        path =
            Path.fromPosixString (workspaceRoot ++ "/.session")

        bytes =
            Bytes.fromString sessionId
    in
    FileSystem.writeFile fsPermission bytes path
        |> Task.mapError FileSystem.errorToString
        |> Task.map (\_ -> {})
        |> Task.attempt SessionSaved
