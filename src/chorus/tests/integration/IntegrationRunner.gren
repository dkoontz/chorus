module IntegrationRunner exposing (main)

{-| Integration tests for Task.Registry.

These tests exercise the actual file I/O operations against the filesystem.
-}

import Bytes
import Crypto exposing (SecureContext)
import Dict
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Init
import Json.Decode as Decode
import Node
import Stream
import Task as GrenTask
import Task.Queue as Queue
import Task.Registry as Registry exposing (Registry, TaskStatus(..))
import Time


main : Node.SimpleProgram a
main =
    Node.defineSimpleProgram init


init : Node.Environment -> Init.Task (Cmd a)
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.awaitTask (getSecureContextOrCrash env) <| \secureContext ->
        let
            tempDir =
                Path.fromPosixString "/tmp/chorus-integration-test"

            ctx =
                { fsPermission = fsPermission
                , secureContext = secureContext
                , tempDir = tempDir
                , stdout = env.stdout
                }
        in
        Stream.writeLineAsBytes "Running 18 integration tests...\n" env.stdout
            |> GrenTask.onError (\_ -> GrenTask.succeed env.stdout)
            |> GrenTask.andThen (\_ -> setupTempDir fsPermission tempDir)
            |> GrenTask.andThen (\_ -> runAllTests ctx)
            |> GrenTask.andThen (\results -> reportResults ctx results)
            |> GrenTask.andThen
                (\exitCode ->
                    -- Cleanup temp dir
                    FileSystem.remove fsPermission { recursive = True } tempDir
                        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
                        |> GrenTask.map (\_ -> exitCode)
                )
            |> GrenTask.andThen
                (\exitCode ->
                    if exitCode > 0 then
                        Node.setExitCode exitCode
                    else
                        GrenTask.succeed {}
                )
            |> Node.endSimpleProgram


{-| Get the secure context, converting the empty error type to Never.
    The error type is {} which can never actually be constructed,
    so we just need to satisfy the type system.
-}
getSecureContextOrCrash : Node.Environment -> GrenTask.Task Never SecureContext
getSecureContextOrCrash _ =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed - this should never happen")


type alias Context =
    { fsPermission : FileSystem.Permission
    , secureContext : SecureContext
    , tempDir : Path
    , stdout : Stream.Writable Bytes.Bytes
    }


type alias TestResult =
    { name : String
    , passed : Bool
    , message : String
    }


setupTempDir : FileSystem.Permission -> Path -> GrenTask.Task x {}
setupTempDir fsPermission tempDir =
    -- Remove existing temp dir if present, then create fresh
    FileSystem.remove fsPermission { recursive = True } tempDir
        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
        |> GrenTask.andThen (\_ -> FileSystem.makeDirectory fsPermission { recursive = True } tempDir)
        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
        |> GrenTask.map (\_ -> {})


runAllTests : Context -> GrenTask.Task Never (Array TestResult)
runAllTests ctx =
    let
        tests =
            [ { name = "init creates registry directories"
              , run = testInitCreatesDirectories
              }
            , { name = "init creates registry.json"
              , run = testInitCreatesRegistryJson
              }
            , { name = "createTask creates task with UUID"
              , run = testCreateTaskCreatesTask
              }
            , { name = "createTask writes task.json"
              , run = testCreateTaskWritesTaskJson
              }
            , { name = "createTask writes queue.json"
              , run = testCreateTaskWritesQueueJson
              }
            , { name = "createTask writes history.json"
              , run = testCreateTaskWritesHistoryJson
              }
            , { name = "getTask returns created task"
              , run = testGetTaskReturnsTask
              }
            , { name = "getTask returns Nothing for missing task"
              , run = testGetTaskReturnsNothingForMissing
              }
            , { name = "updateTask modifies task status"
              , run = testUpdateTaskModifiesStatus
              }
            , { name = "listTasks returns all tasks"
              , run = testListTasksReturnsAll
              }
            , { name = "listTasks filters by status"
              , run = testListTasksFiltersByStatus
              }
            , { name = "recordEvent appends to history"
              , run = testRecordEventAppendsToHistory
              }
            -- Queue tests
            , { name = "enqueue adds message to queue"
              , run = testEnqueueAddsMessage
              }
            , { name = "dequeue returns messages in FIFO order"
              , run = testDequeueFIFO
              }
            , { name = "dequeue returns Nothing for empty queue"
              , run = testDequeueEmptyQueue
              }
            , { name = "peek returns message without removing"
              , run = testPeekDoesNotRemove
              }
            , { name = "isEmpty returns correct status"
              , run = testIsEmpty
              }
            , { name = "length returns correct count"
              , run = testQueueLength
              }
            ]
    in
    tests
        |> Array.foldl
            (\test acc ->
                acc
                    |> GrenTask.andThen
                        (\results ->
                            runTest ctx test
                                |> GrenTask.map (\result -> Array.pushLast result results)
                        )
            )
            (GrenTask.succeed [])


runTest :
    Context
    -> { name : String, run : Context -> String -> GrenTask.Task String {} }
    -> GrenTask.Task Never TestResult
runTest ctx test =
    -- Each test gets a unique subdirectory
    let
        subdir =
            test.name
                |> String.replace " " "-"
                |> String.toLower
    in
    test.run ctx subdir
        |> GrenTask.map
            (\_ ->
                { name = test.name
                , passed = True
                , message = ""
                }
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    { name = test.name
                    , passed = False
                    , message = err
                    }
            )


reportResults : Context -> Array TestResult -> GrenTask.Task Never Int
reportResults ctx results =
    let
        passed =
            Array.keepIf .passed results
                |> Array.length

        failed =
            Array.keepIf (\r -> not r.passed) results
                |> Array.length

        failedTests =
            Array.keepIf (\r -> not r.passed) results

        summary =
            String.fromInt passed
                ++ " passed, "
                ++ String.fromInt failed
                ++ " failed"

        failureDetails =
            failedTests
                |> Array.map
                    (\r ->
                        "  FAIL: "
                            ++ r.name
                            ++ "\n    "
                            ++ r.message
                    )
                |> String.join "\n"

        output =
            if failed > 0 then
                "\n" ++ failureDetails ++ "\n\n" ++ summary ++ "\n"
            else
                summary ++ "\n"
    in
    Stream.writeLineAsBytes output ctx.stdout
        |> GrenTask.onError (\_ -> GrenTask.succeed ctx.stdout)
        |> GrenTask.map (\_ -> failed)



-- Test helpers


initRegistry : Context -> String -> GrenTask.Task String Registry
initRegistry ctx subdir =
    let
        -- Path.append prepends the second argument to the first
        -- so we need Path.append childPath parentPath to get parent/child
        registryRoot =
            Path.append (Path.fromPosixString (subdir ++ "/registry")) ctx.tempDir

        workspacesRoot =
            Path.append (Path.fromPosixString (subdir ++ "/workspaces")) ctx.tempDir
    in
    Registry.init ctx.fsPermission ctx.secureContext
        { registryRoot = Path.toPosixString registryRoot
        , workspacesRoot = Path.toPosixString workspacesRoot
        }
        |> GrenTask.mapError registryErrorToString


registryErrorToString : Registry.Error -> String
registryErrorToString err =
    when err is
        Registry.FileSystemError msg ->
            "FileSystemError: " ++ msg

        Registry.JsonDecodeError msg ->
            "JsonDecodeError: " ++ msg

        Registry.TaskNotFound id ->
            "TaskNotFound: " ++ id

        Registry.RegistryCorrupt msg ->
            "RegistryCorrupt: " ++ msg


assertFileExists : FileSystem.Permission -> Path -> GrenTask.Task String {}
assertFileExists fsPermission path =
    FileSystem.checkAccess fsPermission [] path
        |> GrenTask.map (\_ -> {})
        |> GrenTask.mapError (\_ -> "File does not exist: " ++ Path.toPosixString path)


assertEqual : String -> a -> a -> GrenTask.Task String {}
assertEqual description expected actual =
    if expected == actual then
        GrenTask.succeed {}
    else
        GrenTask.fail (description ++ ": expected " ++ Debug.toString expected ++ " but got " ++ Debug.toString actual)


assertJust : String -> Maybe a -> GrenTask.Task String a
assertJust description maybeValue =
    when maybeValue is
        Just value ->
            GrenTask.succeed value

        Nothing ->
            GrenTask.fail (description ++ ": expected Just but got Nothing")


assertNothing : String -> Maybe a -> GrenTask.Task String {}
assertNothing description maybeValue =
    when maybeValue is
        Nothing ->
            GrenTask.succeed {}

        Just _ ->
            GrenTask.fail (description ++ ": expected Nothing but got Just")



-- Individual tests


testInitCreatesDirectories : Context -> String -> GrenTask.Task String {}
testInitCreatesDirectories ctx subdir =
    let
        registryRoot =
            Path.append (Path.fromPosixString (subdir ++ "/registry")) ctx.tempDir

        workspacesRoot =
            Path.append (Path.fromPosixString (subdir ++ "/workspaces")) ctx.tempDir
    in
    initRegistry ctx subdir
        |> GrenTask.andThen (\_ -> assertFileExists ctx.fsPermission registryRoot)
        |> GrenTask.andThen (\_ -> assertFileExists ctx.fsPermission workspacesRoot)


testInitCreatesRegistryJson : Context -> String -> GrenTask.Task String {}
testInitCreatesRegistryJson ctx subdir =
    let
        registryJsonPath =
            Path.append (Path.fromPosixString (subdir ++ "/registry/registry.json")) ctx.tempDir
    in
    initRegistry ctx subdir
        |> GrenTask.andThen (\_ -> assertFileExists ctx.fsPermission registryJsonPath)


testCreateTaskCreatesTask : Context -> String -> GrenTask.Task String {}
testCreateTaskCreatesTask ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                -- UUID should be 36 characters (8-4-4-4-12 format)
                let
                    tid =
                        Registry.taskId task
                in
                if String.unitLength tid == 36 then
                    GrenTask.succeed {}
                else
                    GrenTask.fail ("Expected UUID to be 36 chars, got " ++ String.fromInt (String.unitLength tid))
            )


testCreateTaskWritesTaskJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesTaskJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Registry.taskId task ++ "/task.json")) ctx.tempDir
                in
                assertFileExists ctx.fsPermission taskJsonPath
            )


testCreateTaskWritesQueueJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesQueueJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    queueJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Registry.taskId task ++ "/queue.json")) ctx.tempDir
                in
                assertFileExists ctx.fsPermission queueJsonPath
            )


testCreateTaskWritesHistoryJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesHistoryJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    historyJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Registry.taskId task ++ "/history.json")) ctx.tempDir
                in
                assertFileExists ctx.fsPermission historyJsonPath
            )


testGetTaskReturnsTask : Context -> String -> GrenTask.Task String {}
testGetTaskReturnsTask ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.getTask registry (Registry.taskId task)
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.andThen (assertJust "getTask")
                    |> GrenTask.andThen
                        (\retrieved ->
                            assertEqual "task description" (Registry.taskDescription task) (Registry.taskDescription retrieved)
                        )
            )


testGetTaskReturnsNothingForMissing : Context -> String -> GrenTask.Task String {}
testGetTaskReturnsNothingForMissing ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.getTask registry "nonexistent-task-id"
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.andThen (assertNothing "getTask for missing task")
            )


testUpdateTaskModifiesStatus : Context -> String -> GrenTask.Task String {}
testUpdateTaskModifiesStatus ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.updateStatus registry (Registry.taskId task) Active
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\updatedTask ->
                when Registry.taskStatus updatedTask is
                    Active ->
                        GrenTask.succeed {}

                    _ ->
                        GrenTask.fail ("Expected Active status, got " ++ Debug.toString (Registry.taskStatus updatedTask))
            )


testListTasksReturnsAll : Context -> String -> GrenTask.Task String {}
testListTasksReturnsAll ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                -- Create two tasks
                Registry.createTask registry
                    { description = "Task 1"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Task 2"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.listTasks registry Nothing
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\tasks ->
                assertEqual "number of tasks" 2 (Array.length tasks)
            )


testListTasksFiltersByStatus : Context -> String -> GrenTask.Task String {}
testListTasksFiltersByStatus ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                -- Create a task and update it to Active
                Registry.createTask registry
                    { description = "Active Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.andThen
                        (\task ->
                            Registry.updateStatus registry (Registry.taskId task) Active
                                |> GrenTask.mapError registryErrorToString
                                |> GrenTask.map (\_ -> registry)
                        )
            )
        |> GrenTask.andThen
            (\registry ->
                -- Create a Pending task
                Registry.createTask registry
                    { description = "Pending Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.listTasks registry (Just Active)
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\tasks ->
                assertEqual "number of Active tasks" 1 (Array.length tasks)
            )


testRecordEventAppendsToHistory : Context -> String -> GrenTask.Task String {}
testRecordEventAppendsToHistory ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.recordEvent registry (Registry.taskId task)
                    { eventType = "test_event"
                    , data = Dict.singleton "key" "value"
                    }
                    |> GrenTask.mapError registryErrorToString
                    |> GrenTask.map (\_ -> task)
            )
        |> GrenTask.andThen
            (\task ->
                -- Read the history file and verify it has 2 events (created + test_event)
                let
                    historyPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Registry.taskId task ++ "/history.json")) ctx.tempDir
                in
                FileSystem.readFile ctx.fsPermission historyPath
                    |> GrenTask.mapError (\e -> "Failed to read history: " ++ FileSystem.errorToString e)
                    |> GrenTask.andThen
                        (\bytes ->
                            when Bytes.toString bytes is
                                Nothing ->
                                    GrenTask.fail "Could not decode history file as UTF-8"

                                Just content ->
                                    let
                                        eventsCountDecoder =
                                            Decode.field "events" (Decode.array (Decode.succeed {}))
                                                |> Decode.map Array.length
                                    in
                                    when Decode.decodeString eventsCountDecoder content is
                                        Ok count ->
                                            assertEqual "number of events" 2 count

                                        Err err ->
                                            GrenTask.fail ("Failed to decode history: " ++ Decode.errorToString err)
                        )
            )



-- Queue integration tests


{-| Helper to get the task directory path for queue operations.
-}
getTaskDir : Context -> String -> String -> Path
getTaskDir ctx subdir taskId =
    Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ taskId)) ctx.tempDir


queueErrorToString : Queue.Error -> String
queueErrorToString err =
    when err is
        Queue.FileSystemError msg ->
            "FileSystemError: " ++ msg

        Queue.JsonDecodeError msg ->
            "JsonDecodeError: " ++ msg

        Queue.TaskNotFound id ->
            "TaskNotFound: " ++ id


testEnqueueAddsMessage : Context -> String -> GrenTask.Task String {}
testEnqueueAddsMessage ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Queue Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Registry.taskId task)
                in
                Queue.enqueue ctx.fsPermission ctx.secureContext taskDir (Registry.taskId task) "Hello, world!"
                    |> GrenTask.mapError queueErrorToString
            )
        |> GrenTask.andThen
            (\message ->
                -- Verify the message has a UUID (36 chars)
                if String.unitLength message.id == 36 then
                    assertEqual "message content" "Hello, world!" message.content
                else
                    GrenTask.fail ("Expected UUID to be 36 chars, got " ++ String.fromInt (String.unitLength message.id))
            )


testDequeueFIFO : Context -> String -> GrenTask.Task String {}
testDequeueFIFO ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Queue FIFO Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    tid =
                        Registry.taskId task

                    taskDir =
                        getTaskDir ctx subdir tid
                in
                -- Enqueue two messages
                Queue.enqueue ctx.fsPermission ctx.secureContext taskDir tid "First message"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.fsPermission ctx.secureContext taskDir tid "Second message"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Dequeue first message
                Queue.dequeue ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected first message but got Nothing"

                                Just msg ->
                                    assertEqual "first message content" "First message" msg.content
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            -- Dequeue second message
                            Queue.dequeue ctx.fsPermission taskDir
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected second message but got Nothing"

                                Just msg ->
                                    assertEqual "second message content" "Second message" msg.content
                        )
            )


testDequeueEmptyQueue : Context -> String -> GrenTask.Task String {}
testDequeueEmptyQueue ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Empty Queue Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Registry.taskId task)
                in
                Queue.dequeue ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertNothing "dequeue from empty queue")
            )


testPeekDoesNotRemove : Context -> String -> GrenTask.Task String {}
testPeekDoesNotRemove ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Peek Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Registry.taskId task)
                in
                Queue.enqueue ctx.fsPermission ctx.secureContext taskDir (Registry.taskId task) "Peek me"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Peek should return the message
                Queue.peek ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected message from peek but got Nothing"

                                Just msg ->
                                    assertEqual "peeked message content" "Peek me" msg.content
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            -- Peek again - should still return the same message (not removed)
                            Queue.peek ctx.fsPermission taskDir
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected message from second peek but got Nothing"

                                Just msg ->
                                    assertEqual "second peeked message content" "Peek me" msg.content
                        )
            )


testIsEmpty : Context -> String -> GrenTask.Task String {}
testIsEmpty ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "IsEmpty Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Registry.taskId task)
                in
                -- Should be empty initially
                Queue.isEmpty ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\empty ->
                            if empty then
                                GrenTask.succeed taskDir
                            else
                                GrenTask.fail "Expected queue to be empty initially"
                        )
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Add a message
                Queue.enqueue ctx.fsPermission ctx.secureContext taskDir "test" "Message"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Should not be empty now
                Queue.isEmpty ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\empty ->
                            if not empty then
                                GrenTask.succeed {}
                            else
                                GrenTask.fail "Expected queue to not be empty after enqueue"
                        )
            )


testQueueLength : Context -> String -> GrenTask.Task String {}
testQueueLength ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Length Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError registryErrorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    tid =
                        Registry.taskId task

                    taskDir =
                        getTaskDir ctx subdir tid
                in
                -- Should be 0 initially
                Queue.length ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertEqual "initial length" 0)
                    |> GrenTask.map (\_ -> { taskDir = taskDir, taskId = tid })
            )
        |> GrenTask.andThen
            (\{ taskDir, taskId } ->
                -- Add 3 messages
                Queue.enqueue ctx.fsPermission ctx.secureContext taskDir taskId "One"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.fsPermission ctx.secureContext taskDir taskId "Two"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.fsPermission ctx.secureContext taskDir taskId "Three"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Should be 3 now
                Queue.length ctx.fsPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertEqual "length after 3 enqueues" 3)
            )
