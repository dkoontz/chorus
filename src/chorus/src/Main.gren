module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Bytes
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode as Decode
import Node
import Stream
import Task as GrenTask
import Task.Registry as Registry
import Time
import Web.Api as Api
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , fsPermission : FileSystem.Permission
    , secureContext : SecureContext
    , config : Config
    , status : Status
    , pendingResponses : Array PendingResponse
    }


type alias PendingResponse =
    { response : Response
    , id : Int
    }


type alias Config =
    { host : String
    , port_ : Int
    , registryRoot : String
    , workspacesRoot : String
    , staticRoot : String
    , logLevel : LogLevel
    }


{-| Log level for controlling output verbosity.

    - LogError: Only errors
    - LogWarn: Warnings and errors
    - LogInfo: Normal operation (default)
    - LogDebug: Verbose output including request details

-}
type LogLevel
    = LogError
    | LogWarn
    | LogInfo
    | LogDebug


type Status
    = Initializing
    | Running
    | Error String


defaultConfig : Config
defaultConfig =
    { host = "0.0.0.0"
    , port_ = 8080
    , registryRoot = "./data/registry"
    , workspacesRoot = "./data/workspaces"
    , staticRoot = "./static"
    , logLevel = LogInfo
    }


{-| Create configuration from environment variables.

    Supported environment variables:
    - CHORUS_HOST: Server host (default: 0.0.0.0)
    - CHORUS_PORT: Server port (default: 8080)
    - CHORUS_DATA_DIR: Base data directory (default: ./data)
    - CHORUS_STATIC_DIR: Static files directory (default: ./static)
    - CHORUS_LOG_LEVEL: Log level - error, warn, info, debug (default: info)

-}
configFromEnv : Dict String String -> Config -> Config
configFromEnv envVars config =
    let
        host =
            Dict.get "CHORUS_HOST" envVars
                |> Maybe.withDefault config.host

        port_ =
            Dict.get "CHORUS_PORT" envVars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault config.port_

        dataDir =
            Dict.get "CHORUS_DATA_DIR" envVars
                |> Maybe.withDefault "./data"

        staticRoot =
            Dict.get "CHORUS_STATIC_DIR" envVars
                |> Maybe.withDefault config.staticRoot

        logLevel =
            Dict.get "CHORUS_LOG_LEVEL" envVars
                |> Maybe.andThen parseLogLevel
                |> Maybe.withDefault config.logLevel
    in
    { host = host
    , port_ = port_
    , registryRoot = dataDir ++ "/registry"
    , workspacesRoot = dataDir ++ "/workspaces"
    , staticRoot = staticRoot
    , logLevel = logLevel
    }


{-| Parse a log level string.
-}
parseLogLevel : String -> Maybe LogLevel
parseLogLevel str =
    when String.toLower str is
        "error" ->
            Just LogError

        "warn" ->
            Just LogWarn

        "info" ->
            Just LogInfo

        "debug" ->
            Just LogDebug

        _ ->
            Nothing



-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
        Init.awaitTask getSecureContext <| \secureContext ->
            Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                Init.await HttpServer.initialize <| \httpPermission ->
                    let
                        config =
                            configFromEnv envVars defaultConfig

                        model =
                            { env = env
                            , server = Nothing
                            , registry = Nothing
                            , fsPermission = fsPermission
                            , secureContext = secureContext
                            , config = config
                            , status = Initializing
                            , pendingResponses = []
                            }
                    in
                    Node.startProgram
                        { model = model
                        , command =
                            Cmd.batch
                                [ -- Initialize the HTTP server
                                  Server.createServer httpPermission
                                    { host = config.host
                                    , port_ = config.port_
                                    }
                                    |> GrenTask.attempt GotServer

                                , -- Initialize the task registry
                                  Registry.init fsPermission secureContext
                                    { registryRoot = config.registryRoot
                                    , workspacesRoot = config.workspacesRoot
                                    }
                                    |> GrenTask.attempt GotRegistry

                                , -- Log startup
                                  logInfoInit env config ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.port_)
                                ]
                        }



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = logInfo model "HTTP server started"
                    }

                Err err ->
                    { model = { model | status = Error (Server.errorToString err) }
                    , command = logError model ("Server error: " ++ Server.errorToString err)
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    { model =
                        { model
                            | registry = Just registry
                            , status = Running
                        }
                    , command = logInfo model "Task registry initialized"
                    }

                Err err ->
                    { model = { model | status = Error (registryErrorToString err) }
                    , command = logError model ("Registry error: " ++ registryErrorToString err)
                    }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            logDebug model ("Request body: " ++ bodyStr)
            in
            { model = model
            , command =
                Cmd.batch
                    [ logInfo model
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { fsPermission = model.fsPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        _ ->
            -- API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , fsPermission = model.fsPermission
                            , secureContext = model.secureContext
                            , registryRoot = Path.fromPosixString model.config.registryRoot
                            }

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody ("{\"error\":{\"code\":\"BAD_REQUEST\",\"message\":\"" ++ message ++ "\"}}")
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\title source ->
                    { title = title
                    , source = source
                    }
                )
                (Decode.field "title" Decode.string)
                (Decode.field "source" sourceDecoder)

        sourceDecoder =
            Decode.map3
                (\sourceType userId conversationId ->
                    { sourceType = sourceType
                    , userId = userId
                    , conversationId = conversationId
                    }
                )
                (Decode.field "sourceType" Decode.string)
                (Decode.field "userId" Decode.string)
                (Decode.maybe (Decode.field "conversationId" Decode.string))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.
-}
parseStatusBody : HttpServer.Request -> Result String Registry.TaskStatus
parseStatusBody request =
    let
        decoder =
            Decode.field "status" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok statusStr ->
            when statusStr is
                "pending" ->
                    Ok Registry.Pending

                "active" ->
                    Ok Registry.Active

                "waiting" ->
                    Ok Registry.Waiting

                "completed" ->
                    Ok Registry.Completed

                "failed" ->
                    Ok (Registry.Failed "")

                _ ->
                    Err ("Unknown status: " ++ statusStr)

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

        Nothing ->
            Sub.none



-- LOGGING


{-| Log at INFO level during init (before model exists).
-}
logInfoInit : Node.Environment -> Config -> String -> Cmd Msg
logInfoInit env config message =
    writeLogAtLevelInit env config LogInfo "INFO" message


{-| Write a log message during init phase.
-}
writeLogAtLevelInit : Node.Environment -> Config -> LogLevel -> String -> String -> Cmd Msg
writeLogAtLevelInit env config msgLevel levelStr message =
    if shouldLog config.logLevel msgLevel then
        Time.now
            |> GrenTask.andThen
                (\now ->
                    let
                        timestamp =
                            formatTimestamp now

                        line =
                            "[Chorus " ++ timestamp ++ "] [" ++ levelStr ++ "] " ++ message
                    in
                    Stream.writeLineAsBytes line env.stdout
                )
            |> GrenTask.onError (\_ -> GrenTask.succeed env.stdout)
            |> GrenTask.map (\_ -> NoOp)
            |> GrenTask.perform identity
    else
        Cmd.none


{-| Log at ERROR level.
-}
logError : Model -> String -> Cmd Msg
logError model message =
    writeLogAtLevel model LogError "ERROR" message


{-| Log at WARN level.
-}
logWarn : Model -> String -> Cmd Msg
logWarn model message =
    writeLogAtLevel model LogWarn "WARN" message


{-| Log at INFO level.
-}
logInfo : Model -> String -> Cmd Msg
logInfo model message =
    writeLogAtLevel model LogInfo "INFO" message


{-| Log at DEBUG level.
-}
logDebug : Model -> String -> Cmd Msg
logDebug model message =
    writeLogAtLevel model LogDebug "DEBUG" message


{-| Write a log message if the configured level allows it.
-}
writeLogAtLevel : Model -> LogLevel -> String -> String -> Cmd Msg
writeLogAtLevel model msgLevel levelStr message =
    if shouldLog model.config.logLevel msgLevel then
        Time.now
            |> GrenTask.andThen
                (\now ->
                    let
                        timestamp =
                            formatTimestamp now

                        line =
                            "[Chorus " ++ timestamp ++ "] [" ++ levelStr ++ "] " ++ message
                    in
                    Stream.writeLineAsBytes line model.env.stdout
                )
            |> GrenTask.onError (\_ -> GrenTask.succeed model.env.stdout)
            |> GrenTask.map (\_ -> NoOp)
            |> GrenTask.perform identity
    else
        Cmd.none


{-| Check if a message at the given level should be logged.
-}
shouldLog : LogLevel -> LogLevel -> Bool
shouldLog configLevel msgLevel =
    logLevelToInt msgLevel >= logLevelToInt configLevel


{-| Convert log level to integer for comparison.
-}
logLevelToInt : LogLevel -> Int
logLevelToInt level =
    when level is
        LogDebug ->
            0

        LogInfo ->
            1

        LogWarn ->
            2

        LogError ->
            3


{-| Format a timestamp as ISO 8601.

    Uses a simplified algorithm to avoid importing additional modules.

-}
formatTimestamp : Time.Posix -> String
formatTimestamp time =
    let
        millis =
            Time.posixToMillis time

        totalSeconds =
            millis // 1000

        -- Use integer division and subtraction to compute remainder
        -- since modBy isn't directly available
        seconds =
            totalSeconds - ((totalSeconds // 60) * 60)

        totalMinutes =
            totalSeconds // 60

        minutes =
            totalMinutes - ((totalMinutes // 60) * 60)

        totalHours =
            totalMinutes // 60

        hours =
            totalHours - ((totalHours // 24) * 24)

        -- Days since epoch (1970-01-01)
        days =
            totalHours // 24

        -- Calculate year, month, day from days since epoch
        { year, month, day } =
            daysToDate days
    in
    String.fromInt year
        ++ "-"
        ++ padZero month
        ++ "-"
        ++ padZero day
        ++ "T"
        ++ padZero hours
        ++ ":"
        ++ padZero minutes
        ++ ":"
        ++ padZero seconds
        ++ "Z"


{-| Pad a number with leading zero if needed.
-}
padZero : Int -> String
padZero n =
    if n < 10 then
        "0" ++ String.fromInt n

    else
        String.fromInt n


{-| Convert days since Unix epoch to year, month, day.
-}
daysToDate : Int -> { year : Int, month : Int, day : Int }
daysToDate totalDays =
    let
        -- Algorithm to convert days since epoch to date
        -- Based on the algorithm from Howard Hinnant
        z =
            totalDays + 719468

        era =
            (if z >= 0 then
                z

             else
                z - 146096
            )
                // 146097

        doe =
            z - (era * 146097)

        yoe =
            (doe - (doe // 1460) + (doe // 36524) - (doe // 146096)) // 365

        y =
            yoe + (era * 400)

        doy =
            doe - ((365 * yoe) + (yoe // 4) - (yoe // 100))

        mp =
            ((5 * doy) + 2) // 153

        d =
            doy - (((153 * mp) + 2) // 5) + 1

        m =
            mp
                + (if mp < 10 then
                    3

                   else
                    -9
                  )

        year =
            y
                + (if m <= 2 then
                    1

                   else
                    0
                  )
    in
    { year = year, month = m, day = d }



-- HELPERS


{-| Convert registry error to string.
-}
registryErrorToString : Registry.Error -> String
registryErrorToString err =
    when err is
        Registry.FileSystemError msg ->
            "File system error: " ++ msg

        Registry.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Registry.TaskNotFound id ->
            "Task not found: " ++ id

        Registry.RegistryCorrupt msg ->
            "Registry corrupt: " ++ msg


{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")
