module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Bytes
import ChildProcess
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode as Decode
import Logging exposing (LogLevel(..))
import Node
import Stream
import Task as GrenTask
import Task.Registry as Registry
import Web.Api as Api
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , secureContext : SecureContext
    , config : Config
    , status : Status
    , pendingResponses : Array PendingResponse
    , logger : Logging.Logger
    }


type alias PendingResponse =
    { response : Response
    , id : Int
    }


type alias Config =
    { host : String
    , port_ : Int
    , registryRoot : String
    , workspacesRoot : String
    , staticRoot : String
    , uploadDir : String
    , logLevel : LogLevel
    }


type Status
    = Initializing
    | Running
    | Error String


defaultConfig : Config
defaultConfig =
    { host = "0.0.0.0"
    , port_ = 8080
    , registryRoot = "./data/registry"
    , workspacesRoot = "./data/workspaces"
    , staticRoot = "./static"
    , uploadDir = "./data/uploads"
    , logLevel = LogInfo
    }


{-| Create configuration from environment variables.

    Supported environment variables:
    - CHORUS_HOST: Server host (default: 0.0.0.0)
    - CHORUS_PORT: Server port (default: 8080)
    - CHORUS_DATA_DIR: Base data directory (default: ./data)
    - CHORUS_STATIC_DIR: Static files directory (default: ./static)
    - CHORUS_LOG_LEVEL: Log level - error, warn, info, debug (default: info)

-}
configFromEnv : Dict String String -> Config -> Config
configFromEnv envVars config =
    let
        host =
            Dict.get "CHORUS_HOST" envVars
                |> Maybe.withDefault config.host

        port_ =
            Dict.get "CHORUS_PORT" envVars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault config.port_

        dataDir =
            Dict.get "CHORUS_DATA_DIR" envVars
                |> Maybe.withDefault "./data"

        staticRoot =
            Dict.get "CHORUS_STATIC_DIR" envVars
                |> Maybe.withDefault config.staticRoot

        logLevel =
            Dict.get "CHORUS_LOG_LEVEL" envVars
                |> Maybe.andThen Logging.parseLogLevel
                |> Maybe.withDefault config.logLevel

        uploadDir =
            Dict.get "CHORUS_UPLOAD_DIR" envVars
                |> Maybe.withDefault (dataDir ++ "/uploads")
    in
    { host = host
    , port_ = port_
    , registryRoot = dataDir ++ "/registry"
    , workspacesRoot = dataDir ++ "/workspaces"
    , staticRoot = staticRoot
    , uploadDir = uploadDir
    , logLevel = logLevel
    }


-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | GotBinaryResult { response : Response, result : Api.BinaryResult }
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
        Init.await ChildProcess.initialize <| \cpPermission ->
            Init.awaitTask getSecureContext <| \secureContext ->
                Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                    Init.await HttpServer.initialize <| \httpPermission ->
                        let
                            config =
                                configFromEnv envVars defaultConfig

                            logger =
                                Logging.makeLogger env.stdout config.logLevel

                            model =
                                { env = env
                                , server = Nothing
                                , registry = Nothing
                                , fsPermission = fsPermission
                                , cpPermission = cpPermission
                                , secureContext = secureContext
                                , config = config
                                , status = Initializing
                                , pendingResponses = []
                                , logger = logger
                                }
                        in
                        Node.startProgram
                            { model = model
                            , command =
                                Cmd.batch
                                    [ -- Initialize the HTTP server
                                      Server.createServer httpPermission
                                        { host = config.host
                                        , port_ = config.port_
                                        }
                                        |> GrenTask.attempt GotServer

                                    , -- Initialize the task registry
                                      Registry.init fsPermission secureContext
                                        { registryRoot = config.registryRoot
                                        , workspacesRoot = config.workspacesRoot
                                        }
                                        |> GrenTask.attempt GotRegistry

                                    , -- Log startup
                                      Logging.logInfo logger ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.port_) NoOp
                                    ]
                            }



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = Logging.logInfo model.logger "HTTP server started" NoOp
                    }

                Err err ->
                    { model = { model | status = Error (Server.errorToString err) }
                    , command = Logging.logError model.logger ("Server error: " ++ Server.errorToString err) NoOp
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    { model =
                        { model
                            | registry = Just registry
                            , status = Running
                        }
                    , command = Logging.logInfo model.logger "Task registry initialized" NoOp
                    }

                Err err ->
                    { model = { model | status = Error (registryErrorToString err) }
                    , command = Logging.logError model.logger ("Registry error: " ++ registryErrorToString err) NoOp
                    }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            Logging.logDebug model.logger ("Request body: " ++ bodyStr) NoOp
            in
            { model = model
            , command =
                Cmd.batch
                    [ Logging.logInfo model.logger
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                        NoOp
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotBinaryResult { response, result } ->
            { model = model
            , command = Api.sendBinaryResponse response result
            }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { fsPermission = model.fsPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        _ ->
            -- API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , fsPermission = model.fsPermission
                            , secureContext = model.secureContext
                            , registryRoot = Path.fromPosixString model.config.registryRoot
                            }

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UploadAttachment { taskId, filename } ->
                            Api.requestUploadAttachment ctx taskId filename request.body model.config.uploadDir toMsg

                        Router.DownloadAttachment { taskId, filename } ->
                            let
                                toBinaryMsg =
                                    \binaryResult -> GotBinaryResult { response = response, result = binaryResult }
                            in
                            Api.requestDownloadAttachment ctx taskId filename model.config.uploadDir toBinaryMsg

                        Router.DeleteAttachment { taskId, filename } ->
                            Api.requestDeleteAttachment ctx taskId filename model.config.uploadDir toMsg

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody ("{\"error\":{\"code\":\"BAD_REQUEST\",\"message\":\"" ++ message ++ "\"}}")
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\description source ->
                    { description = description
                    , source = source
                    }
                )
                (Decode.field "description" Decode.string)
                (Decode.field "source" sourceDecoder)

        sourceDecoder =
            Decode.map3
                (\sourceType userId conversationId ->
                    { sourceType = sourceType
                    , userId = userId
                    , conversationId = conversationId
                    }
                )
                (Decode.field "sourceType" Decode.string)
                (Decode.field "userId" Decode.string)
                (Decode.maybe (Decode.field "conversationId" Decode.string))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.
-}
parseStatusBody : HttpServer.Request -> Result String Registry.TaskStatus
parseStatusBody request =
    let
        decoder =
            Decode.field "status" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok statusStr ->
            when statusStr is
                "pending" ->
                    Ok Registry.Pending

                "active" ->
                    Ok Registry.Active

                "waiting" ->
                    Ok Registry.Waiting

                "completed" ->
                    Ok Registry.Completed

                "failed" ->
                    Ok (Registry.Failed "")

                _ ->
                    Err ("Unknown status: " ++ statusStr)

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

        Nothing ->
            Sub.none



-- HELPERS


{-| Convert registry error to string.
-}
registryErrorToString : Registry.Error -> String
registryErrorToString err =
    when err is
        Registry.FileSystemError msg ->
            "File system error: " ++ msg

        Registry.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Registry.TaskNotFound id ->
            "Task not found: " ++ id

        Registry.RegistryCorrupt msg ->
            "Registry corrupt: " ++ msg


{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")
