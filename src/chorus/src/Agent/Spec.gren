module Agent.Spec exposing
    ( AgentSpec
    , ParseError(..)
    , parseErrorToString
    , parse
    , parseFromString
    )

{-| Parse agent specifications from markdown files.

Agent specs are markdown files with a title and optional sections.
The system prompt is extracted as all content between the title
and the first `##` heading.

Example agent spec:

    # Developer Agent

    You are a developer agent responsible for implementing
    technical requirements while ensuring code quality.

    ## Parameters
    ...

    ## Your Workflow
    ...

The name would be "Developer Agent" and the system prompt would be
the paragraph starting with "You are a developer...".
-}

import Bytes exposing (Bytes)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Task exposing (Task)


-- TYPES


{-| An agent specification.
-}
type alias AgentSpec =
    { name : String
    , systemPrompt : String
    }


{-| Errors that can occur when parsing an agent spec.
-}
type ParseError
    = FileReadError FileSystem.Error
    | EncodingError { reason : String }
    | MissingTitle { reason : String }
    | EmptySystemPrompt { reason : String }


{-| Convert a parse error to a human-readable string.
-}
parseErrorToString : ParseError -> String
parseErrorToString error =
    when error is
        FileReadError fsError ->
            "Failed to read agent spec file: " ++ FileSystem.errorToString fsError

        EncodingError { reason } ->
            "Failed to decode agent spec file: " ++ reason

        MissingTitle { reason } ->
            "Agent spec missing title: " ++ reason

        EmptySystemPrompt { reason } ->
            "Agent spec has empty system prompt: " ++ reason



-- PARSING


{-| Parse an agent spec from a file.
-}
parse : FileSystem.Permission -> Path -> Task ParseError AgentSpec
parse fsPermission path =
    FileSystem.readFile fsPermission path
        |> Task.mapError FileReadError
        |> Task.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        Task.fail (EncodingError { reason = "Could not decode file as UTF-8" })

                    Just content ->
                        when parseFromString content is
                            Err parseError ->
                                Task.fail parseError

                            Ok spec ->
                                Task.succeed spec
            )


{-| Parse an agent spec from a string.

This is the pure parsing function that can be tested without IO.
-}
parseFromString : String -> Result ParseError AgentSpec
parseFromString content =
    let
        lines =
            String.split "\n" content

        -- Find the title line (first line starting with "# ")
        titleResult =
            lines
                |> Array.keepIf (\line -> String.startsWith "# " line)
                |> Array.first
                |> Maybe.map (\line -> String.dropFirst 2 line |> String.trim)
                |> Result.fromMaybe (MissingTitle { reason = "No line starting with '# ' found" })

        -- Find the index of the title line
        titleIndex =
            lines
                |> Array.indexedMap (\i line -> { index = i, line = line })
                |> Array.keepIf (\item -> String.startsWith "# " item.line)
                |> Array.first
                |> Maybe.map .index
                |> Maybe.withDefault 0

        -- Find the index of the first ## heading
        firstSectionIndex =
            lines
                |> Array.indexedMap (\i line -> { index = i, line = line })
                |> Array.keepIf (\item -> item.index > titleIndex && String.startsWith "## " item.line)
                |> Array.first
                |> Maybe.map .index

        -- Extract the system prompt (content between title and first ## heading)
        systemPromptLines =
            when firstSectionIndex is
                Just sectionIdx ->
                    lines
                        |> Array.dropFirst (titleIndex + 1)
                        |> Array.takeFirst (sectionIdx - titleIndex - 1)

                Nothing ->
                    -- No sections, everything after title is system prompt
                    Array.dropFirst (titleIndex + 1) lines

        systemPrompt =
            systemPromptLines
                |> String.join "\n"
                |> String.trim
    in
    titleResult
        |> Result.andThen
            (\name ->
                if String.isEmpty systemPrompt then
                    Err (EmptySystemPrompt { reason = "No content found between title and first section" })
                else
                    Ok { name = name, systemPrompt = systemPrompt }
            )
