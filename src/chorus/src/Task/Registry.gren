module Task.Registry exposing
    ( Registry
    , Task
    , TaskStatus(..)
    , SourceInfo
    , Attachment
    , Error(..)
    , init
    , createTask
    , getTask
    , updateTask
    , updateStatus
    , listTasks
    , getActiveTasks
    , getRecentTasks
    , recordEvent
    , encodeTask
    , taskDecoder
    , encodeAttachment
    , attachmentDecoder
    , contentTypeFromExtension
    )

{-| Task Registry - manages task lifecycle and persistence.

Tasks are the central unit of work in Chorus. Each user request becomes a task
that can be tracked, queued, and displayed in a UI.

The registry stores tasks in a file-based structure:

    {registryRoot}/
    ├── registry.json           -- index of all tasks
    └── {task-id}/              -- per-task directory
        ├── task.json           -- task state
        ├── queue.json          -- pending messages
        └── history.json        -- event log

-}

import Bytes
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Task as GrenTask
import Time


-- TYPES


{-| The registry handle. Contains configuration and secure context for operations.
-}
type Registry
    = Registry
        { fsPermission : FileSystem.Permission
        , secureContext : SecureContext
        , registryRoot : Path
        , workspacesRoot : Path
        }


{-| A task in the registry.
-}
type alias Task =
    { id : String
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe String
    , source : SourceInfo
    , agentWorkspace : String
    , attachments : Array Attachment
    }


{-| Metadata for a file attached to a task.
-}
type alias Attachment =
    { filename : String
    , size : Int
    , contentType : String
    , uploadedAt : Time.Posix
    }


{-| Task lifecycle status.
-}
type TaskStatus
    = Pending       -- created but session not started
    | Active        -- session is currently processing
    | Waiting       -- session idle, ready for more input
    | Completed     -- finished successfully
    | Failed String -- finished with error message


{-| Information about where the task originated.
-}
type alias SourceInfo =
    { sourceType : String
    , userId : String
    , conversationId : Maybe String
    }


{-| Event recorded in task history.
-}
type alias Event =
    { timestamp : Time.Posix
    , eventType : String
    , data : Dict String String
    }


{-| Registry operation errors.
-}
type Error
    = FileSystemError String
    | JsonDecodeError String
    | TaskNotFound String
    | RegistryCorrupt String



-- INITIALIZATION


{-| Initialize a registry, creating directories if needed.
-}
init :
    FileSystem.Permission
    -> SecureContext
    -> { registryRoot : String, workspacesRoot : String }
    -> GrenTask.Task Error Registry
init fsPermission secureContext config =
    let
        registryPath =
            Path.fromPosixString config.registryRoot

        workspacesPath =
            Path.fromPosixString config.workspacesRoot

        registry =
            Registry
                { fsPermission = fsPermission
                , secureContext = secureContext
                , registryRoot = registryPath
                , workspacesRoot = workspacesPath
                }
    in
    ensureDirectoryExists fsPermission registryPath
        |> GrenTask.andThen (\_ -> ensureDirectoryExists fsPermission workspacesPath)
        |> GrenTask.andThen (\_ -> ensureRegistryIndex fsPermission registryPath)
        |> GrenTask.map (\_ -> registry)


{-| Ensure a directory exists, creating it if necessary.
-}
ensureDirectoryExists : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureDirectoryExists fsPermission path =
    FileSystem.makeDirectory fsPermission { recursive = True } path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.map (\_ -> {})


{-| Ensure registry.json exists with valid structure.
-}
ensureRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureRegistryIndex fsPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot

        emptyIndex =
            encodeRegistryIndex { version = 1, tasks = [] }
                |> Encode.encode 2
    in
    -- Try to access the file - if it succeeds, file exists; if it fails with ENOENT, create it
    FileSystem.checkAccess fsPermission [] indexPath
        |> GrenTask.andThen (\_ -> GrenTask.succeed {})
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    writeFileAtomic fsPermission indexPath emptyIndex
                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                else
                    GrenTask.fail (FileSystemError (FileSystem.errorToString err))
            )



-- TASK OPERATIONS


{-| Create a new task.
-}
createTask :
    Registry
    -> { description : String, source : SourceInfo }
    -> GrenTask.Task Error Task
createTask (Registry config) { description, source } =
    -- 1. Generate UUID and get current time
    Crypto.randomUuidV4 config.secureContext
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to generate UUID")
        |> GrenTask.andThen
            (\taskId ->
                Time.now
                    |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                    |> GrenTask.map (\now -> { taskId = taskId, now = now })
            )
        |> GrenTask.andThen
            (\{ taskId, now } ->
                let
                    taskDir =
                        Path.append (Path.fromPosixString taskId) config.registryRoot

                    workspaceDir =
                        Path.append (Path.fromPosixString taskId) config.workspacesRoot

                    task =
                        { id = taskId
                        , description = description
                        , status = Pending
                        , createdAt = now
                        , updatedAt = now
                        , sessionId = Nothing
                        , source = source
                        , agentWorkspace = Path.toPosixString workspaceDir
                        , attachments = []
                        }
                in
                -- 2. Create task directory
                ensureDirectoryExists config.fsPermission taskDir
                    -- 3. Create workspace directory
                    |> GrenTask.andThen (\_ -> ensureDirectoryExists config.fsPermission workspaceDir)
                    -- 4. Write task.json
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                taskPath =
                                    Path.append (Path.fromPosixString "task.json") taskDir

                                taskJson =
                                    encodeTask task
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission taskPath taskJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 5. Write queue.json (empty queue)
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                queuePath =
                                    Path.append (Path.fromPosixString "queue.json") taskDir

                                queueJson =
                                    encodeEmptyQueue
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission queuePath queueJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 6. Write history.json with task_created event
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                historyPath =
                                    Path.append (Path.fromPosixString "history.json") taskDir

                                initialEvent =
                                    { timestamp = now
                                    , eventType = "task_created"
                                    , data = Dict.singleton "description" description
                                    }

                                historyJson =
                                    encodeHistory [ initialEvent ]
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission historyPath historyJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 7. Update registry.json index
                    |> GrenTask.andThen
                        (\_ ->
                            updateRegistryIndex config.fsPermission config.registryRoot
                                (\index ->
                                    let
                                        summary =
                                            { id = taskId
                                            , description = description
                                            , status = Pending
                                            , createdAt = now
                                            , updatedAt = now
                                            }
                                    in
                                    { index | tasks = Array.pushLast summary index.tasks }
                                )
                        )
                    |> GrenTask.map (\_ -> task)
            )


{-| Get a task by ID.
-}
getTask : Registry -> String -> GrenTask.Task Error (Maybe Task)
getTask (Registry config) taskId =
    let
        taskDir =
            Path.append (Path.fromPosixString taskId) config.registryRoot

        taskPath =
            Path.append (Path.fromPosixString "task.json") taskDir
    in
    FileSystem.readFile config.fsPermission taskPath
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    -- Convert to a special marker that we'll handle below
                    GrenTask.fail err
                else
                    GrenTask.fail err
            )
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString taskDecoder content is
                            Ok task ->
                                GrenTask.succeed (Just task)

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    FileSystemError msg ->
                        if String.contains "ENOENT" msg || String.contains "no such file" msg then
                            GrenTask.succeed Nothing
                        else
                            GrenTask.fail err

                    _ ->
                        GrenTask.fail err
            )


{-| Update a task.
-}
updateTask :
    Registry
    -> String
    -> (Task -> Task)
    -> GrenTask.Task Error Task
updateTask (Registry config) taskId updateFn =
    getTask (Registry config) taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (TaskNotFound taskId)

                    Just task ->
                        Time.now
                            |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                            |> GrenTask.andThen
                                (\now ->
                                    let
                                        updatedTask =
                                            updateFn task
                                                |> (\t -> { t | updatedAt = now })

                                        taskDir =
                                            Path.append (Path.fromPosixString taskId) config.registryRoot

                                        taskPath =
                                            Path.append (Path.fromPosixString "task.json") taskDir

                                        taskJson =
                                            encodeTask updatedTask
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.fsPermission taskPath taskJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                        |> GrenTask.andThen
                                            (\_ ->
                                                -- Update registry index with new status/updatedAt
                                                updateRegistryIndex config.fsPermission config.registryRoot
                                                    (\index ->
                                                        { index
                                                            | tasks =
                                                                Array.map
                                                                    (\summary ->
                                                                        if summary.id == taskId then
                                                                            { summary
                                                                                | status = updatedTask.status
                                                                                , updatedAt = now
                                                                            }
                                                                        else
                                                                            summary
                                                                    )
                                                                    index.tasks
                                                        }
                                                    )
                                            )
                                        |> GrenTask.map (\_ -> updatedTask)
                                )
            )


{-| Update just the task status.
-}
updateStatus :
    Registry
    -> String
    -> TaskStatus
    -> GrenTask.Task Error Task
updateStatus registry taskId newStatus =
    updateTask registry taskId (\task -> { task | status = newStatus })


{-| List all tasks, optionally filtered by status.
-}
listTasks : Registry -> Maybe TaskStatus -> GrenTask.Task Error (Array Task)
listTasks (Registry config) maybeStatus =
    readRegistryIndex config.fsPermission config.registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    filteredSummaries =
                        when maybeStatus is
                            Nothing ->
                                index.tasks

                            Just status ->
                                Array.keepIf (\s -> statusEquals s.status status) index.tasks
                in
                -- Load each task from disk
                filteredSummaries
                    |> Array.foldl
                        (\summary acc ->
                            acc
                                |> GrenTask.andThen
                                    (\tasks ->
                                        getTask (Registry config) summary.id
                                            |> GrenTask.map
                                                (\maybeTask ->
                                                    when maybeTask is
                                                        Just task ->
                                                            Array.pushLast task tasks

                                                        Nothing ->
                                                            -- Task file missing, skip it
                                                            tasks
                                                )
                                    )
                        )
                        (GrenTask.succeed [])
            )


{-| Get currently active tasks.
-}
getActiveTasks : Registry -> GrenTask.Task Error (Array Task)
getActiveTasks registry =
    listTasks registry (Just Active)


{-| Get recent tasks ordered by updatedAt.
-}
getRecentTasks : Registry -> Int -> GrenTask.Task Error (Array Task)
getRecentTasks registry limit =
    listTasks registry Nothing
        |> GrenTask.map
            (\tasks ->
                tasks
                    |> Array.sortBy (\t -> negate (Time.posixToMillis t.updatedAt))
                    |> Array.takeFirst limit
            )


{-| Record an event to the task's history.
-}
recordEvent :
    Registry
    -> String
    -> { eventType : String, data : Dict String String }
    -> GrenTask.Task Error {}
recordEvent (Registry config) taskId event =
    let
        taskDir =
            Path.append (Path.fromPosixString taskId) config.registryRoot

        historyPath =
            Path.append (Path.fromPosixString "history.json") taskDir
    in
    Time.now
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
        |> GrenTask.andThen
            (\now ->
                readHistory config.fsPermission historyPath
                    |> GrenTask.andThen
                        (\events ->
                            let
                                newEvent =
                                    { timestamp = now
                                    , eventType = event.eventType
                                    , data = event.data
                                    }

                                updatedEvents =
                                    Array.pushLast newEvent events

                                historyJson =
                                    encodeHistory updatedEvents
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission historyPath historyJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
            )



-- JSON ENCODING/DECODING


{-| Encode a task to JSON.
-}
encodeTask : Task -> Encode.Value
encodeTask task =
    Encode.object
        [ { key = "id", value = Encode.string task.id }
        , { key = "description", value = Encode.string task.description }
        , { key = "status", value = encodeStatus task.status }
        , { key = "createdAt", value = Encode.int (Time.posixToMillis task.createdAt) }
        , { key = "updatedAt", value = Encode.int (Time.posixToMillis task.updatedAt) }
        , { key = "sessionId", value = encodeMaybe Encode.string task.sessionId }
        , { key = "source", value = encodeSourceInfo task.source }
        , { key = "agentWorkspace", value = Encode.string task.agentWorkspace }
        , { key = "attachments", value = Encode.array encodeAttachment task.attachments }
        ]


{-| Encode an attachment to JSON.
-}
encodeAttachment : Attachment -> Encode.Value
encodeAttachment attachment =
    Encode.object
        [ { key = "filename", value = Encode.string attachment.filename }
        , { key = "size", value = Encode.int attachment.size }
        , { key = "contentType", value = Encode.string attachment.contentType }
        , { key = "uploadedAt", value = Encode.int (Time.posixToMillis attachment.uploadedAt) }
        ]


encodeStatus : TaskStatus -> Encode.Value
encodeStatus status =
    when status is
        Pending ->
            Encode.object
                [ { key = "type", value = Encode.string "pending" }
                ]

        Active ->
            Encode.object
                [ { key = "type", value = Encode.string "active" }
                ]

        Waiting ->
            Encode.object
                [ { key = "type", value = Encode.string "waiting" }
                ]

        Completed ->
            Encode.object
                [ { key = "type", value = Encode.string "completed" }
                ]

        Failed message ->
            Encode.object
                [ { key = "type", value = Encode.string "failed" }
                , { key = "message", value = Encode.string message }
                ]


encodeSourceInfo : SourceInfo -> Encode.Value
encodeSourceInfo source =
    Encode.object
        [ { key = "sourceType", value = Encode.string source.sourceType }
        , { key = "userId", value = Encode.string source.userId }
        , { key = "conversationId", value = encodeMaybe Encode.string source.conversationId }
        ]


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder maybeValue =
    when maybeValue is
        Just value ->
            encoder value

        Nothing ->
            Encode.null


{-| Decode a task from JSON.
-}
taskDecoder : Decoder Task
taskDecoder =
    Decode.map8
        (\id description status createdAt updatedAt sessionId source agentWorkspace ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = sessionId
            , source = source
            , agentWorkspace = agentWorkspace
            , attachments = []
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "sessionId" (Decode.maybe Decode.string))
        (Decode.field "source" sourceInfoDecoder)
        (Decode.field "agentWorkspace" Decode.string)
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "attachments" (Decode.array attachmentDecoder)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )


{-| Decode an attachment from JSON.
-}
attachmentDecoder : Decoder Attachment
attachmentDecoder =
    Decode.map4
        (\filename size contentType uploadedAt ->
            { filename = filename
            , size = size
            , contentType = contentType
            , uploadedAt = uploadedAt
            }
        )
        (Decode.field "filename" Decode.string)
        (Decode.field "size" Decode.int)
        (Decode.field "contentType" Decode.string)
        (Decode.field "uploadedAt" (Decode.map Time.millisToPosix Decode.int))


statusDecoder : Decoder TaskStatus
statusDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\statusType ->
                when statusType is
                    "pending" ->
                        Decode.succeed Pending

                    "active" ->
                        Decode.succeed Active

                    "waiting" ->
                        Decode.succeed Waiting

                    "completed" ->
                        Decode.succeed Completed

                    "failed" ->
                        Decode.field "message" Decode.string
                            |> Decode.map Failed

                    _ ->
                        Decode.fail ("Unknown status type: " ++ statusType)
            )


sourceInfoDecoder : Decoder SourceInfo
sourceInfoDecoder =
    Decode.map3
        (\sourceType userId conversationId ->
            { sourceType = sourceType
            , userId = userId
            , conversationId = conversationId
            }
        )
        (Decode.field "sourceType" Decode.string)
        (Decode.field "userId" Decode.string)
        (Decode.field "conversationId" (Decode.maybe Decode.string))



-- REGISTRY INDEX TYPES AND OPERATIONS


{-| Summary of a task stored in the registry index.
-}
type alias TaskSummary =
    { id : String
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    }


{-| Registry index stored in registry.json.
-}
type alias RegistryIndex =
    { version : Int
    , tasks : Array TaskSummary
    }


{-| Read the registry index from disk.
-}
readRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error RegistryIndex
readRegistryIndex fsPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot
    in
    FileSystem.readFile fsPermission indexPath
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString registryIndexDecoder content is
                            Ok index ->
                                GrenTask.succeed index

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


{-| Update the registry index atomically.
-}
updateRegistryIndex :
    FileSystem.Permission
    -> Path
    -> (RegistryIndex -> RegistryIndex)
    -> GrenTask.Task Error {}
updateRegistryIndex fsPermission registryRoot updateFn =
    readRegistryIndex fsPermission registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    updatedIndex =
                        updateFn index

                    indexPath =
                        Path.append (Path.fromPosixString "registry.json") registryRoot

                    indexJson =
                        encodeRegistryIndex updatedIndex
                            |> Encode.encode 2
                in
                writeFileAtomic fsPermission indexPath indexJson
                    |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
            )


encodeRegistryIndex : RegistryIndex -> Encode.Value
encodeRegistryIndex index =
    Encode.object
        [ { key = "version", value = Encode.int index.version }
        , { key = "tasks", value = Encode.array encodeTaskSummary index.tasks }
        ]


encodeTaskSummary : TaskSummary -> Encode.Value
encodeTaskSummary summary =
    Encode.object
        [ { key = "id", value = Encode.string summary.id }
        , { key = "description", value = Encode.string summary.description }
        , { key = "status", value = encodeStatus summary.status }
        , { key = "createdAt", value = Encode.int (Time.posixToMillis summary.createdAt) }
        , { key = "updatedAt", value = Encode.int (Time.posixToMillis summary.updatedAt) }
        ]


registryIndexDecoder : Decoder RegistryIndex
registryIndexDecoder =
    Decode.map2
        (\version tasks -> { version = version, tasks = tasks })
        (Decode.field "version" Decode.int)
        (Decode.field "tasks" (Decode.array taskSummaryDecoder))


taskSummaryDecoder : Decoder TaskSummary
taskSummaryDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))



-- HISTORY OPERATIONS


{-| Read history events from disk.
-}
readHistory : FileSystem.Permission -> Path -> GrenTask.Task Error (Array Event)
readHistory fsPermission path =
    FileSystem.readFile fsPermission path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString historyDecoder content is
                            Ok events ->
                                GrenTask.succeed events

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


encodeHistory : Array Event -> Encode.Value
encodeHistory events =
    Encode.object
        [ { key = "events", value = Encode.array encodeEvent events }
        ]


encodeEvent : Event -> Encode.Value
encodeEvent event =
    Encode.object
        [ { key = "timestamp", value = Encode.int (Time.posixToMillis event.timestamp) }
        , { key = "eventType", value = Encode.string event.eventType }
        , { key = "data", value = Encode.dict identity Encode.string event.data }
        ]


historyDecoder : Decoder (Array Event)
historyDecoder =
    Decode.field "events" (Decode.array eventDecoder)


eventDecoder : Decoder Event
eventDecoder =
    Decode.map3
        (\timestamp eventType data ->
            { timestamp = timestamp
            , eventType = eventType
            , data = data
            }
        )
        (Decode.field "timestamp" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "eventType" Decode.string)
        (Decode.field "data" (Decode.dict Decode.string))


encodeEmptyQueue : Encode.Value
encodeEmptyQueue =
    Encode.object
        [ { key = "messages", value = Encode.array identity [] }
        ]



-- STATUS HELPERS


{-| Check if two statuses are equal (for filtering).
-}
statusEquals : TaskStatus -> TaskStatus -> Bool
statusEquals a b =
    when { a = a, b = b } is
        { a = Pending, b = Pending } ->
            True

        { a = Active, b = Active } ->
            True

        { a = Waiting, b = Waiting } ->
            True

        { a = Completed, b = Completed } ->
            True

        { a = Failed _, b = Failed _ } ->
            True

        _ ->
            False



-- CONTENT TYPE HELPERS


{-| Infer a MIME content type from a file extension.
-}
contentTypeFromExtension : String -> String
contentTypeFromExtension filename =
    let
        extension =
            filename
                |> String.split "."
                |> Array.last
                |> Maybe.withDefault ""
                |> String.toLower
    in
    when extension is
        "png" ->
            "image/png"

        "jpg" ->
            "image/jpeg"

        "jpeg" ->
            "image/jpeg"

        "gif" ->
            "image/gif"

        "pdf" ->
            "application/pdf"

        "txt" ->
            "text/plain"

        "md" ->
            "text/markdown"

        "json" ->
            "application/json"

        "csv" ->
            "text/csv"

        "html" ->
            "text/html"

        _ ->
            "application/octet-stream"



-- FILE HELPERS


{-| Write a file atomically (write to temp, then rename).
-}
writeFileAtomic : FileSystem.Permission -> Path -> String -> GrenTask.Task FileSystem.Error {}
writeFileAtomic fsPermission path content =
    let
        tempPath =
            Path.fromPosixString (Path.toPosixString path ++ ".tmp")

        bytes =
            Bytes.fromString content
    in
    FileSystem.writeFile fsPermission bytes tempPath
        |> GrenTask.andThen (\_ -> FileSystem.move fsPermission path tempPath)
        |> GrenTask.map (\_ -> {})
