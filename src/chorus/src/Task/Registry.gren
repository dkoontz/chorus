module Task.Registry exposing
    ( Registry
    , Task(..)
    , DescriptionOnlyTask
    , PlannedTask
    , PlanningFields
    , TaskStatus(..)
    , SourceInfo
    , Attachment
    , Error(..)
    , init
    , createTask
    , getTask
    , updateTask
    , updateStatus
    , listTasks
    , getActiveTasks
    , getRecentTasks
    , recordEvent
    , encodeTask
    , taskDecoder
    , encodeAttachment
    , attachmentDecoder
    , contentTypeFromExtension
    , taskId
    , taskDescription
    , taskStatus
    , taskCreatedAt
    , taskUpdatedAt
    , taskSessionId
    , taskSource
    , taskAgentWorkspace
    , taskAttachments
    , isPlanned
    , planTask
    , setTaskStatus
    , setAttachments
    )

{-| Task Registry - manages task lifecycle and persistence.

Tasks are the central unit of work in Chorus. Each user request becomes a task
that can be tracked, queued, and displayed in a UI.

The registry stores tasks in a file-based structure:

    {registryRoot}/
    ├── registry.json           -- index of all tasks
    └── {task-id}/              -- per-task directory
        ├── task.json           -- task state
        ├── queue.json          -- pending messages
        └── history.json        -- event log

-}

import Bytes
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Task as GrenTask
import Time


-- TYPES


{-| The registry handle. Contains configuration and secure context for operations.
-}
type Registry
    = Registry
        { fsPermission : FileSystem.Permission
        , secureContext : SecureContext
        , registryRoot : Path
        , workspacesRoot : Path
        }


{-| A task in the registry. Either a simple description-only task or a fully
    planned task with summary, requirements, acceptance criteria, and plan.
-}
type Task
    = DescriptionOnly DescriptionOnlyTask
    | Planned PlannedTask


{-| A task that has only a description and no planning data.
-}
type alias DescriptionOnlyTask =
    { id : String
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe String
    , source : SourceInfo
    , agentWorkspace : String
    , attachments : Array Attachment
    }


{-| A task that has been planned with summary, requirements, criteria, and steps.
-}
type alias PlannedTask =
    { id : String
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe String
    , source : SourceInfo
    , agentWorkspace : String
    , attachments : Array Attachment
    , summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    }


{-| Planning fields used when converting a DescriptionOnly task to Planned.
-}
type alias PlanningFields =
    { summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    }


{-| Metadata for a file attached to a task.
-}
type alias Attachment =
    { filename : String
    , size : Int
    , contentType : String
    , uploadedAt : Time.Posix
    }


{-| Task lifecycle status.
-}
type TaskStatus
    = Pending       -- created but session not started
    | Active        -- session is currently processing
    | Waiting       -- session idle, ready for more input
    | Completed     -- finished successfully
    | Failed String -- finished with error message


{-| Information about where the task originated.
-}
type alias SourceInfo =
    { sourceType : String
    , userId : String
    , conversationId : Maybe String
    }


{-| Event recorded in task history.
-}
type alias Event =
    { timestamp : Time.Posix
    , eventType : String
    , data : Dict String String
    }


{-| Registry operation errors.
-}
type Error
    = FileSystemError String
    | JsonDecodeError String
    | TaskNotFound String
    | RegistryCorrupt String



-- TASK ACCESSORS


{-| Get the ID of a task.
-}
taskId : Task -> String
taskId task =
    when task is
        DescriptionOnly t ->
            t.id

        Planned t ->
            t.id


{-| Get the description of a task.
-}
taskDescription : Task -> String
taskDescription task =
    when task is
        DescriptionOnly t ->
            t.description

        Planned t ->
            t.description


{-| Get the status of a task.
-}
taskStatus : Task -> TaskStatus
taskStatus task =
    when task is
        DescriptionOnly t ->
            t.status

        Planned t ->
            t.status


{-| Get the creation time of a task.
-}
taskCreatedAt : Task -> Time.Posix
taskCreatedAt task =
    when task is
        DescriptionOnly t ->
            t.createdAt

        Planned t ->
            t.createdAt


{-| Get the last update time of a task.
-}
taskUpdatedAt : Task -> Time.Posix
taskUpdatedAt task =
    when task is
        DescriptionOnly t ->
            t.updatedAt

        Planned t ->
            t.updatedAt


{-| Get the session ID of a task.
-}
taskSessionId : Task -> Maybe String
taskSessionId task =
    when task is
        DescriptionOnly t ->
            t.sessionId

        Planned t ->
            t.sessionId


{-| Get the source info of a task.
-}
taskSource : Task -> SourceInfo
taskSource task =
    when task is
        DescriptionOnly t ->
            t.source

        Planned t ->
            t.source


{-| Get the agent workspace of a task.
-}
taskAgentWorkspace : Task -> String
taskAgentWorkspace task =
    when task is
        DescriptionOnly t ->
            t.agentWorkspace

        Planned t ->
            t.agentWorkspace


{-| Get the attachments of a task.
-}
taskAttachments : Task -> Array Attachment
taskAttachments task =
    when task is
        DescriptionOnly t ->
            t.attachments

        Planned t ->
            t.attachments


{-| Check if a task has been planned.
-}
isPlanned : Task -> Bool
isPlanned task =
    when task is
        DescriptionOnly _ ->
            False

        Planned _ ->
            True


{-| Convert a task to Planned by adding planning fields.
    If the task is already Planned, the existing planning fields are replaced.
-}
planTask : Task -> PlanningFields -> Task
planTask task fields =
    when task is
        DescriptionOnly t ->
            Planned
                { id = t.id
                , description = t.description
                , status = t.status
                , createdAt = t.createdAt
                , updatedAt = t.updatedAt
                , sessionId = t.sessionId
                , source = t.source
                , agentWorkspace = t.agentWorkspace
                , attachments = t.attachments
                , summary = fields.summary
                , requirements = fields.requirements
                , acceptanceCriteria = fields.acceptanceCriteria
                , plan = fields.plan
                }

        Planned t ->
            Planned
                { t
                    | summary = fields.summary
                    , requirements = fields.requirements
                    , acceptanceCriteria = fields.acceptanceCriteria
                    , plan = fields.plan
                }



-- INTERNAL SETTERS
-- These setters are used only within this module and are not exported.
-- setUpdatedAt is called automatically by updateTask.
-- setSessionId is used internally for session management.
--
-- PUBLIC SETTERS (exported)
-- setTaskStatus and setAttachments are exported because Web.Api
-- uses them to build update functions passed to updateTask.


{-| Set the updatedAt time on a task. Internal use only.
-}
setUpdatedAt : Time.Posix -> Task -> Task
setUpdatedAt time task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | updatedAt = time }

        Planned t ->
            Planned { t | updatedAt = time }


{-| Set the status on a task.
-}
setTaskStatus : TaskStatus -> Task -> Task
setTaskStatus newStatus task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | status = newStatus }

        Planned t ->
            Planned { t | status = newStatus }


{-| Set the session ID on a task. Internal use only.
-}
setSessionId : Maybe String -> Task -> Task
setSessionId sid task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | sessionId = sid }

        Planned t ->
            Planned { t | sessionId = sid }


{-| Set the attachments on a task.
-}
setAttachments : Array Attachment -> Task -> Task
setAttachments attachments task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | attachments = attachments }

        Planned t ->
            Planned { t | attachments = attachments }



-- INITIALIZATION


{-| Initialize a registry, creating directories if needed.
-}
init :
    FileSystem.Permission
    -> SecureContext
    -> { registryRoot : String, workspacesRoot : String }
    -> GrenTask.Task Error Registry
init fsPermission secureContext config =
    let
        registryPath =
            Path.fromPosixString config.registryRoot

        workspacesPath =
            Path.fromPosixString config.workspacesRoot

        registry =
            Registry
                { fsPermission = fsPermission
                , secureContext = secureContext
                , registryRoot = registryPath
                , workspacesRoot = workspacesPath
                }
    in
    ensureDirectoryExists fsPermission registryPath
        |> GrenTask.andThen (\_ -> ensureDirectoryExists fsPermission workspacesPath)
        |> GrenTask.andThen (\_ -> ensureRegistryIndex fsPermission registryPath)
        |> GrenTask.map (\_ -> registry)


{-| Ensure a directory exists, creating it if necessary.
-}
ensureDirectoryExists : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureDirectoryExists fsPermission path =
    FileSystem.makeDirectory fsPermission { recursive = True } path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.map (\_ -> {})


{-| Ensure registry.json exists with valid structure.
-}
ensureRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureRegistryIndex fsPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot

        emptyIndex =
            encodeRegistryIndex { version = 1, tasks = [] }
                |> Encode.encode 2
    in
    -- Try to access the file - if it succeeds, file exists; if it fails with ENOENT, create it
    FileSystem.checkAccess fsPermission [] indexPath
        |> GrenTask.andThen (\_ -> GrenTask.succeed {})
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    writeFileAtomic fsPermission indexPath emptyIndex
                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                else
                    GrenTask.fail (FileSystemError (FileSystem.errorToString err))
            )



-- TASK OPERATIONS


{-| Create a new task.
-}
createTask :
    Registry
    -> { description : String, source : SourceInfo }
    -> GrenTask.Task Error Task
createTask (Registry config) { description, source } =
    -- 1. Generate UUID and get current time
    Crypto.randomUuidV4 config.secureContext
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to generate UUID")
        |> GrenTask.andThen
            (\newId ->
                Time.now
                    |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                    |> GrenTask.map (\now -> { newId = newId, now = now })
            )
        |> GrenTask.andThen
            (\{ newId, now } ->
                let
                    taskDir =
                        Path.append (Path.fromPosixString newId) config.registryRoot

                    workspaceDir =
                        Path.append (Path.fromPosixString newId) config.workspacesRoot

                    task =
                        DescriptionOnly
                            { id = newId
                            , description = description
                            , status = Pending
                            , createdAt = now
                            , updatedAt = now
                            , sessionId = Nothing
                            , source = source
                            , agentWorkspace = Path.toPosixString workspaceDir
                            , attachments = []
                            }
                in
                -- 2. Create task directory
                ensureDirectoryExists config.fsPermission taskDir
                    -- 3. Create workspace directory
                    |> GrenTask.andThen (\_ -> ensureDirectoryExists config.fsPermission workspaceDir)
                    -- 4. Write task.json
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                taskPath =
                                    Path.append (Path.fromPosixString "task.json") taskDir

                                taskJson =
                                    encodeTask task
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission taskPath taskJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 5. Write queue.json (empty queue)
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                queuePath =
                                    Path.append (Path.fromPosixString "queue.json") taskDir

                                queueJson =
                                    encodeEmptyQueue
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission queuePath queueJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 6. Write history.json with task_created event
                    |> GrenTask.andThen
                        (\_ ->
                            let
                                historyPath =
                                    Path.append (Path.fromPosixString "history.json") taskDir

                                initialEvent =
                                    { timestamp = now
                                    , eventType = "task_created"
                                    , data = Dict.singleton "description" description
                                    }

                                historyJson =
                                    encodeHistory [ initialEvent ]
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission historyPath historyJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
                    -- 7. Update registry.json index
                    |> GrenTask.andThen
                        (\_ ->
                            updateRegistryIndex config.fsPermission config.registryRoot
                                (\index ->
                                    let
                                        summary =
                                            { id = newId
                                            , description = description
                                            , status = Pending
                                            , createdAt = now
                                            , updatedAt = now
                                            }
                                    in
                                    { index | tasks = Array.pushLast summary index.tasks }
                                )
                        )
                    |> GrenTask.map (\_ -> task)
            )


{-| Get a task by ID.
-}
getTask : Registry -> String -> GrenTask.Task Error (Maybe Task)
getTask (Registry config) tid =
    let
        taskDir =
            Path.append (Path.fromPosixString tid) config.registryRoot

        taskPath =
            Path.append (Path.fromPosixString "task.json") taskDir
    in
    FileSystem.readFile config.fsPermission taskPath
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    -- Convert to a special marker that we'll handle below
                    GrenTask.fail err
                else
                    GrenTask.fail err
            )
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString taskDecoder content is
                            Ok task ->
                                GrenTask.succeed (Just task)

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    FileSystemError msg ->
                        if String.contains "ENOENT" msg || String.contains "no such file" msg then
                            GrenTask.succeed Nothing
                        else
                            GrenTask.fail err

                    _ ->
                        GrenTask.fail err
            )


{-| Update a task.
-}
updateTask :
    Registry
    -> String
    -> (Task -> Task)
    -> GrenTask.Task Error Task
updateTask (Registry config) theTaskId updateFn =
    getTask (Registry config) theTaskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (TaskNotFound theTaskId)

                    Just task ->
                        Time.now
                            |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                            |> GrenTask.andThen
                                (\now ->
                                    let
                                        updatedTask =
                                            updateFn task
                                                |> setUpdatedAt now

                                        taskDir =
                                            Path.append (Path.fromPosixString theTaskId) config.registryRoot

                                        taskPath =
                                            Path.append (Path.fromPosixString "task.json") taskDir

                                        taskJson =
                                            encodeTask updatedTask
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.fsPermission taskPath taskJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                        |> GrenTask.andThen
                                            (\_ ->
                                                -- Update registry index with new status/updatedAt
                                                updateRegistryIndex config.fsPermission config.registryRoot
                                                    (\index ->
                                                        { index
                                                            | tasks =
                                                                Array.map
                                                                    (\summary ->
                                                                        if summary.id == theTaskId then
                                                                            { summary
                                                                                | status = taskStatus updatedTask
                                                                                , updatedAt = now
                                                                            }
                                                                        else
                                                                            summary
                                                                    )
                                                                    index.tasks
                                                        }
                                                    )
                                            )
                                        |> GrenTask.map (\_ -> updatedTask)
                                )
            )


{-| Update just the task status.
-}
updateStatus :
    Registry
    -> String
    -> TaskStatus
    -> GrenTask.Task Error Task
updateStatus registry theTaskId newStatus =
    updateTask registry theTaskId (setTaskStatus newStatus)


{-| List all tasks, optionally filtered by status.
-}
listTasks : Registry -> Maybe TaskStatus -> GrenTask.Task Error (Array Task)
listTasks (Registry config) maybeStatus =
    readRegistryIndex config.fsPermission config.registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    filteredSummaries =
                        when maybeStatus is
                            Nothing ->
                                index.tasks

                            Just status ->
                                Array.keepIf (\s -> statusEquals s.status status) index.tasks
                in
                -- Load each task from disk
                filteredSummaries
                    |> Array.foldl
                        (\summary acc ->
                            acc
                                |> GrenTask.andThen
                                    (\tasks ->
                                        getTask (Registry config) summary.id
                                            |> GrenTask.map
                                                (\maybeTask ->
                                                    when maybeTask is
                                                        Just task ->
                                                            Array.pushLast task tasks

                                                        Nothing ->
                                                            -- Task file missing, skip it
                                                            tasks
                                                )
                                    )
                        )
                        (GrenTask.succeed [])
            )


{-| Get currently active tasks.
-}
getActiveTasks : Registry -> GrenTask.Task Error (Array Task)
getActiveTasks registry =
    listTasks registry (Just Active)


{-| Get recent tasks ordered by updatedAt.
-}
getRecentTasks : Registry -> Int -> GrenTask.Task Error (Array Task)
getRecentTasks registry limit =
    listTasks registry Nothing
        |> GrenTask.map
            (\tasks ->
                tasks
                    |> Array.sortBy (\t -> negate (Time.posixToMillis (taskUpdatedAt t)))
                    |> Array.takeFirst limit
            )


{-| Record an event to the task's history.
-}
recordEvent :
    Registry
    -> String
    -> { eventType : String, data : Dict String String }
    -> GrenTask.Task Error {}
recordEvent (Registry config) tid event =
    let
        taskDir =
            Path.append (Path.fromPosixString tid) config.registryRoot

        historyPath =
            Path.append (Path.fromPosixString "history.json") taskDir
    in
    Time.now
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
        |> GrenTask.andThen
            (\now ->
                readHistory config.fsPermission historyPath
                    |> GrenTask.andThen
                        (\events ->
                            let
                                newEvent =
                                    { timestamp = now
                                    , eventType = event.eventType
                                    , data = event.data
                                    }

                                updatedEvents =
                                    Array.pushLast newEvent events

                                historyJson =
                                    encodeHistory updatedEvents
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.fsPermission historyPath historyJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
            )



-- JSON ENCODING/DECODING


{-| Encode a task to JSON. Includes a "taskType" discriminator field.

    The discriminator is named "taskType" rather than "type" because "type"
    is already used as the discriminator inside the nested status object
    (e.g. {"type": "active"}). Using "taskType" avoids ambiguity.
-}
encodeTask : Task -> Encode.Value
encodeTask task =
    when task is
        DescriptionOnly t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "descriptionOnly" }
                , { key = "id", value = Encode.string t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Encode.string t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "agentWorkspace", value = Encode.string t.agentWorkspace }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                ]

        Planned t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "planned" }
                , { key = "id", value = Encode.string t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Encode.string t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "agentWorkspace", value = Encode.string t.agentWorkspace }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                , { key = "summary", value = Encode.string t.summary }
                , { key = "requirements", value = Encode.array Encode.string t.requirements }
                , { key = "acceptanceCriteria", value = Encode.array Encode.string t.acceptanceCriteria }
                , { key = "plan", value = Encode.array Encode.string t.plan }
                ]


{-| Encode an attachment to JSON.
-}
encodeAttachment : Attachment -> Encode.Value
encodeAttachment attachment =
    Encode.object
        [ { key = "filename", value = Encode.string attachment.filename }
        , { key = "size", value = Encode.int attachment.size }
        , { key = "contentType", value = Encode.string attachment.contentType }
        , { key = "uploadedAt", value = Encode.int (Time.posixToMillis attachment.uploadedAt) }
        ]


encodeStatus : TaskStatus -> Encode.Value
encodeStatus status =
    when status is
        Pending ->
            Encode.object
                [ { key = "type", value = Encode.string "pending" }
                ]

        Active ->
            Encode.object
                [ { key = "type", value = Encode.string "active" }
                ]

        Waiting ->
            Encode.object
                [ { key = "type", value = Encode.string "waiting" }
                ]

        Completed ->
            Encode.object
                [ { key = "type", value = Encode.string "completed" }
                ]

        Failed message ->
            Encode.object
                [ { key = "type", value = Encode.string "failed" }
                , { key = "message", value = Encode.string message }
                ]


encodeSourceInfo : SourceInfo -> Encode.Value
encodeSourceInfo source =
    Encode.object
        [ { key = "sourceType", value = Encode.string source.sourceType }
        , { key = "userId", value = Encode.string source.userId }
        , { key = "conversationId", value = encodeMaybe Encode.string source.conversationId }
        ]


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder maybeValue =
    when maybeValue is
        Just value ->
            encoder value

        Nothing ->
            Encode.null


{-| Decode a task from JSON. Handles both the new union type format
    (with "taskType" discriminator) and backward-compatible legacy format.
-}
taskDecoder : Decoder Task
taskDecoder =
    Decode.oneOf
        [ Decode.field "taskType" Decode.string
            |> Decode.andThen
                (\taskType ->
                    when taskType is
                        "planned" ->
                            plannedTaskDecoder

                        _ ->
                            descriptionOnlyTaskDecoder
                )
        , -- Backward compatibility: no taskType field.
          -- Check if planning fields are present to decide variant.
          legacyTaskDecoder
        ]


{-| Decode a DescriptionOnly task.
-}
descriptionOnlyTaskDecoder : Decoder Task
descriptionOnlyTaskDecoder =
    Decode.map8
        (\id description status createdAt updatedAt sessionId source agentWorkspace ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = sessionId
            , source = source
            , agentWorkspace = agentWorkspace
            , attachments = []
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "sessionId" (Decode.maybe Decode.string))
        (Decode.field "source" sourceInfoDecoder)
        (Decode.field "agentWorkspace" Decode.string)
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "attachments" (Decode.array attachmentDecoder)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\attachments -> DescriptionOnly { task | attachments = attachments })
            )


{-| Decode a Planned task (all base fields plus planning fields).
-}
plannedTaskDecoder : Decoder Task
plannedTaskDecoder =
    Decode.map8
        (\id description status createdAt updatedAt sessionId source agentWorkspace ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = sessionId
            , source = source
            , agentWorkspace = agentWorkspace
            , attachments = []
            , summary = ""
            , requirements = []
            , acceptanceCriteria = []
            , plan = []
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "sessionId" (Decode.maybe Decode.string))
        (Decode.field "source" sourceInfoDecoder)
        (Decode.field "agentWorkspace" Decode.string)
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "attachments" (Decode.array attachmentDecoder)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "summary" Decode.string
                    , Decode.succeed ""
                    ]
                    |> Decode.map (\summary -> { task | summary = summary })
            )
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "requirements" (Decode.array Decode.string)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\requirements -> { task | requirements = requirements })
            )
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "acceptanceCriteria" (Decode.array Decode.string)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\acceptanceCriteria -> { task | acceptanceCriteria = acceptanceCriteria })
            )
        |> Decode.andThen
            (\task ->
                Decode.oneOf
                    [ Decode.field "plan" (Decode.array Decode.string)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\plan -> Planned { task | plan = plan })
            )


{-| Backward-compatible decoder for legacy task.json files without a taskType field.

    This decoder is only reached when the taskType discriminator field is absent
    (via the Decode.oneOf in taskDecoder). It uses a heuristic: if any planning
    fields contain non-empty data, the task is decoded as Planned; otherwise as
    DescriptionOnly. This heuristic is a fallback for truly legacy data written
    before the taskType field was introduced. Newly serialized tasks always
    include taskType, so the discriminator-based branch handles them.
-}
legacyTaskDecoder : Decoder Task
legacyTaskDecoder =
    Decode.map8
        (\id description status createdAt updatedAt sessionId source agentWorkspace ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = sessionId
            , source = source
            , agentWorkspace = agentWorkspace
            , attachments = []
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "sessionId" (Decode.maybe Decode.string))
        (Decode.field "source" sourceInfoDecoder)
        (Decode.field "agentWorkspace" Decode.string)
        |> Decode.andThen
            (\baseTask ->
                Decode.oneOf
                    [ Decode.field "attachments" (Decode.array attachmentDecoder)
                    , Decode.succeed []
                    ]
                    |> Decode.map (\attachments -> { baseTask | attachments = attachments })
            )
        |> Decode.andThen
            (\baseTask ->
                -- Try decoding planning fields. If any are present, create Planned.
                Decode.map4
                    (\summary requirements acceptanceCriteria plan ->
                        { summary = summary
                        , requirements = requirements
                        , acceptanceCriteria = acceptanceCriteria
                        , plan = plan
                        }
                    )
                    (Decode.oneOf [ Decode.field "summary" Decode.string, Decode.succeed "" ])
                    (Decode.oneOf [ Decode.field "requirements" (Decode.array Decode.string), Decode.succeed [] ])
                    (Decode.oneOf [ Decode.field "acceptanceCriteria" (Decode.array Decode.string), Decode.succeed [] ])
                    (Decode.oneOf [ Decode.field "plan" (Decode.array Decode.string), Decode.succeed [] ])
                    |> Decode.map
                        (\planningFields ->
                            if String.isEmpty planningFields.summary && Array.isEmpty planningFields.requirements && Array.isEmpty planningFields.acceptanceCriteria && Array.isEmpty planningFields.plan then
                                DescriptionOnly baseTask
                            else
                                Planned
                                    { id = baseTask.id
                                    , description = baseTask.description
                                    , status = baseTask.status
                                    , createdAt = baseTask.createdAt
                                    , updatedAt = baseTask.updatedAt
                                    , sessionId = baseTask.sessionId
                                    , source = baseTask.source
                                    , agentWorkspace = baseTask.agentWorkspace
                                    , attachments = baseTask.attachments
                                    , summary = planningFields.summary
                                    , requirements = planningFields.requirements
                                    , acceptanceCriteria = planningFields.acceptanceCriteria
                                    , plan = planningFields.plan
                                    }
                        )
            )


{-| Decode an attachment from JSON.
-}
attachmentDecoder : Decoder Attachment
attachmentDecoder =
    Decode.map4
        (\filename size contentType uploadedAt ->
            { filename = filename
            , size = size
            , contentType = contentType
            , uploadedAt = uploadedAt
            }
        )
        (Decode.field "filename" Decode.string)
        (Decode.field "size" Decode.int)
        (Decode.field "contentType" Decode.string)
        (Decode.field "uploadedAt" (Decode.map Time.millisToPosix Decode.int))


statusDecoder : Decoder TaskStatus
statusDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\statusType ->
                when statusType is
                    "pending" ->
                        Decode.succeed Pending

                    "active" ->
                        Decode.succeed Active

                    "waiting" ->
                        Decode.succeed Waiting

                    "completed" ->
                        Decode.succeed Completed

                    "failed" ->
                        Decode.field "message" Decode.string
                            |> Decode.map Failed

                    _ ->
                        Decode.fail ("Unknown status type: " ++ statusType)
            )


sourceInfoDecoder : Decoder SourceInfo
sourceInfoDecoder =
    Decode.map3
        (\sourceType userId conversationId ->
            { sourceType = sourceType
            , userId = userId
            , conversationId = conversationId
            }
        )
        (Decode.field "sourceType" Decode.string)
        (Decode.field "userId" Decode.string)
        (Decode.field "conversationId" (Decode.maybe Decode.string))



-- REGISTRY INDEX TYPES AND OPERATIONS


{-| Summary of a task stored in the registry index.
-}
type alias TaskSummary =
    { id : String
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    }


{-| Registry index stored in registry.json.
-}
type alias RegistryIndex =
    { version : Int
    , tasks : Array TaskSummary
    }


{-| Read the registry index from disk.
-}
readRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error RegistryIndex
readRegistryIndex fsPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot
    in
    FileSystem.readFile fsPermission indexPath
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString registryIndexDecoder content is
                            Ok index ->
                                GrenTask.succeed index

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


{-| Update the registry index atomically.
-}
updateRegistryIndex :
    FileSystem.Permission
    -> Path
    -> (RegistryIndex -> RegistryIndex)
    -> GrenTask.Task Error {}
updateRegistryIndex fsPermission registryRoot updateFn =
    readRegistryIndex fsPermission registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    updatedIndex =
                        updateFn index

                    indexPath =
                        Path.append (Path.fromPosixString "registry.json") registryRoot

                    indexJson =
                        encodeRegistryIndex updatedIndex
                            |> Encode.encode 2
                in
                writeFileAtomic fsPermission indexPath indexJson
                    |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
            )


encodeRegistryIndex : RegistryIndex -> Encode.Value
encodeRegistryIndex index =
    Encode.object
        [ { key = "version", value = Encode.int index.version }
        , { key = "tasks", value = Encode.array encodeTaskSummary index.tasks }
        ]


encodeTaskSummary : TaskSummary -> Encode.Value
encodeTaskSummary summary =
    Encode.object
        [ { key = "id", value = Encode.string summary.id }
        , { key = "description", value = Encode.string summary.description }
        , { key = "status", value = encodeStatus summary.status }
        , { key = "createdAt", value = Encode.int (Time.posixToMillis summary.createdAt) }
        , { key = "updatedAt", value = Encode.int (Time.posixToMillis summary.updatedAt) }
        ]


registryIndexDecoder : Decoder RegistryIndex
registryIndexDecoder =
    Decode.map2
        (\version tasks -> { version = version, tasks = tasks })
        (Decode.field "version" Decode.int)
        (Decode.field "tasks" (Decode.array taskSummaryDecoder))


taskSummaryDecoder : Decoder TaskSummary
taskSummaryDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))



-- HISTORY OPERATIONS


{-| Read history events from disk.
-}
readHistory : FileSystem.Permission -> Path -> GrenTask.Task Error (Array Event)
readHistory fsPermission path =
    FileSystem.readFile fsPermission path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString historyDecoder content is
                            Ok events ->
                                GrenTask.succeed events

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


encodeHistory : Array Event -> Encode.Value
encodeHistory events =
    Encode.object
        [ { key = "events", value = Encode.array encodeEvent events }
        ]


encodeEvent : Event -> Encode.Value
encodeEvent event =
    Encode.object
        [ { key = "timestamp", value = Encode.int (Time.posixToMillis event.timestamp) }
        , { key = "eventType", value = Encode.string event.eventType }
        , { key = "data", value = Encode.dict identity Encode.string event.data }
        ]


historyDecoder : Decoder (Array Event)
historyDecoder =
    Decode.field "events" (Decode.array eventDecoder)


eventDecoder : Decoder Event
eventDecoder =
    Decode.map3
        (\timestamp eventType data ->
            { timestamp = timestamp
            , eventType = eventType
            , data = data
            }
        )
        (Decode.field "timestamp" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "eventType" Decode.string)
        (Decode.field "data" (Decode.dict Decode.string))


encodeEmptyQueue : Encode.Value
encodeEmptyQueue =
    Encode.object
        [ { key = "messages", value = Encode.array identity [] }
        ]



-- STATUS HELPERS


{-| Check if two statuses are equal (for filtering).
-}
statusEquals : TaskStatus -> TaskStatus -> Bool
statusEquals a b =
    when { a = a, b = b } is
        { a = Pending, b = Pending } ->
            True

        { a = Active, b = Active } ->
            True

        { a = Waiting, b = Waiting } ->
            True

        { a = Completed, b = Completed } ->
            True

        { a = Failed _, b = Failed _ } ->
            True

        _ ->
            False



-- CONTENT TYPE HELPERS


{-| Infer a MIME content type from a file extension.
-}
contentTypeFromExtension : String -> String
contentTypeFromExtension filename =
    let
        extension =
            filename
                |> String.split "."
                |> Array.last
                |> Maybe.withDefault ""
                |> String.toLower
    in
    when extension is
        "png" ->
            "image/png"

        "jpg" ->
            "image/jpeg"

        "jpeg" ->
            "image/jpeg"

        "gif" ->
            "image/gif"

        "pdf" ->
            "application/pdf"

        "txt" ->
            "text/plain"

        "md" ->
            "text/markdown"

        "json" ->
            "application/json"

        "csv" ->
            "text/csv"

        "html" ->
            "text/html"

        _ ->
            "application/octet-stream"



-- FILE HELPERS


{-| Write a file atomically (write to temp, then rename).
-}
writeFileAtomic : FileSystem.Permission -> Path -> String -> GrenTask.Task FileSystem.Error {}
writeFileAtomic fsPermission path content =
    let
        tempPath =
            Path.fromPosixString (Path.toPosixString path ++ ".tmp")

        bytes =
            Bytes.fromString content
    in
    FileSystem.writeFile fsPermission bytes tempPath
        |> GrenTask.andThen (\_ -> FileSystem.move fsPermission path tempPath)
        |> GrenTask.map (\_ -> {})
