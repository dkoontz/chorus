module Web.Api exposing
    ( ApiResult(..)
    , BinaryResult(..)
    , requestTasks
    , requestTask
    , requestCreateTask
    , requestUpdateStatus
    , requestUpdatePlanning
    , requestHistory
    , requestQueue
    , requestEnqueue
    , requestUploadAttachment
    , requestDownloadAttachment
    , requestDeleteAttachment
    , sendApiResponse
    , sendBinaryResponse
    , CreateTaskParams
    , UpdatePlanningParams
    )

{-| API request handlers for the Chorus web interface.

Each endpoint produces an ApiResult that should be sent back via the Response.

-}

import Bytes exposing (Bytes)
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer exposing (Request)
import HttpServer.Response as Response exposing (Response)
import Json.Decode as Decode
import Json.Encode as Encode
import Task as GrenTask exposing (Task)
import Task.Queue as Queue
import Task.Registry as Registry
import Time
import Web.Router exposing (Route(..))


-- TYPES


{-| Context needed for API operations.
-}
type alias ApiContext =
    { registry : Registry.Registry
    , fsPermission : FileSystem.Permission
    , secureContext : SecureContext
    , registryRoot : Path
    }


{-| Result of an API operation.
-}
type ApiResult
    = ApiSuccess { statusCode : Int, body : String }
    | ApiError { statusCode : Int, code : String, message : String }


{-| Parameters for creating a task.
-}
type alias CreateTaskParams =
    { description : String
    , source : Registry.SourceInfo
    }


{-| Parameters for updating task planning fields.
    Each field is optional; only present fields are updated.
-}
type alias UpdatePlanningParams =
    { summary : Maybe String
    , requirements : Maybe (Array String)
    , acceptanceCriteria : Maybe (Array String)
    , plan : Maybe (Array String)
    }


{-| Result of a binary file operation (for attachment downloads).
-}
type BinaryResult
    = BinarySuccess { bytes : Bytes.Bytes, contentType : String }
    | BinaryError { statusCode : Int, code : String, message : String }



-- API HANDLERS - Return Tasks that produce ApiResult


{-| GET /api/tasks - List all tasks.
-}
requestTasks : ApiContext -> Maybe String -> (ApiResult -> msg) -> Cmd msg
requestTasks ctx maybeStatus toMsg =
    let
        statusFilter =
            maybeStatus
                |> Maybe.andThen parseStatus
    in
    Registry.listTasks ctx.registry statusFilter
        |> GrenTask.andThen
            (\tasks ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                tasksJson =
                                    Encode.array Registry.encodeTask tasks

                                body =
                                    wrapResponse tasksJson now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = registryErrorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id - Get a single task.
-}
requestTask : ApiContext -> String -> (ApiResult -> msg) -> Cmd msg
requestTask ctx taskId toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ taskId })

                    Just task ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        body =
                                            wrapResponse (Registry.encodeTask task) now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = registryErrorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks - Create a new task.
-}
requestCreateTask : ApiContext -> CreateTaskParams -> (ApiResult -> msg) -> Cmd msg
requestCreateTask ctx params toMsg =
    Registry.createTask ctx.registry
        { description = params.description
        , source = params.source
        }
        |> GrenTask.andThen
            (\task ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Registry.encodeTask task) now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = registryErrorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/status - Update task status.
-}
requestUpdateStatus : ApiContext -> String -> Registry.TaskStatus -> (ApiResult -> msg) -> Cmd msg
requestUpdateStatus ctx taskId status toMsg =
    Registry.updateStatus ctx.registry taskId status
        |> GrenTask.andThen
            (\task ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Registry.encodeTask task) now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ taskId }

                            _ ->
                                { statusCode = 500, message = registryErrorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/planning - Update task planning fields.
    Converts a DescriptionOnly task to Planned when planning fields are set.
-}
requestUpdatePlanning : ApiContext -> String -> UpdatePlanningParams -> (ApiResult -> msg) -> Cmd msg
requestUpdatePlanning ctx taskId params toMsg =
    Registry.updateTask ctx.registry taskId
        (\task ->
            let
                -- Get current planning fields (empty defaults for DescriptionOnly)
                currentFields =
                    when task is
                        Registry.DescriptionOnly _ ->
                            { summary = ""
                            , requirements = []
                            , acceptanceCriteria = []
                            , plan = []
                            }

                        Registry.Planned t ->
                            { summary = t.summary
                            , requirements = t.requirements
                            , acceptanceCriteria = t.acceptanceCriteria
                            , plan = t.plan
                            }

                newFields =
                    { summary = Maybe.withDefault currentFields.summary params.summary
                    , requirements = Maybe.withDefault currentFields.requirements params.requirements
                    , acceptanceCriteria = Maybe.withDefault currentFields.acceptanceCriteria params.acceptanceCriteria
                    , plan = Maybe.withDefault currentFields.plan params.plan
                    }
            in
            Registry.planTask task newFields
        )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Registry.encodeTask updatedTask) now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ taskId }

                            _ ->
                                { statusCode = 500, message = registryErrorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/history - Get task event history.
-}
requestHistory : ApiContext -> String -> (ApiResult -> msg) -> Cmd msg
requestHistory ctx taskId toMsg =
    let
        historyPath =
            Path.append
                (Path.fromPosixString (taskId ++ "/history.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.fsPermission historyPath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode history file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        historyValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse historyValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "History not found for task: " ++ taskId })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/queue - Get task message queue.
-}
requestQueue : ApiContext -> String -> (ApiResult -> msg) -> Cmd msg
requestQueue ctx taskId toMsg =
    let
        queuePath =
            Path.append
                (Path.fromPosixString (taskId ++ "/queue.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.fsPermission queuePath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode queue file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        queueValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse queueValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Queue not found for task: " ++ taskId })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks/:id/queue - Add message to task queue.
-}
requestEnqueue : ApiContext -> String -> String -> (ApiResult -> msg) -> Cmd msg
requestEnqueue ctx taskId content toMsg =
    let
        taskDir =
            Path.append (Path.fromPosixString taskId) ctx.registryRoot
    in
    Queue.enqueue ctx.fsPermission ctx.secureContext taskDir taskId content
        |> GrenTask.andThen
            (\message ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                msgJson =
                                    Encode.object
                                        [ { key = "id", value = Encode.string message.id }
                                        , { key = "content", value = Encode.string message.content }
                                        , { key = "receivedAt", value = Encode.int (Time.posixToMillis message.receivedAt) }
                                        ]

                                body =
                                    wrapResponse msgJson now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "QUEUE_ERROR", message = queueErrorToString err })
            )
        |> GrenTask.perform toMsg



{-| POST /api/tasks/:id/attachments?filename=... - Upload a file attachment.
-}
requestUploadAttachment :
    ApiContext
    -> String
    -> String
    -> Bytes.Bytes
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestUploadAttachment ctx taskId filename fileBytes uploadDir toMsg =
    let
        maxSize =
            10 * 1024 * 1024  -- 10MB

        fileSize =
            Bytes.length fileBytes
    in
    if fileSize > maxSize then
        GrenTask.succeed (ApiError { statusCode = 413, code = "FILE_TOO_LARGE", message = "Upload exceeds 10MB limit" })
            |> GrenTask.perform toMsg
    else
        let
            contentType =
                Registry.contentTypeFromExtension filename

            taskUploadDir =
                Path.append (Path.fromPosixString taskId) (Path.fromPosixString uploadDir)

            filePath =
                Path.append (Path.fromPosixString filename) taskUploadDir
        in
        -- Create the per-task upload directory
        FileSystem.makeDirectory ctx.fsPermission { recursive = True } taskUploadDir
            |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
            |> GrenTask.andThen
                (\_ ->
                    -- Write the file
                    FileSystem.writeFile ctx.fsPermission fileBytes filePath
                        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                )
            |> GrenTask.andThen
                (\_ ->
                    -- Get current time for the attachment metadata
                    Time.now
                        |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                )
            |> GrenTask.andThen
                (\now ->
                    let
                        attachment =
                            { filename = filename
                            , size = fileSize
                            , contentType = contentType
                            , uploadedAt = now
                            }
                    in
                    -- Update the task to add the attachment metadata
                    Registry.updateTask ctx.registry taskId
                        (\task ->
                            Registry.setAttachments
                                (Array.pushLast attachment (Registry.taskAttachments task))
                                task
                        )
                        |> GrenTask.map
                            (\updatedTask ->
                                ApiSuccess
                                    { statusCode = 200
                                    , body =
                                        wrapResponse (Registry.encodeTask updatedTask) now
                                    }
                            )
                )
            |> GrenTask.onError
                (\err ->
                    GrenTask.succeed (ApiError { statusCode = 500, code = "UPLOAD_ERROR", message = registryErrorToString err })
                )
            |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/attachments/:filename - Download a file attachment.
-}
requestDownloadAttachment :
    ApiContext
    -> String
    -> String
    -> String
    -> (BinaryResult -> msg)
    -> Cmd msg
requestDownloadAttachment ctx taskId filename uploadDir toMsg =
    let
        taskUploadDir =
            Path.append (Path.fromPosixString taskId) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- First get the task to find the content type
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (Registry.TaskNotFound taskId)

                    Just task ->
                        let
                            maybeAttachment =
                                Array.findFirst (\a -> a.filename == filename) (Registry.taskAttachments task)
                        in
                        when maybeAttachment is
                            Nothing ->
                                GrenTask.fail (Registry.FileSystemError ("Attachment not found: " ++ filename))

                            Just { value } ->
                                FileSystem.readFile ctx.fsPermission filePath
                                    |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                                    |> GrenTask.map
                                        (\bytes ->
                                            BinarySuccess
                                                { bytes = bytes
                                                , contentType = value.contentType
                                                }
                                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        registryErrorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (BinaryError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (BinaryError { statusCode = 500, code = "DOWNLOAD_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg


{-| DELETE /api/tasks/:id/attachments/:filename - Delete a file attachment.
-}
requestDeleteAttachment :
    ApiContext
    -> String
    -> String
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestDeleteAttachment ctx taskId filename uploadDir toMsg =
    let
        taskUploadDir =
            Path.append (Path.fromPosixString taskId) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- Delete the file from disk
    FileSystem.remove ctx.fsPermission { recursive = False } filePath
        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\_ ->
                -- Remove the attachment entry from the task
                Registry.updateTask ctx.registry taskId
                    (\task ->
                        Registry.setAttachments
                            (Array.keepIf (\a -> a.filename /= filename) (Registry.taskAttachments task))
                            task
                    )
            )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess
                                { statusCode = 200
                                , body =
                                    wrapResponse (Registry.encodeTask updatedTask) now
                                }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        registryErrorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (ApiError { statusCode = 500, code = "DELETE_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg



-- RESPONSE SENDING


{-| Send an API response.
-}
sendApiResponse : Response -> ApiResult -> Cmd msg
sendApiResponse response result =
    when result is
        ApiSuccess { statusCode, body } ->
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody body
                |> Response.send

        ApiError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send



{-| Send a binary response (for file downloads).
-}
sendBinaryResponse : Response -> BinaryResult -> Cmd msg
sendBinaryResponse response result =
    when result is
        BinarySuccess { bytes, contentType } ->
            response
                |> Response.setStatus 200
                |> Response.setHeader "Content-Type" contentType
                |> Response.setBodyAsBytes bytes
                |> Response.send

        BinaryError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send



-- HELPERS


{-| Parse a status string to TaskStatus.
-}
parseStatus : String -> Maybe Registry.TaskStatus
parseStatus statusStr =
    when statusStr is
        "pending" ->
            Just Registry.Pending

        "active" ->
            Just Registry.Active

        "waiting" ->
            Just Registry.Waiting

        "completed" ->
            Just Registry.Completed

        "failed" ->
            Just (Registry.Failed "")

        _ ->
            Nothing


{-| Wrap data in standard response format.
-}
wrapResponse : Encode.Value -> Time.Posix -> String
wrapResponse data timestamp =
    Encode.object
        [ { key = "data", value = data }
        , { key = "meta"
          , value =
                Encode.object
                    [ { key = "timestamp", value = Encode.int (Time.posixToMillis timestamp) }
                    ]
          }
        ]
        |> Encode.encode 0


{-| Convert registry error to string.
-}
registryErrorToString : Registry.Error -> String
registryErrorToString err =
    when err is
        Registry.FileSystemError msg ->
            "File system error: " ++ msg

        Registry.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Registry.TaskNotFound id ->
            "Task not found: " ++ id

        Registry.RegistryCorrupt msg ->
            "Registry corrupt: " ++ msg


{-| Convert queue error to string.
-}
queueErrorToString : Queue.Error -> String
queueErrorToString err =
    when err is
        Queue.FileSystemError msg ->
            "File system error: " ++ msg

        Queue.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Queue.TaskNotFound id ->
            "Task not found: " ++ id
