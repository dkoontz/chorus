module Main exposing (main)

{-| Chorus Web UI - Task Registry Dashboard

A browser application for managing and monitoring tasks in the Chorus
orchestration system.

Features:
- Real-time task list with status filtering
- Task creation form
- Task detail view with history
- Real-time updates via WebSocket

-}

import Api
import Browser
import Browser.Navigation as Nav
import Bytes exposing (Bytes)
import File exposing (File)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput, onSubmit)
import Http
import Id
import Json.Decode
import Process
import Set exposing (Set)
import Task
import Time
import Types exposing (AgentConfig(..), AgentProvider(..), ProviderConfig, SourceType(..), Task(..), TaskStatus(..), WorkspaceConfig, WorkspaceEntry)
import Url exposing (Url)
import View.Agents as Agents exposing (AgentForm)
import View.Providers as Providers exposing (ProviderForm)
import View.Board as Board
import View.SystemSettings as SystemSettings exposing (SettingsForm)
import View.TaskDetail as TaskDetail exposing (PlanningSection(..), PlanningEditState)
import View.Workspaces as Workspaces
import Notification exposing (Notification)
import WebSocket
import WorkspaceStatus exposing (WorkspaceStatus(..))


-- MAIN


main : Program {} Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }



-- MODEL


type alias Model =
    { key : Nav.Key
    , page : Page
    , tasks : Array Types.Task
    , selectedTask : Maybe Types.Task
    , taskHistory : Maybe Types.History
    , taskQueue : Maybe Types.Queue
    , createForm : CreateTaskForm
    , loading : Bool
    , notifications : Array Notification
    , nextNotificationId : Int
    , currentTime : Time.Posix
    , editingPlanning : Maybe PlanningEditState
    , timeZone : Time.Zone
    , agents : Array AgentConfig
    , agentForm : Maybe AgentForm
    , providers : Array ProviderConfig
    , providerForm : Maybe ProviderForm
    , confirmingDeleteProvider : Maybe String
    , startingAgent : Maybe String
    , draftAnswers : Array String
    , expandedEvents : Set Int
    , workspaceStatus : WorkspaceStatus
    , recentWorkspaces : Array WorkspaceEntry
    , openPath : String
    , createName : String
    , createPath : String
    , defaultWorkspacePath : String
    , createPathManuallyEdited : Bool
    , nameValidationError : Maybe String
    , settingsForm : Maybe SettingsForm
    , settingsValidationError : Maybe String
    , websocketConnection : WebSocketConnectionState
    , websocketUrl : String
    , initialUrl : Url
    , bulkProviderMode : Bool
    , selectedAgents : Set String
    , bulkProvider : String
    , bulkModel : String
    }


{-| WebSocket connection state. Uses a custom type so that invalid
combinations (e.g. "connecting but also has a connection") are
impossible to represent.
-}
type WebSocketConnectionState
    = WsNotConnected
    | WsConnecting
    | WsConnected WebSocket.Connection
    | WsReconnecting


type Page
    = BoardPage
    | TaskDetailPage String
    | AgentsPage
    | ProvidersPage
    | WorkspacesPage
    | SystemSettingsPage
    | NotFoundPage


type alias CreateTaskForm =
    { description : String
    , sourceType : SourceType
    , userId : String
    , isOpen : Bool
    }


emptyCreateForm : CreateTaskForm
emptyCreateForm =
    { description = ""
    , sourceType = WebSource
    , userId = "anonymous"
    , isOpen = False
    }



-- MSG


type Msg
    = LinkClicked Browser.UrlRequest
    | UrlChanged Url
    | GotTasks (Result Http.Error (Array Types.Task))
    | GotTask (Result Http.Error Types.Task)
    | GotHistory (Result Http.Error Types.History)
    | GotQueue (Result Http.Error Types.Queue)
    | TaskCreated (Result Http.Error Types.Task)
    | StatusUpdated (Result Http.Error Types.Task)
    | Tick Time.Posix
      -- WebSocket
    | GotWsConnection (Result WebSocket.ConnectError WebSocket.Connection)
    | GotWsMessage { connection : WebSocket.Connection, message : WebSocket.Message }
    | GotWsClosed { connection : WebSocket.Connection, reason : WebSocket.CloseReason }
    | GotWsError { connection : WebSocket.Connection, error : String }
    | WsReconnect
    | OpenCreateForm
    | CloseCreateForm
    | UpdateCreateDescription String
    | SubmitCreateForm
    | UpdateTaskStatus { taskId : String, status : String }
    | RefreshTask String
    | DismissNotification Int
    | FileSelected File
    | GotFileBytes { file : File, bytes : Bytes }
    | FileUploaded (Result Http.Error Types.Task)
    | DeleteAttachment { taskId : String, filename : String }
    | AttachmentDeleted (Result Http.Error Types.Task)
    | EditPlanningSection PlanningSection
    | UpdatePlanningDraft String
    | UpdatePlanningItemDraft { index : Int, value : String }
    | AddPlanningItem
    | RemovePlanningItem Int
    | SavePlanning
    | CancelPlanningEdit
    | PlanningUpdated (Result Http.Error Types.Task)
    | GotZone Time.Zone
      -- Agent CRUD
    | GotAgents (Result Http.Error (Array AgentConfig))
    | GotAgentSaved (Result Http.Error AgentConfig)
    | GotAgentDeleted { name : String, result : Result Http.Error {} }
    | OpenAgentCreateForm
    | OpenAgentEditForm AgentConfig
    | CloseAgentForm
    | UpdateAgentName String
    | UpdateAgentInstructions String
    | UpdateAgentAllowedTools String
    | UpdateAgentProvider String
    | UpdateAgentModel String
    | SaveAgent
    | DeleteAgent String
      -- Agent bulk provider
    | ToggleBulkProviderMode
    | ToggleAgentSelected String
    | UpdateBulkProvider String
    | UpdateBulkModel String
    | ApplyBulkProvider
    | GotBulkAgentSaved (Result Http.Error AgentConfig)
      -- Provider CRUD
    | GotProviders (Result Http.Error (Array ProviderConfig))
    | GotProviderSaved (Result Http.Error ProviderConfig)
    | GotProviderDeleted { name : String, result : Result Http.Error {} }
    | OpenProviderCreateForm
    | OpenProviderEditForm ProviderConfig
    | CloseProviderForm
    | UpdateProviderName String
    | UpdateProviderType String
    | UpdateProviderApiBaseUrl String
    | UpdateProviderApiKey String
    | UpdateProviderPreset String
    | UpdateProviderDefaultModel String
    | SaveProvider
    | DeleteProvider String
    | ConfirmDeleteProvider String
    | PlanTask String
    | PlanTaskStarted (Result Http.Error Types.Task)
    | SelectStartAgent String
    | StartTask String
    | HandoffStarted (Result Http.Error Types.Task)
    | UpdateAnswer { index : Int, value : String }
    | SubmitAnswers String
    | AnswersSubmitted (Result Http.Error Types.Task)
    | ToggleEventExpanded Int
      -- Workspace config
    | GotInitialConfig (Result Http.Error Api.ConfigResponse)
    | GotConfig (Result Http.Error Api.ConfigResponse)
    | GotConfigDefaults (Result Http.Error Api.ConfigDefaultsResponse)
    | UpdateOpenPath String
    | UpdateCreateName String
    | UpdateCreatePath String
    | SelectConfig
    | CreateConfig
      -- Workspace history
    | GotWorkspaces (Result Http.Error (Array WorkspaceEntry))
    | OpenRecentWorkspace String
    | RemoveRecentWorkspace String
    | WorkspaceRemoved { path : String, result : Result Http.Error {} }
      -- System settings
    | UpdateSettingsAllowedDir { index : Int, value : String }
    | AddSettingsAllowedDir
    | RemoveSettingsAllowedDir Int
    | UpdateSettingsInitialAgentDirectory String
    | UpdateSettingsSystemAgentProvider String
    | UpdateSettingsServerPort String
    | SaveSettings
    | SettingsSaved (Result Http.Error Api.ConfigResponse)
    | NoOp



-- INIT


init : {} -> Url -> Nav.Key -> { model : Model, command : Cmd Msg }
init _ url key =
    let
        -- Derive the WebSocket URL from the page URL.
        -- The WebSocket server runs on HTTP port + 1.
        wsUrl =
            let
                httpPort =
                    Maybe.withDefault 8080 url.port_

                wsPort =
                    httpPort + 1
            in
            "ws://" ++ url.host ++ ":" ++ String.fromInt wsPort

        model =
            { key = key
            , page = WorkspacesPage
            , tasks = []
            , selectedTask = Nothing
            , taskHistory = Nothing
            , taskQueue = Nothing
            , createForm = emptyCreateForm
            , loading = True
            , notifications = []
            , nextNotificationId = 0
            , currentTime = Time.millisToPosix 0
            , editingPlanning = Nothing
            , timeZone = Time.utc
            , agents = []
            , agentForm = Nothing
            , providers = []
            , providerForm = Nothing
            , confirmingDeleteProvider = Nothing
            , startingAgent = Nothing
            , draftAnswers = []
            , expandedEvents = Set.empty
            , workspaceStatus = NoWorkspace
            , recentWorkspaces = []
            , openPath = ""
            , createName = ""
            , createPath = ""
            , defaultWorkspacePath = ""
            , createPathManuallyEdited = False
            , nameValidationError = Nothing
            , settingsForm = Nothing
            , settingsValidationError = Nothing
            , websocketConnection = WsNotConnected
            , websocketUrl = wsUrl
            , initialUrl = url
            , bulkProviderMode = False
            , selectedAgents = Set.empty
            , bulkProvider = ""
            , bulkModel = ""
            }
    in
    { model = model
    , command =
        Cmd.batch
            [ Api.getConfig GotInitialConfig
            , Api.getWorkspaces GotWorkspaces
            , Api.getConfigDefaults GotConfigDefaults
            , Task.perform GotZone Time.here
            ]
    }


urlToPage : Url -> Page
urlToPage url =
    when url.path is
        "/" ->
            BoardPage

        "/tasks" ->
            BoardPage

        "/agents" ->
            AgentsPage

        "/providers" ->
            ProvidersPage

        "/workspaces" ->
            WorkspacesPage

        "/settings" ->
            SystemSettingsPage

        _ ->
            if String.startsWith "/tasks/" url.path then
                let
                    taskId =
                        String.dropFirst 7 url.path
                in
                if String.isEmpty taskId then
                    BoardPage
                else
                    TaskDetailPage taskId
            else
                NotFoundPage


loadPageData : Page -> Cmd Msg
loadPageData page =
    when page is
        BoardPage ->
            Api.getTasks Nothing GotTasks

        TaskDetailPage taskId ->
            Cmd.batch
                [ Api.getTask taskId GotTask
                , Api.getTaskHistory taskId GotHistory
                , Api.getTaskQueue taskId GotQueue
                , Api.getAgents GotAgents
                ]

        AgentsPage ->
            Cmd.batch
                [ Api.getAgents GotAgents
                , Api.getProviders GotProviders
                ]

        ProvidersPage ->
            Api.getProviders GotProviders

        WorkspacesPage ->
            Cmd.batch
                [ Api.getWorkspaces GotWorkspaces
                , Api.getConfigDefaults GotConfigDefaults
                ]

        SystemSettingsPage ->
            Api.getProviders GotProviders

        NotFoundPage ->
            Cmd.none



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        LinkClicked urlRequest ->
            when urlRequest is
                Browser.Internal url ->
                    { model = model
                    , command = Nav.pushUrl model.key (Url.toString url)
                    }

                Browser.External href ->
                    { model = model
                    , command = Nav.load href
                    }

        UrlChanged url ->
            let
                requestedPage =
                    urlToPage url

                page =
                    if not (WorkspaceStatus.isOpened model.workspaceStatus) && requiresConfig requestedPage then
                        WorkspacesPage
                    else
                        requestedPage
            in
            { model =
                { model
                    | page = page
                    , selectedTask = Nothing
                    , taskHistory = Nothing
                    , taskQueue = Nothing
                    , loading = pageLoadsData page
                    , editingPlanning = Nothing
                    , agentForm = Nothing
                    , providerForm = Nothing
                    , confirmingDeleteProvider = Nothing
                    , startingAgent = Nothing
                    , draftAnswers = []
                    , expandedEvents = Set.empty
                    , bulkProviderMode = False
                    , selectedAgents = Set.empty
                    , bulkProvider = ""
                    , bulkModel = ""
                    , settingsForm =
                        if page == SystemSettingsPage then
                            when model.workspaceStatus is
                                WorkspaceOpened { config } ->
                                    Just (SystemSettings.workspaceConfigToForm config)

                                _ ->
                                    Nothing
                        else
                            model.settingsForm
                    , settingsValidationError = Nothing
                }
            , command = loadPageData page
            }

        GotTasks result ->
            when result is
                Ok tasks ->
                    { model = { model | tasks = tasks, loading = False }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) { model | loading = False }
                    , command = Cmd.none
                    }

        GotTask result ->
            when result is
                Ok task ->
                    let
                        answers =
                            Types.taskQuestions task
                                |> Array.map (\q -> Maybe.withDefault "" q.answer)
                    in
                    { model = { model | selectedTask = Just task, loading = False, draftAnswers = answers }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) { model | loading = False }
                    , command = Cmd.none
                    }

        GotHistory result ->
            when result is
                Ok history ->
                    { model = { model | taskHistory = Just history }
                    , command = Cmd.none
                    }

                Err _ ->
                    -- History fetch failure is non-critical
                    { model = model
                    , command = Cmd.none
                    }

        GotQueue result ->
            when result is
                Ok queue ->
                    { model = { model | taskQueue = Just queue }
                    , command = Cmd.none
                    }

                Err _ ->
                    -- Queue fetch failure is non-critical
                    { model = model
                    , command = Cmd.none
                    }

        TaskCreated result ->
            when result is
                Ok task ->
                    { model =
                        addSuccessNotification "Task created"
                            { model
                                | tasks = Array.pushLast task model.tasks
                                , createForm = emptyCreateForm
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        StatusUpdated result ->
            when result is
                Ok updatedTask ->
                    let
                        updateTask t =
                            if Types.taskId t == Types.taskId updatedTask then
                                updatedTask
                            else
                                t

                        newTasks =
                            Array.map updateTask model.tasks

                        newSelected =
                            when model.selectedTask is
                                Just selected ->
                                    if Types.taskId selected == Types.taskId updatedTask then
                                        Just updatedTask
                                    else
                                        model.selectedTask

                                Nothing ->
                                    Nothing
                    in
                    { model =
                        { model
                            | tasks = newTasks
                            , selectedTask = newSelected
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        Tick now ->
            { model =
                { model
                    | currentTime = now
                    , notifications =
                        Array.keepIf (\n -> not (Notification.isExpired now n)) model.notifications
                }
            , command = Cmd.none
            }

        OpenCreateForm ->
            { model = { model | createForm = { emptyCreateForm | isOpen = True } }
            , command = Cmd.none
            }

        CloseCreateForm ->
            { model = { model | createForm = emptyCreateForm }
            , command = Cmd.none
            }

        UpdateCreateDescription description ->
            let
                form =
                    model.createForm
            in
            { model = { model | createForm = { form | description = description } }
            , command = Cmd.none
            }

        SubmitCreateForm ->
            if String.isEmpty (String.trim model.createForm.description) then
                { model = addErrorNotification "Task description is required" model
                , command = Cmd.none
                }
            else
                { model = model
                , command =
                    Api.createTask
                        { description = model.createForm.description
                        , source =
                            { sourceType = model.createForm.sourceType
                            , userId = model.createForm.userId
                            , conversationId = Nothing
                            }
                        }
                        TaskCreated
                }

        UpdateTaskStatus { taskId, status } ->
            { model = model
            , command = Api.updateTaskStatus taskId status StatusUpdated
            }

        RefreshTask taskId ->
            { model = { model | loading = True }
            , command =
                Cmd.batch
                    [ Api.getTask taskId GotTask
                    , Api.getTaskHistory taskId GotHistory
                    , Api.getTaskQueue taskId GotQueue
                    ]
            }

        DismissNotification id ->
            { model =
                { model
                    | notifications =
                        Array.keepIf (\n -> Notification.notificationId n /= id) model.notifications
                }
            , command = Cmd.none
            }

        FileSelected file ->
            { model = model
            , command =
                File.toBytes file
                    |> Task.map (\bytes -> { file = file, bytes = bytes })
                    |> Task.perform GotFileBytes
            }

        GotFileBytes { file, bytes } ->
            when model.page is
                TaskDetailPage taskId ->
                    { model = model
                    , command =
                        Api.uploadAttachment taskId (File.name file) bytes (File.mime file) FileUploaded
                    }

                _ ->
                    { model = model
                    , command = Cmd.none
                    }

        FileUploaded result ->
            when result is
                Ok updatedTask ->
                    { model = { model | selectedTask = Just updatedTask }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        DeleteAttachment { taskId, filename } ->
            { model = model
            , command = Api.deleteAttachment taskId filename AttachmentDeleted
            }

        AttachmentDeleted result ->
            when result is
                Ok updatedTask ->
                    { model = { model | selectedTask = Just updatedTask }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        EditPlanningSection section ->
            let
                editState =
                    when model.selectedTask is
                        Just task ->
                            let
                                -- Get current planning values (empty for DescriptionOnly)
                                planning =
                                    when task is
                                        DescriptionOnly _ ->
                                            { summary = ""
                                            , requirements = []
                                            , acceptanceCriteria = []
                                            , plan = []
                                            }

                                        Planned t ->
                                            { summary = t.summary
                                            , requirements = t.requirements
                                            , acceptanceCriteria = t.acceptanceCriteria
                                            , plan = t.plan
                                            }
                            in
                            when section is
                                PlanningSummary ->
                                    Just
                                        { section = section
                                        , draftSummary = planning.summary
                                        , draftItems = []
                                        }

                                PlanningRequirements ->
                                    Just
                                        { section = section
                                        , draftSummary = ""
                                        , draftItems = planning.requirements
                                        }

                                PlanningAcceptanceCriteria ->
                                    Just
                                        { section = section
                                        , draftSummary = ""
                                        , draftItems = planning.acceptanceCriteria
                                        }

                                PlanningPlan ->
                                    Just
                                        { section = section
                                        , draftSummary = ""
                                        , draftItems = planning.plan
                                        }

                        Nothing ->
                            Nothing
            in
            { model = { model | editingPlanning = editState }
            , command = Cmd.none
            }

        UpdatePlanningDraft value ->
            { model =
                { model
                    | editingPlanning =
                        Maybe.map
                            (\state -> { state | draftSummary = value })
                            model.editingPlanning
                }
            , command = Cmd.none
            }

        UpdatePlanningItemDraft { index, value } ->
            { model =
                { model
                    | editingPlanning =
                        Maybe.map
                            (\state -> { state | draftItems = Array.set index value state.draftItems })
                            model.editingPlanning
                }
            , command = Cmd.none
            }

        AddPlanningItem ->
            { model =
                { model
                    | editingPlanning =
                        Maybe.map
                            (\state -> { state | draftItems = Array.pushLast "" state.draftItems })
                            model.editingPlanning
                }
            , command = Cmd.none
            }

        RemovePlanningItem index ->
            { model =
                { model
                    | editingPlanning =
                        Maybe.map
                            (\state ->
                                { state
                                    | draftItems =
                                        state.draftItems
                                            |> Array.indexedMap (\i item -> { index = i, item = item })
                                            |> Array.keepIf (\entry -> entry.index /= index)
                                            |> Array.map .item
                                }
                            )
                            model.editingPlanning
                }
            , command = Cmd.none
            }

        SavePlanning ->
            when { task = model.selectedTask, editing = model.editingPlanning } is
                { task = Just task, editing = Just editState } ->
                    let
                        params =
                            when editState.section is
                                PlanningSummary ->
                                    { summary = Just editState.draftSummary
                                    , requirements = Nothing
                                    , acceptanceCriteria = Nothing
                                    , plan = Nothing
                                    }

                                PlanningRequirements ->
                                    { summary = Nothing
                                    , requirements = Just editState.draftItems
                                    , acceptanceCriteria = Nothing
                                    , plan = Nothing
                                    }

                                PlanningAcceptanceCriteria ->
                                    { summary = Nothing
                                    , requirements = Nothing
                                    , acceptanceCriteria = Just editState.draftItems
                                    , plan = Nothing
                                    }

                                PlanningPlan ->
                                    { summary = Nothing
                                    , requirements = Nothing
                                    , acceptanceCriteria = Nothing
                                    , plan = Just editState.draftItems
                                    }
                    in
                    { model = model
                    , command = Api.updateTaskPlanning (Id.taskIdToString (Types.taskId task)) params PlanningUpdated
                    }

                _ ->
                    { model = model
                    , command = Cmd.none
                    }

        CancelPlanningEdit ->
            { model = { model | editingPlanning = Nothing }
            , command = Cmd.none
            }

        PlanningUpdated result ->
            when result is
                Ok updatedTask ->
                    { model =
                        { model
                            | selectedTask = Just updatedTask
                            , editingPlanning = Nothing
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        GotZone zone ->
            { model = { model | timeZone = zone }
            , command = Cmd.none
            }
        -- Agent CRUD

        GotAgents result ->
            when result is
                Ok agents ->
                    { model = { model | agents = agents, loading = False }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) { model | loading = False }
                    , command = Cmd.none
                    }

        GotAgentSaved result ->
            when result is
                Ok savedAgent ->
                    let
                        savedName =
                            Types.agentConfigName savedAgent

                        updatedAgents =
                            if Array.any (\a -> Types.agentConfigName a == savedName) model.agents then
                                Array.map
                                    (\a ->
                                        if Types.agentConfigName a == savedName then
                                            savedAgent
                                        else
                                            a
                                    )
                                    model.agents
                            else
                                Array.pushLast savedAgent model.agents
                    in
                    { model =
                        addSuccessNotification "Agent saved"
                            { model
                                | agents = updatedAgents
                                , agentForm = Nothing
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        GotAgentDeleted { name, result } ->
            when result is
                Ok _ ->
                    { model =
                        addSuccessNotification "Agent deleted"
                            { model
                                | agents = Array.keepIf (\a -> Types.agentConfigName a /= name) model.agents
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        OpenAgentCreateForm ->
            { model = { model | agentForm = Just Agents.emptyAgentForm }
            , command = Cmd.none
            }

        OpenAgentEditForm agent ->
            let
                form =
                    when agent is
                        UserDefinedAgent r ->
                            { name = r.name
                            , instructions = r.instructions
                            , allowedTools = String.join ", " r.allowedTools
                            , provider =
                                when r.provider is
                                    NotConfigured ->
                                        ""

                                    ProviderRef pName ->
                                        pName
                            , model = Maybe.withDefault "" r.model
                            , isEditing = True
                            }

                        InternalAgent r ->
                            { name = r.name
                            , instructions = r.instructions
                            , allowedTools = ""
                            , provider = ""
                            , model = ""
                            , isEditing = True
                            }
            in
            { model =
                { model
                    | agentForm = Just form
                }
            , command = Cmd.none
            }

        CloseAgentForm ->
            { model = { model | agentForm = Nothing }
            , command = Cmd.none
            }

        UpdateAgentName name ->
            { model =
                { model
                    | agentForm =
                        Maybe.map (\f -> { f | name = name }) model.agentForm
                }
            , command = Cmd.none
            }

        UpdateAgentInstructions instructions ->
            { model =
                { model
                    | agentForm =
                        Maybe.map (\f -> { f | instructions = instructions }) model.agentForm
                }
            , command = Cmd.none
            }

        UpdateAgentAllowedTools tools ->
            { model =
                { model
                    | agentForm =
                        Maybe.map (\f -> { f | allowedTools = tools }) model.agentForm
                }
            , command = Cmd.none
            }

        UpdateAgentProvider provider ->
            { model =
                { model
                    | agentForm =
                        Maybe.map (\f -> { f | provider = provider }) model.agentForm
                }
            , command = Cmd.none
            }

        UpdateAgentModel modelStr ->
            { model =
                { model
                    | agentForm =
                        Maybe.map (\f -> { f | model = modelStr }) model.agentForm
                }
            , command = Cmd.none
            }

        SaveAgent ->
            when model.agentForm is
                Just form ->
                    if String.isEmpty (String.trim form.name) then
                        { model = addErrorNotification "Agent name is required" model
                        , command = Cmd.none
                        }
                    else
                        let
                            agentProvider =
                                if String.isEmpty (String.trim form.provider) then
                                    NotConfigured
                                else
                                    ProviderRef (String.trim form.provider)

                            config =
                                UserDefinedAgent
                                    { name = form.name
                                    , instructions = form.instructions
                                    , allowedTools =
                                        form.allowedTools
                                            |> String.split ","
                                            |> Array.map String.trim
                                            |> Array.keepIf (\s -> not (String.isEmpty s))
                                    , provider = agentProvider
                                    , model =
                                        if String.isEmpty (String.trim form.model) then
                                            Nothing
                                        else
                                            Just (String.trim form.model)
                                    }
                        in
                        if form.isEditing then
                            { model = model
                            , command = Api.updateAgent form.name config GotAgentSaved
                            }
                        else
                            { model = model
                            , command = Api.createAgent config GotAgentSaved
                            }

                Nothing ->
                    { model = model
                    , command = Cmd.none
                    }

        DeleteAgent name ->
            { model = model
            , command = Api.deleteAgent name (\result -> GotAgentDeleted { name = name, result = result })
            }

        -- Agent bulk provider

        ToggleBulkProviderMode ->
            { model =
                { model
                    | bulkProviderMode = not model.bulkProviderMode
                    , selectedAgents = Set.empty
                    , bulkProvider = ""
                    , bulkModel = ""
                }
            , command = Cmd.none
            }

        ToggleAgentSelected agentName ->
            { model =
                { model
                    | selectedAgents =
                        Set.toggle agentName model.selectedAgents
                }
            , command = Cmd.none
            }

        UpdateBulkProvider provider ->
            { model = { model | bulkProvider = provider }
            , command = Cmd.none
            }

        UpdateBulkModel bulkModelStr ->
            { model = { model | bulkModel = bulkModelStr }
            , command = Cmd.none
            }

        ApplyBulkProvider ->
            let
                selectedNames =
                    Set.toArray model.selectedAgents

                agentProvider =
                    if String.isEmpty (String.trim model.bulkProvider) then
                        NotConfigured
                    else
                        ProviderRef (String.trim model.bulkProvider)

                agentModel =
                    if String.isEmpty (String.trim model.bulkModel) then
                        Nothing
                    else
                        Just (String.trim model.bulkModel)

                commands =
                    selectedNames
                        |> Array.mapAndKeepJust
                            (\name ->
                                Array.findFirst (\a -> Types.agentConfigName a == name) model.agents
                                    |> Maybe.map .value
                                    |> Maybe.andThen
                                        (\agent ->
                                            when agent is
                                                UserDefinedAgent r ->
                                                    let
                                                        updatedConfig =
                                                            UserDefinedAgent
                                                                { r
                                                                    | provider = agentProvider
                                                                    , model = agentModel
                                                                }
                                                    in
                                                    Just (Api.updateAgent name updatedConfig GotBulkAgentSaved)

                                                InternalAgent _ ->
                                                    Nothing
                                        )
                            )
            in
            if Array.isEmpty commands then
                { model = model
                , command = Cmd.none
                }
            else
                { model = model
                , command = Cmd.batch commands
                }

        GotBulkAgentSaved result ->
            when result is
                Ok savedAgent ->
                    let
                        savedName =
                            Types.agentConfigName savedAgent

                        updatedAgents =
                            if Array.any (\a -> Types.agentConfigName a == savedName) model.agents then
                                Array.map
                                    (\a ->
                                        if Types.agentConfigName a == savedName then
                                            savedAgent
                                        else
                                            a
                                    )
                                    model.agents
                            else
                                Array.pushLast savedAgent model.agents
                    in
                    { model = { model | agents = updatedAgents }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        -- Provider CRUD

        GotProviders result ->
            when result is
                Ok providersList ->
                    { model = { model | providers = providersList, loading = False }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) { model | loading = False }
                    , command = Cmd.none
                    }

        GotProviderSaved result ->
            when result is
                Ok savedProvider ->
                    let
                        updatedProviders =
                            if Array.any (\p -> p.name == savedProvider.name) model.providers then
                                Array.map
                                    (\p ->
                                        if p.name == savedProvider.name then
                                            savedProvider
                                        else
                                            p
                                    )
                                    model.providers
                            else
                                Array.pushLast savedProvider model.providers
                    in
                    { model =
                        addSuccessNotification "Provider saved"
                            { model
                                | providers = updatedProviders
                                , providerForm = Nothing
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        GotProviderDeleted { name, result } ->
            when result is
                Ok _ ->
                    { model =
                        addSuccessNotification "Provider deleted"
                            { model
                                | providers = Array.keepIf (\p -> p.name /= name) model.providers
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        OpenProviderCreateForm ->
            { model = { model | providerForm = Just Providers.emptyProviderForm }
            , command = Cmd.none
            }

        OpenProviderEditForm provider ->
            { model = { model | providerForm = Just (Providers.providerConfigToForm provider) }
            , command = Cmd.none
            }

        CloseProviderForm ->
            { model = { model | providerForm = Nothing }
            , command = Cmd.none
            }

        UpdateProviderName name ->
            { model =
                { model
                    | providerForm =
                        Maybe.map (\f -> { f | name = name }) model.providerForm
                }
            , command = Cmd.none
            }

        UpdateProviderType providerType ->
            { model =
                { model
                    | providerForm =
                        Maybe.map (\f -> { f | providerType = providerType }) model.providerForm
                }
            , command = Cmd.none
            }

        UpdateProviderApiBaseUrl apiBaseUrl ->
            { model =
                { model
                    | providerForm =
                        Maybe.map (\f -> { f | apiBaseUrl = apiBaseUrl }) model.providerForm
                }
            , command = Cmd.none
            }

        UpdateProviderApiKey apiKey ->
            { model =
                { model
                    | providerForm =
                        Maybe.map (\f -> { f | apiKey = apiKey }) model.providerForm
                }
            , command = Cmd.none
            }

        UpdateProviderPreset preset ->
            { model =
                { model
                    | providerForm =
                        Maybe.map
                            (\f ->
                                { f
                                    | preset = preset
                                    , apiBaseUrl = Providers.baseUrlForPreset preset
                                }
                            )
                            model.providerForm
                }
            , command = Cmd.none
            }

        UpdateProviderDefaultModel defaultModel ->
            { model =
                { model
                    | providerForm =
                        Maybe.map (\f -> { f | defaultModel = defaultModel }) model.providerForm
                }
            , command = Cmd.none
            }

        SaveProvider ->
            when model.providerForm is
                Just form ->
                    if String.isEmpty (String.trim form.name) then
                        { model = addErrorNotification "Provider name is required" model
                        , command = Cmd.none
                        }
                    else
                        let
                            config =
                                Providers.formToProviderConfig form
                        in
                        if form.isEditing then
                            { model = model
                            , command = Api.updateProvider form.name config GotProviderSaved
                            }
                        else
                            { model = model
                            , command = Api.createProvider config GotProviderSaved
                            }

                Nothing ->
                    { model = model
                    , command = Cmd.none
                    }

        DeleteProvider name ->
            { model = { model | confirmingDeleteProvider = Nothing }
            , command = Api.deleteProvider name (\result -> GotProviderDeleted { name = name, result = result })
            }

        ConfirmDeleteProvider name ->
            { model =
                { model
                    | confirmingDeleteProvider =
                        if String.isEmpty name then
                            Nothing
                        else
                            Just name
                }
            , command = Cmd.none
            }

        PlanTask taskId ->
            { model = model
            , command = Api.planTask taskId PlanTaskStarted
            }

        PlanTaskStarted result ->
            when result is
                Ok updatedTask ->
                    let
                        updateTask t =
                            if Types.taskId t == Types.taskId updatedTask then
                                updatedTask
                            else
                                t

                        newTasks =
                            Array.map updateTask model.tasks
                    in
                    { model =
                        { model
                            | tasks = newTasks
                            , selectedTask = Just updatedTask
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        SelectStartAgent agentName ->
            { model = { model | startingAgent = Just agentName }
            , command = Cmd.none
            }

        StartTask taskId ->
            when { task = model.selectedTask, agent = model.startingAgent } is
                { task = Just task, agent = Just agentName } ->
                    let
                        prompt =
                            buildAgentPrompt task
                    in
                    { model = model
                    , command = Api.startHandoff taskId { agentName = agentName, prompt = prompt } HandoffStarted
                    }

                _ ->
                    { model = addErrorNotification "Select an agent before starting" model
                    , command = Cmd.none
                    }

        HandoffStarted result ->
            when result is
                Ok updatedTask ->
                    let
                        updateTask t =
                            if Types.taskId t == Types.taskId updatedTask then
                                updatedTask
                            else
                                t

                        newTasks =
                            Array.map updateTask model.tasks
                    in
                    { model =
                        { model
                            | tasks = newTasks
                            , selectedTask = Just updatedTask
                            , startingAgent = Nothing
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        UpdateAnswer { index, value } ->
            { model = { model | draftAnswers = Array.set index value model.draftAnswers }
            , command = Cmd.none
            }

        SubmitAnswers taskId ->
            { model = model
            , command = Api.submitAnswers taskId model.draftAnswers AnswersSubmitted
            }

        AnswersSubmitted result ->
            when result is
                Ok updatedTask ->
                    let
                        updateTask t =
                            if Types.taskId t == Types.taskId updatedTask then
                                updatedTask
                            else
                                t

                        newTasks =
                            Array.map updateTask model.tasks
                    in
                    { model =
                        { model
                            | tasks = newTasks
                            , selectedTask = Just updatedTask
                            , draftAnswers = []
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) model
                    , command = Cmd.none
                    }

        ToggleEventExpanded index ->
            { model = { model | expandedEvents = Set.toggle index model.expandedEvents }
            , command = Cmd.none
            }

        -- Workspace config

        GotConfigDefaults result ->
            when result is
                Ok defaults ->
                    { model = { model | defaultWorkspacePath = defaults.defaultWorkspacePath }
                    , command = Cmd.none
                    }

                Err _ ->
                    -- Non-critical: the user can still type a path manually
                    { model = model
                    , command = Cmd.none
                    }

        GotInitialConfig result ->
            when result is
                Ok configResponse ->
                    let
                        wc =
                            configResponse.config

                        newModel =
                            { model
                                | workspaceStatus = WorkspaceOpened { config = wc, configPath = configResponse.configPath }
                                , loading = False
                                , settingsForm = Just (SystemSettings.workspaceConfigToForm wc)
                            }
                    in
                    let
                        wsConnectCmd =
                            connectWebSocket model.websocketUrl

                        updatedModel =
                            { newModel | websocketConnection = WsConnecting }
                    in
                    if model.page == WorkspacesPage then
                        let
                            targetPage =
                                let
                                    parsedPage =
                                        urlToPage model.initialUrl
                                in
                                if requiresConfig parsedPage then
                                    parsedPage
                                else
                                    BoardPage
                        in
                        { model = { updatedModel | page = targetPage }
                        , command =
                            Cmd.batch
                                [ loadPageData targetPage
                                , wsConnectCmd
                                ]
                        }
                    else
                        { model = updatedModel
                        , command = wsConnectCmd
                        }

                Err _ ->
                    -- No config found on initial load - expected when no workspace is configured
                    { model = { model | loading = False, workspaceStatus = NoWorkspace }
                    , command = Cmd.none
                    }

        GotConfig result ->
            when result is
                Ok configResponse ->
                    let
                        wc =
                            configResponse.config

                        wasOpened =
                            WorkspaceStatus.isOpened model.workspaceStatus

                        newModel =
                            { model
                                | workspaceStatus = WorkspaceOpened { config = wc, configPath = configResponse.configPath }
                                , loading = False
                                , settingsForm = Just (SystemSettings.workspaceConfigToForm wc)
                            }

                        -- Connect WebSocket if not already connected
                        wsCmd =
                            when model.websocketConnection is
                                WsNotConnected ->
                                    connectWebSocket model.websocketUrl

                                WsReconnecting ->
                                    Cmd.none

                                WsConnecting ->
                                    Cmd.none

                                WsConnected _ ->
                                    Cmd.none

                        wsState =
                            when model.websocketConnection is
                                WsNotConnected ->
                                    WsConnecting

                                other ->
                                    other
                    in
                    if not wasOpened && model.page == WorkspacesPage then
                        -- First workspace selection: navigate to Board
                        { model = { newModel | page = BoardPage, websocketConnection = wsState }
                        , command =
                            Cmd.batch
                                [ loadPageData BoardPage
                                , wsCmd
                                , Api.getWorkspaces GotWorkspaces
                                ]
                        }
                    else
                        { model = { newModel | websocketConnection = wsState }
                        , command =
                            Cmd.batch
                                [ wsCmd
                                , Api.getWorkspaces GotWorkspaces
                                ]
                        }

                Err err ->
                    let
                        errorMessage =
                            httpErrorToString err
                    in
                    { model =
                        { model
                            | loading = False
                            , workspaceStatus = WorkspaceError errorMessage
                        }
                    , command = Cmd.none
                    }

        UpdateOpenPath path ->
            { model = { model | openPath = path }
            , command = Cmd.none
            }

        UpdateCreateName name ->
            let
                validationError =
                    if String.contains "/" name then
                        Just "Name cannot contain '/'"
                    else if String.contains "\\" name then
                        Just "Name cannot contain '\\'"
                    else if String.contains ".." name then
                        Just "Name cannot contain '..'"
                    else
                        Nothing

                newPath =
                    if validationError /= Nothing then
                        model.createPath
                    else if model.createPathManuallyEdited then
                        model.createPath
                    else if String.isEmpty name then
                        ""
                    else if String.isEmpty model.defaultWorkspacePath then
                        model.createPath
                    else
                        model.defaultWorkspacePath ++ "/" ++ name

                resetManualEdit =
                    if String.isEmpty name then
                        False
                    else
                        model.createPathManuallyEdited
            in
            { model =
                { model
                    | createName = name
                    , createPath = newPath
                    , createPathManuallyEdited = resetManualEdit
                    , nameValidationError = validationError
                }
            , command = Cmd.none
            }

        UpdateCreatePath path ->
            { model =
                { model
                    | createPath = path
                    , createPathManuallyEdited = True
                }
            , command = Cmd.none
            }

        SelectConfig ->
            if String.isEmpty (String.trim model.openPath) then
                { model = addErrorNotification "Please enter a path to a chorus.json file" model
                , command = Cmd.none
                }
            else
                { model = { model | loading = True }
                , command = Api.selectConfig (String.trim model.openPath) GotConfig
                }

        CreateConfig ->
            if String.isEmpty (String.trim model.createPath) then
                { model = addErrorNotification "Please enter a directory path" model
                , command = Cmd.none
                }
            else
                { model = { model | loading = True }
                , command = Api.createConfig (String.trim model.createPath) GotConfig
                }

        -- Workspace history

        GotWorkspaces result ->
            when result is
                Ok entries ->
                    { model = { model | recentWorkspaces = entries }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification ("Failed to load recent workspaces: " ++ httpErrorToString err) model
                    , command = Cmd.none
                    }

        OpenRecentWorkspace path ->
            { model = { model | loading = True }
            , command = Api.selectConfig path GotConfig
            }

        RemoveRecentWorkspace path ->
            { model = model
            , command = Api.removeWorkspace path (\result -> WorkspaceRemoved { path = path, result = result })
            }

        WorkspaceRemoved { path, result } ->
            when result is
                Ok _ ->
                    { model =
                        { model
                            | recentWorkspaces =
                                model.recentWorkspaces
                                    |> Array.keepIf (\e -> e.configPath /= path)
                        }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification ("Failed to remove workspace: " ++ httpErrorToString err) model
                    , command = Cmd.none
                    }

        -- System settings

        UpdateSettingsAllowedDir { index, value } ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map
                            (\f ->
                                { f
                                    | allowedAgentDirectories =
                                        Array.set index value f.allowedAgentDirectories
                                }
                            )
                            model.settingsForm
                }
            , command = Cmd.none
            }

        AddSettingsAllowedDir ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map
                            (\f ->
                                { f
                                    | allowedAgentDirectories =
                                        Array.pushLast "" f.allowedAgentDirectories
                                }
                            )
                            model.settingsForm
                }
            , command = Cmd.none
            }

        RemoveSettingsAllowedDir index ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map
                            (\f ->
                                { f
                                    | allowedAgentDirectories =
                                        f.allowedAgentDirectories
                                            |> Array.indexedMap (\i item -> { index = i, item = item })
                                            |> Array.keepIf (\entry -> entry.index /= index)
                                            |> Array.map .item
                                }
                            )
                            model.settingsForm
                }
            , command = Cmd.none
            }

        UpdateSettingsInitialAgentDirectory val ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map (\f -> { f | initialAgentDirectory = val }) model.settingsForm
                }
            , command = Cmd.none
            }

        UpdateSettingsSystemAgentProvider val ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map (\f -> { f | systemAgentProvider = val }) model.settingsForm
                }
            , command = Cmd.none
            }

        UpdateSettingsServerPort val ->
            { model =
                { model
                    | settingsForm =
                        Maybe.map (\f -> { f | serverPort = val }) model.settingsForm
                }
            , command = Cmd.none
            }

        SaveSettings ->
            when model.settingsForm is
                Just form ->
                    let
                        initialDirInAllowed =
                            String.isEmpty form.initialAgentDirectory
                                || Array.any (\d -> d == form.initialAgentDirectory) form.allowedAgentDirectories
                    in
                    if not initialDirInAllowed then
                        { model =
                            { model
                                | settingsValidationError =
                                    Just "Initial agent directory must be one of the allowed agent directories."
                            }
                        , command = Cmd.none
                        }
                    else
                        let
                            provider =
                                if String.isEmpty (String.trim form.systemAgentProvider) then
                                    NotConfigured
                                else
                                    ProviderRef (String.trim form.systemAgentProvider)

                            portValue =
                                if String.isEmpty (String.trim form.serverPort) then
                                    Ok Nothing
                                else
                                    when String.toInt (String.trim form.serverPort) is
                                        Just p ->
                                            if p >= 1 && p <= 65535 then
                                                Ok (Just p)
                                            else
                                                Err "Port must be between 1 and 65535."

                                        Nothing ->
                                            Err "Port must be a valid integer."
                        in
                        when portValue is
                            Err portErr ->
                                { model =
                                    { model
                                        | settingsValidationError = Just portErr
                                    }
                                , command = Cmd.none
                                }

                            Ok parsedPort ->
                                let
                                    wc =
                                        { allowedAgentDirectories = form.allowedAgentDirectories
                                        , initialAgentDirectory = form.initialAgentDirectory
                                        , systemAgentProvider = provider
                                        , serverPort = parsedPort
                                        }
                                in
                                { model = { model | loading = True, settingsValidationError = Nothing }
                                , command = Api.updateConfig wc SettingsSaved
                                }

                Nothing ->
                    { model = model
                    , command = Cmd.none
                    }

        SettingsSaved result ->
            when result is
                Ok configResponse ->
                    let
                        wc =
                            configResponse.config
                    in
                    { model =
                        addSuccessNotification "Settings saved"
                            { model
                                | workspaceStatus = WorkspaceOpened { config = wc, configPath = configResponse.configPath }
                                , settingsForm = Just (SystemSettings.workspaceConfigToForm wc)
                                , loading = False
                                , settingsValidationError = Nothing
                            }
                    , command = Cmd.none
                    }

                Err err ->
                    { model = addErrorNotification (httpErrorToString err) { model | loading = False }
                    , command = Cmd.none
                    }

        -- WebSocket handlers
        GotWsConnection result ->
            when result is
                Ok connection ->
                    { model = { model | websocketConnection = WsConnected connection }
                    , command = Cmd.none
                    }

                Err (WebSocket.ConnectError { message }) ->
                    -- Connection failed; schedule a reconnect
                    { model = { model | websocketConnection = WsReconnecting }
                    , command = scheduleReconnect
                    }

        GotWsMessage { message } ->
            when message is
                WebSocket.TextMessage text ->
                    handleWebSocketMessage text model

                WebSocket.BinaryMessage _ ->
                    -- Ignore binary messages
                    { model = model
                    , command = Cmd.none
                    }

        GotWsClosed _ ->
            -- Connection closed; schedule a reconnect
            { model = { model | websocketConnection = WsReconnecting }
            , command = scheduleReconnect
            }

        GotWsError _ ->
            -- Connection error; schedule a reconnect
            { model = { model | websocketConnection = WsReconnecting }
            , command = scheduleReconnect
            }

        WsReconnect ->
            -- Attempt to reconnect
            { model = { model | websocketConnection = WsConnecting }
            , command = connectWebSocket model.websocketUrl
            }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Schedule a WebSocket reconnection after a 3 second delay.
-}
scheduleReconnect : Cmd Msg
scheduleReconnect =
    Process.sleep 3000
        |> Task.perform (\_ -> WsReconnect)


{-| Connect to the WebSocket server using the URL stored in the model.
-}
connectWebSocket : String -> Cmd Msg
connectWebSocket wsUrl =
    WebSocket.connect wsUrl GotWsConnection


{-| Handle an incoming WebSocket text message.

Messages are JSON objects with "type" and "data" fields.
Based on the type, the UI re-fetches the relevant data.
-}
handleWebSocketMessage : String -> Model -> { model : Model, command : Cmd Msg }
handleWebSocketMessage text model =
    let
        messageType =
            Json.Decode.decodeString (Json.Decode.field "type" Json.Decode.string) text
    in
    when messageType is
        Ok "tasks_changed" ->
            { model = model
            , command = refreshCurrentPageData model
            }

        Ok "agents_changed" ->
            { model = model
            , command =
                when model.page is
                    AgentsPage ->
                        Cmd.batch
                            [ Api.getAgents GotAgents
                            , Api.getProviders GotProviders
                            ]

                    _ ->
                        Cmd.none
            }

        Ok "providers_changed" ->
            { model = model
            , command =
                when model.page is
                    ProvidersPage ->
                        Api.getProviders GotProviders

                    AgentsPage ->
                        Api.getProviders GotProviders

                    SystemSettingsPage ->
                        Api.getProviders GotProviders

                    _ ->
                        Cmd.none
            }

        Ok "config_changed" ->
            { model = model
            , command = Api.getConfig GotConfig
            }

        _ ->
            -- Unknown message type; ignore
            { model = model
            , command = Cmd.none
            }


{-| Re-fetch data for the current page after a tasks_changed notification.

Only refreshes task-related pages (BoardPage, TaskDetailPage). Other entity
types (agents, providers, config) have their own WebSocket message types and
are handled by their respective message handlers.
-}
refreshCurrentPageData : Model -> Cmd Msg
refreshCurrentPageData model =
    when model.page is
        BoardPage ->
            Api.getTasks Nothing GotTasks

        TaskDetailPage taskId ->
            Cmd.batch
                [ Api.getTask taskId GotTask
                , Api.getTaskHistory taskId GotHistory
                , Api.getTaskQueue taskId GotQueue
                ]

        _ ->
            Cmd.none



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        -- Low-frequency timer for notification expiry and time display
        timeSub =
            Time.every 10000 Tick

        -- WebSocket event subscriptions (only when connected)
        wsSubs =
            when model.websocketConnection is
                WsConnected connection ->
                    Sub.batch
                        [ WebSocket.onMessage connection (\conn msg -> GotWsMessage { connection = conn, message = msg })
                        , WebSocket.onClose connection (\conn reason -> GotWsClosed { connection = conn, reason = reason })
                        , WebSocket.onError connection (\conn err -> GotWsError { connection = conn, error = err })
                        ]

                _ ->
                    Sub.none
    in
    Sub.batch
        [ timeSub
        , wsSubs
        ]



-- VIEW


view : Model -> Browser.Document Msg
view model =
    { title = "Chorus - Task Registry"
    , body =
        [ div [ class "app" ]
            [ viewHeader model
            , Notification.viewNotifications model.notifications DismissNotification
            , viewMain model
            ]
        ]
    }


viewHeader : Model -> Html Msg
viewHeader model =
    let
        configLoaded =
            WorkspaceStatus.isOpened model.workspaceStatus

        navLink url label isActive isEnabled =
            if isEnabled then
                a
                    [ href url
                    , classList [ { class = "active", enabled = isActive } ]
                    ]
                    [ text label ]
            else
                span
                    [ class "nav-disabled"
                    ]
                    [ text label ]
    in
    header [ class "header" ]
        [ div [ class "header-content" ]
            [ h1 [] [ text "Chorus" ]
            , nav [ class "nav" ]
                [ navLink "/workspaces" "Workspaces" (model.page == WorkspacesPage) True
                , navLink "/" "Board" (model.page == BoardPage) configLoaded
                , navLink "/agents" "Agents" (model.page == AgentsPage) configLoaded
                , navLink "/providers" "Providers" (model.page == ProvidersPage) configLoaded
                , navLink "/settings" "Settings" (model.page == SystemSettingsPage) configLoaded
                ]
            , if configLoaded then
                button [ class "btn btn-primary", onClick OpenCreateForm ]
                    [ text "+ New Task" ]
              else
                text ""
            ]
        ]


viewMain : Model -> Html Msg
viewMain model =
    main_ [ class "main" ]
        [ when model.page is
            BoardPage ->
                div []
                    [ Board.view
                        { tasks = model.tasks
                        , loading = model.loading
                        , zone = model.timeZone
                        , now = model.currentTime
                        }
                    , viewCreateModal model
                    ]

            TaskDetailPage taskId ->
                let
                    externalAgents =
                        model.agents
                            |> Array.keepIf (\a -> not (Types.isInternalAgent a))

                    providerConfigured =
                        when model.workspaceStatus is
                            WorkspaceOpened { config } ->
                                when config.systemAgentProvider is
                                    ProviderRef _ ->
                                        True

                                    NotConfigured ->
                                        False

                            _ ->
                                False
                in
                TaskDetail.view
                    { task = model.selectedTask
                    , history = model.taskHistory
                    , queue = model.taskQueue
                    , loading = model.loading
                    , onStatusUpdate = \statusTaskId status -> UpdateTaskStatus { taskId = statusTaskId, status = status }
                    , onPlanTask = PlanTask
                    , onStartTask = StartTask
                    , onSelectStartAgent = SelectStartAgent
                    , agents = Array.map Types.agentConfigName externalAgents
                    , selectedStartAgent = model.startingAgent
                    , onRefresh = RefreshTask taskId
                    , onFileSelected = FileSelected
                    , onDeleteAttachment = \filename -> DeleteAttachment { taskId = taskId, filename = filename }
                    , editingPlanning = model.editingPlanning
                    , onEditPlanningSection = EditPlanningSection
                    , onUpdatePlanningDraft = UpdatePlanningDraft
                    , onUpdatePlanningItemDraft = \args -> UpdatePlanningItemDraft args
                    , onAddPlanningItem = AddPlanningItem
                    , onRemovePlanningItem = RemovePlanningItem
                    , onSavePlanning = SavePlanning
                    , onCancelPlanningEdit = CancelPlanningEdit
                    , draftAnswers = model.draftAnswers
                    , onUpdateAnswer = \args -> UpdateAnswer args
                    , onSubmitAnswers = SubmitAnswers
                    , expandedEvents = model.expandedEvents
                    , onToggleEventExpanded = ToggleEventExpanded
                    , zone = model.timeZone
                    , now = model.currentTime
                    , systemAgentProviderConfigured = providerConfigured
                    }

            AgentsPage ->
                Agents.view
                    { agents = Array.keepIf (\a -> not (Types.isInternalAgent a)) model.agents
                    , providers = model.providers
                    , loading = model.loading
                    , agentForm = model.agentForm
                    , onOpenCreateForm = OpenAgentCreateForm
                    , onOpenEditForm = OpenAgentEditForm
                    , onCloseForm = CloseAgentForm
                    , onUpdateName = UpdateAgentName
                    , onUpdateInstructions = UpdateAgentInstructions
                    , onUpdateAllowedTools = UpdateAgentAllowedTools
                    , onUpdateProvider = UpdateAgentProvider
                    , onUpdateModel = UpdateAgentModel
                    , onSaveAgent = SaveAgent
                    , onDeleteAgent = DeleteAgent
                    , onNoOp = NoOp
                    , bulkProviderMode = model.bulkProviderMode
                    , selectedAgents = model.selectedAgents
                    , bulkProvider = model.bulkProvider
                    , bulkModel = model.bulkModel
                    , onToggleBulkProviderMode = ToggleBulkProviderMode
                    , onToggleAgentSelected = ToggleAgentSelected
                    , onUpdateBulkProvider = UpdateBulkProvider
                    , onUpdateBulkModel = UpdateBulkModel
                    , onApplyBulkProvider = ApplyBulkProvider
                    }

            ProvidersPage ->
                div []
                    [ Providers.view
                        { providers = model.providers
                        , loading = model.loading
                        , providerForm = model.providerForm
                        , onOpenCreateForm = OpenProviderCreateForm
                        , onOpenEditForm = OpenProviderEditForm
                        , onCloseForm = CloseProviderForm
                        , onUpdateName = UpdateProviderName
                        , onUpdateProviderType = UpdateProviderType
                        , onUpdatePreset = UpdateProviderPreset
                        , onUpdateApiBaseUrl = UpdateProviderApiBaseUrl
                        , onUpdateApiKey = UpdateProviderApiKey
                        , onUpdateDefaultModel = UpdateProviderDefaultModel
                        , onSaveProvider = SaveProvider
                        , onDeleteProvider = DeleteProvider
                        , onConfirmDeleteProvider = ConfirmDeleteProvider
                        , onNoOp = NoOp
                        }
                    , viewDeleteProviderConfirmation model
                    ]

            WorkspacesPage ->
                Workspaces.view
                    { workspaceStatus = model.workspaceStatus
                    , recentWorkspaces = model.recentWorkspaces
                    , openPath = model.openPath
                    , createName = model.createName
                    , createPath = model.createPath
                    , defaultWorkspacePath = model.defaultWorkspacePath
                    , createPathManuallyEdited = model.createPathManuallyEdited
                    , nameValidationError = model.nameValidationError
                    , loading = model.loading
                    , onUpdateOpenPath = UpdateOpenPath
                    , onUpdateCreateName = UpdateCreateName
                    , onUpdateCreatePath = UpdateCreatePath
                    , onSelectConfig = SelectConfig
                    , onCreateConfig = CreateConfig
                    , onOpenRecentWorkspace = OpenRecentWorkspace
                    , onRemoveRecentWorkspace = RemoveRecentWorkspace
                    }

            SystemSettingsPage ->
                SystemSettings.view
                    { settingsForm = model.settingsForm
                    , providers = model.providers
                    , loading = model.loading
                    , validationError = model.settingsValidationError
                    , onUpdateAllowedDir = UpdateSettingsAllowedDir
                    , onAddAllowedDir = AddSettingsAllowedDir
                    , onRemoveAllowedDir = RemoveSettingsAllowedDir
                    , onUpdateInitialAgentDirectory = UpdateSettingsInitialAgentDirectory
                    , onUpdateSystemAgentProvider = UpdateSettingsSystemAgentProvider
                    , onUpdateServerPort = UpdateSettingsServerPort
                    , onSaveSettings = SaveSettings
                    }

            NotFoundPage ->
                div [ class "not-found" ]
                    [ h2 [] [ text "Page Not Found" ]
                    , p [] [ text "The page you requested does not exist." ]
                    , a [ href "/" ] [ text "Go to Board" ]
                    ]
        ]


viewCreateModal : Model -> Html Msg
viewCreateModal model =
    if model.createForm.isOpen then
        div [ class "modal-overlay", onClick CloseCreateForm ]
            [ div
                [ class "modal"
                , Html.Events.stopPropagationOn "click" (Json.Decode.succeed { message = NoOp, stopPropagation = True })
                ]
                [ h2 [] [ text "Create New Task" ]
                , Html.form [ onSubmit SubmitCreateForm ]
                    [ div [ class "form-group" ]
                        [ label [ for "description" ] [ text "Description" ]
                        , textarea
                            [ id "description"
                            , value model.createForm.description
                            , onInput UpdateCreateDescription
                            , placeholder "Enter task description..."
                            , Html.Attributes.rows 4
                            , autofocus True
                            ]
                            []
                        ]
                    , div [ class "form-actions" ]
                        [ button
                            [ type_ "button"
                            , class "btn btn-secondary"
                            , onClick CloseCreateForm
                            ]
                            [ text "Cancel" ]
                        , button
                            [ type_ "submit"
                            , class "btn btn-primary"
                            ]
                            [ text "Create" ]
                        ]
                    ]
                ]
            ]
    else
        text ""



viewDeleteProviderConfirmation : Model -> Html Msg
viewDeleteProviderConfirmation model =
    when model.confirmingDeleteProvider is
        Nothing ->
            text ""

        Just providerName ->
            let
                affectedAgents =
                    model.agents
                        |> Array.keepIf
                            (\agent ->
                                when agent is
                                    UserDefinedAgent r ->
                                        r.provider == ProviderRef providerName

                                    InternalAgent _ ->
                                        False
                            )
                        |> Array.map Types.agentConfigName
            in
            div [ class "modal-overlay", onClick (ConfirmDeleteProvider "") ]
                [ div
                    [ class "modal"
                    , Html.Events.stopPropagationOn "click"
                        (Json.Decode.succeed { message = NoOp, stopPropagation = True })
                    ]
                    [ h2 [] [ text "Delete Provider" ]
                    , p [] [ text ("Are you sure you want to delete the provider \"" ++ providerName ++ "\"?") ]
                    , if Array.isEmpty affectedAgents then
                        text ""
                      else
                        div [ class "warning-box" ]
                            [ p [] [ text "The following agents use this provider and will be set to \"Not Configured\":" ]
                            , ul []
                                (Array.map (\name -> li [] [ text name ]) affectedAgents)
                            ]
                    , div [ class "form-actions" ]
                        [ button
                            [ class "btn btn-secondary"
                            , onClick (ConfirmDeleteProvider "")
                            ]
                            [ text "Cancel" ]
                        , button
                            [ class "btn btn-danger"
                            , onClick (DeleteProvider providerName)
                            ]
                            [ text "Delete" ]
                        ]
                    ]
                ]


-- HELPERS


addErrorNotification : String -> Model -> Model
addErrorNotification errorMessage model =
    { model
        | notifications =
            Array.pushLast
                (Notification.error model.nextNotificationId errorMessage)
                model.notifications
        , nextNotificationId = model.nextNotificationId + 1
    }


addSuccessNotification : String -> Model -> Model
addSuccessNotification successMessage model =
    { model
        | notifications =
            Array.pushLast
                (Notification.success model.nextNotificationId model.currentTime successMessage)
                model.notifications
        , nextNotificationId = model.nextNotificationId + 1
    }


{-| Build a prompt for an agent from the task's planning fields.
-}
buildAgentPrompt : Types.Task -> String
buildAgentPrompt task =
    when task is
        DescriptionOnly t ->
            t.description

        Planned t ->
            let
                sections =
                    Array.keepIf (\s -> not (String.isEmpty s))
                        [ "## Task\n" ++ t.description
                        , if String.isEmpty t.summary then
                            ""
                          else
                            "## Summary\n" ++ t.summary
                        , if Array.isEmpty t.requirements then
                            ""
                          else
                            "## Requirements\n" ++ String.join "\n" (Array.map (\r -> "- " ++ r) t.requirements)
                        , if Array.isEmpty t.acceptanceCriteria then
                            ""
                          else
                            "## Acceptance Criteria\n" ++ String.join "\n" (Array.map (\a -> "- " ++ a) t.acceptanceCriteria)
                        , if Array.isEmpty t.plan then
                            ""
                          else
                            "## Plan\n" ++ String.join "\n" (Array.indexedMap (\i step -> String.fromInt (i + 1) ++ ". " ++ step) t.plan)
                        ]
            in
            String.join "\n\n" sections


{-| Does this page require a workspace config to be loaded?
-}
requiresConfig : Page -> Bool
requiresConfig page =
    when page is
        WorkspacesPage ->
            False

        NotFoundPage ->
            False

        _ ->
            True


{-| Does navigating to this page trigger a data-loading command?
Used to set the loading flag correctly on page transitions.
-}
pageLoadsData : Page -> Bool
pageLoadsData page =
    when page is
        WorkspacesPage ->
            False

        NotFoundPage ->
            False

        _ ->
            True


httpErrorToString : Http.Error -> String
httpErrorToString error =
    when error is
        Http.BadUrl url ->
            "Invalid URL: " ++ url

        Http.Timeout ->
            "Request timed out"

        Http.NetworkError ->
            "Network error - check your connection"

        Http.BadStatus status ->
            "Server error: " ++ String.fromInt status

        Http.BadBody message ->
            if String.startsWith "Invalid response: " message then
                message
            else
                "Server error: " ++ message
