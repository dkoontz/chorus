module Types exposing
    ( Task(..)
    , DescriptionOnlyTask
    , PlannedTask
    , PlanningFields
    , PlanningQuestion
    , HandoffRecord
    , CompletionReport
    , CompletionStatus(..)
    , TaskStatus(..)
    , SourceInfo
    , Attachment
    , Event
    , History
    , QueuedMessage
    , Queue
    , AgentConfig
    -- Encoders
    , encodeTask
    , encodeStatus
    , encodeSourceInfo
    , encodeAttachment
    , encodeEvent
    , encodeHistory
    , encodeQueue
    , encodeMessage
    , encodeMaybe
    , encodeHandoffRecord
    , encodeCompletionReport
    , encodeAgentConfig
    , encodePlanningQuestion
    -- Decoders
    , taskDecoder
    , statusDecoder
    , sourceInfoDecoder
    , attachmentDecoder
    , eventDecoder
    , historyDecoder
    , queueDecoder
    , messageDecoder
    , handoffRecordDecoder
    , completionReportDecoder
    , agentConfigDecoder
    , planningQuestionDecoder
    -- Accessors
    , taskId
    , taskDescription
    , taskStatus
    , taskCreatedAt
    , taskUpdatedAt
    , taskSessionId
    , taskSource
    , taskAttachments
    , taskCurrentAgent
    , taskAgentChain
    , taskQuestions
    , taskAssignedAgent
    , isPlanned
    -- Mutators
    , planTask
    , setTaskStatus
    , setAttachments
    , setCurrentAgent
    , setAgentChain
    -- Helpers
    , statusToString
    , statusFromString
    , statusEquals
    , completionStatusToString
    )

{-| Shared types, encoders, and decoders for the Chorus API contract.

This module is the single source of truth for all types that cross the
boundary between backend and frontend. Both applications reference it
via the `source-directories` field in their `gren.json`.

Only depends on `gren-lang/core` so it compiles for both node and browser.

-}

import Dict exposing (Dict)
import Id exposing (TaskId, SessionId, MessageId)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Time



-- TYPES


{-| A task in the registry. Either description-only or fully planned.
-}
type Task
    = DescriptionOnly DescriptionOnlyTask
    | Planned PlannedTask


{-| A record of an agent hand-off on a task.
-}
type alias HandoffRecord =
    { agentName : String
    , startedAt : Time.Posix
    , completedAt : Maybe Time.Posix
    , input : String
    , output : String
    , completionReport : Maybe CompletionReport
    }


{-| Status of a completion report submitted by an agent.
-}
type CompletionStatus
    = ReportComplete
    | ReportBlocked
    | ReportFailed


{-| Structured output submitted by an agent via the completion-report tool.
-}
type alias CompletionReport =
    { status : CompletionStatus
    , summary : String
    , output : String
    , blockedReason : Maybe String
    }


{-| A task that has only a description and no planning data.
-}
type alias DescriptionOnlyTask =
    { id : TaskId
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe SessionId
    , source : SourceInfo
    , attachments : Array Attachment
    , currentAgent : Maybe String
    , agentChain : Array HandoffRecord
    }


{-| A question asked by the planning agent, with an optional user answer.
-}
type alias PlanningQuestion =
    { question : String
    , answer : Maybe String
    }


{-| A task that has been planned with summary, requirements, criteria, and steps.
-}
type alias PlannedTask =
    { id : TaskId
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe SessionId
    , source : SourceInfo
    , attachments : Array Attachment
    , currentAgent : Maybe String
    , agentChain : Array HandoffRecord
    , summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    , questions : Array PlanningQuestion
    , assignedAgent : Maybe String
    }


{-| Planning fields used when converting a DescriptionOnly task to Planned.
-}
type alias PlanningFields =
    { summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    , questions : Array PlanningQuestion
    , assignedAgent : Maybe String
    }


{-| Metadata for a file attached to a task.
-}
type alias Attachment =
    { filename : String
    , size : Int
    , contentType : String
    , uploadedAt : Time.Posix
    }


{-| Task lifecycle status.
-}
type TaskStatus
    = Pending        -- created but session not started
    | Planning       -- being analyzed by planning agent
    | AwaitingInput  -- planning agent returned questions for user
    | ReadyToStart   -- plan complete, ready to start
    | Active         -- session is currently processing
    | Waiting        -- session idle, ready for more input
    | Completed      -- finished successfully
    | Failed String  -- finished with error message


{-| Information about where the task originated.
-}
type alias SourceInfo =
    { sourceType : String
    , userId : String
    , conversationId : Maybe String
    }


{-| Event recorded in task history.
-}
type alias Event =
    { timestamp : Time.Posix
    , eventType : String
    , data : Dict String String
    }


{-| Task event history.
-}
type alias History =
    { events : Array Event
    }


{-| A message waiting to be processed.
-}
type alias QueuedMessage =
    { id : MessageId
    , content : String
    , receivedAt : Time.Posix
    }


{-| Task message queue.
-}
type alias Queue =
    { messages : Array QueuedMessage
    }


{-| An agent configuration.
-}
type alias AgentConfig =
    { name : String
    , instructions : String
    , allowedTools : Array String
    , provider : String
    , model : Maybe String
    }



-- TASK ACCESSORS


{-| Get the ID of a task.
-}
taskId : Task -> TaskId
taskId task =
    when task is
        DescriptionOnly t ->
            t.id

        Planned t ->
            t.id


{-| Get the description of a task.
-}
taskDescription : Task -> String
taskDescription task =
    when task is
        DescriptionOnly t ->
            t.description

        Planned t ->
            t.description


{-| Get the status of a task.
-}
taskStatus : Task -> TaskStatus
taskStatus task =
    when task is
        DescriptionOnly t ->
            t.status

        Planned t ->
            t.status


{-| Get the creation time of a task.
-}
taskCreatedAt : Task -> Time.Posix
taskCreatedAt task =
    when task is
        DescriptionOnly t ->
            t.createdAt

        Planned t ->
            t.createdAt


{-| Get the last update time of a task.
-}
taskUpdatedAt : Task -> Time.Posix
taskUpdatedAt task =
    when task is
        DescriptionOnly t ->
            t.updatedAt

        Planned t ->
            t.updatedAt


{-| Get the session ID of a task.
-}
taskSessionId : Task -> Maybe SessionId
taskSessionId task =
    when task is
        DescriptionOnly t ->
            t.sessionId

        Planned t ->
            t.sessionId


{-| Get the source info of a task.
-}
taskSource : Task -> SourceInfo
taskSource task =
    when task is
        DescriptionOnly t ->
            t.source

        Planned t ->
            t.source


{-| Get the attachments of a task.
-}
taskAttachments : Task -> Array Attachment
taskAttachments task =
    when task is
        DescriptionOnly t ->
            t.attachments

        Planned t ->
            t.attachments


{-| Get the current agent assigned to a task.
-}
taskCurrentAgent : Task -> Maybe String
taskCurrentAgent task =
    when task is
        DescriptionOnly t ->
            t.currentAgent

        Planned t ->
            t.currentAgent


{-| Get the agent chain (hand-off history) of a task.
-}
taskAgentChain : Task -> Array HandoffRecord
taskAgentChain task =
    when task is
        DescriptionOnly t ->
            t.agentChain

        Planned t ->
            t.agentChain


{-| Check if a task has been planned.
-}
isPlanned : Task -> Bool
isPlanned task =
    when task is
        DescriptionOnly _ ->
            False

        Planned _ ->
            True


{-| Get the planning questions for a task.
-}
taskQuestions : Task -> Array PlanningQuestion
taskQuestions task =
    when task is
        DescriptionOnly _ ->
            []

        Planned t ->
            t.questions


{-| Get the assigned agent for a task.
-}
taskAssignedAgent : Task -> Maybe String
taskAssignedAgent task =
    when task is
        DescriptionOnly _ ->
            Nothing

        Planned t ->
            t.assignedAgent



-- TASK MUTATORS


{-| Convert a task to Planned by adding planning fields.
    If the task is already Planned, the existing planning fields are replaced.
-}
planTask : Task -> PlanningFields -> Task
planTask task fields =
    when task is
        DescriptionOnly t ->
            Planned
                { id = t.id
                , description = t.description
                , status = t.status
                , createdAt = t.createdAt
                , updatedAt = t.updatedAt
                , sessionId = t.sessionId
                , source = t.source
                , attachments = t.attachments
                , currentAgent = t.currentAgent
                , agentChain = t.agentChain
                , summary = fields.summary
                , requirements = fields.requirements
                , acceptanceCriteria = fields.acceptanceCriteria
                , plan = fields.plan
                , questions = fields.questions
                , assignedAgent = fields.assignedAgent
                }

        Planned t ->
            Planned
                { t
                    | summary = fields.summary
                    , requirements = fields.requirements
                    , acceptanceCriteria = fields.acceptanceCriteria
                    , plan = fields.plan
                    , questions = fields.questions
                    , assignedAgent = fields.assignedAgent
                }


{-| Set the status on a task.
-}
setTaskStatus : TaskStatus -> Task -> Task
setTaskStatus newStatus task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | status = newStatus }

        Planned t ->
            Planned { t | status = newStatus }


{-| Set the attachments on a task.
-}
setAttachments : Array Attachment -> Task -> Task
setAttachments attachments task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | attachments = attachments }

        Planned t ->
            Planned { t | attachments = attachments }


{-| Set the current agent on a task.
-}
setCurrentAgent : Maybe String -> Task -> Task
setCurrentAgent agent task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | currentAgent = agent }

        Planned t ->
            Planned { t | currentAgent = agent }


{-| Set the agent chain (hand-off history) on a task.
-}
setAgentChain : Array HandoffRecord -> Task -> Task
setAgentChain chain task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | agentChain = chain }

        Planned t ->
            Planned { t | agentChain = chain }



-- JSON ENCODING


{-| Encode a task to JSON. Includes a "taskType" discriminator field.

    The discriminator is named "taskType" rather than "type" because "type"
    is already used as the discriminator inside the nested status object
    (e.g. {"type": "active"}). Using "taskType" avoids ambiguity.
-}
encodeTask : Task -> Encode.Value
encodeTask task =
    when task is
        DescriptionOnly t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "descriptionOnly" }
                , { key = "id", value = Id.encodeTaskId t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Id.encodeSessionId t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                , { key = "currentAgent", value = encodeMaybe Encode.string t.currentAgent }
                , { key = "agentChain", value = Encode.array encodeHandoffRecord t.agentChain }
                ]

        Planned t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "planned" }
                , { key = "id", value = Id.encodeTaskId t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Id.encodeSessionId t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                , { key = "currentAgent", value = encodeMaybe Encode.string t.currentAgent }
                , { key = "agentChain", value = Encode.array encodeHandoffRecord t.agentChain }
                , { key = "summary", value = Encode.string t.summary }
                , { key = "requirements", value = Encode.array Encode.string t.requirements }
                , { key = "acceptanceCriteria", value = Encode.array Encode.string t.acceptanceCriteria }
                , { key = "plan", value = Encode.array Encode.string t.plan }
                , { key = "questions", value = Encode.array encodePlanningQuestion t.questions }
                , { key = "assignedAgent", value = encodeMaybe Encode.string t.assignedAgent }
                ]


{-| Encode an attachment to JSON.
-}
encodeAttachment : Attachment -> Encode.Value
encodeAttachment attachment =
    Encode.object
        [ { key = "filename", value = Encode.string attachment.filename }
        , { key = "size", value = Encode.int attachment.size }
        , { key = "contentType", value = Encode.string attachment.contentType }
        , { key = "uploadedAt", value = Encode.int (Time.posixToMillis attachment.uploadedAt) }
        ]


{-| Encode a planning question to JSON.
-}
encodePlanningQuestion : PlanningQuestion -> Encode.Value
encodePlanningQuestion q =
    Encode.object
        [ { key = "question", value = Encode.string q.question }
        , { key = "answer", value = encodeMaybe Encode.string q.answer }
        ]


encodeHandoffRecord : HandoffRecord -> Encode.Value
encodeHandoffRecord record =
    Encode.object
        [ { key = "agentName", value = Encode.string record.agentName }
        , { key = "startedAt", value = Encode.int (Time.posixToMillis record.startedAt) }
        , { key = "completedAt", value = encodeMaybe (\t -> Encode.int (Time.posixToMillis t)) record.completedAt }
        , { key = "input", value = Encode.string record.input }
        , { key = "output", value = Encode.string record.output }
        , { key = "completionReport", value = encodeMaybe encodeCompletionReport record.completionReport }
        ]


{-| Encode a completion report to JSON.
-}
encodeCompletionReport : CompletionReport -> Encode.Value
encodeCompletionReport report =
    Encode.object
        [ { key = "status", value = Encode.string (completionStatusToString report.status) }
        , { key = "summary", value = Encode.string report.summary }
        , { key = "output", value = Encode.string report.output }
        , { key = "blockedReason", value = encodeMaybe Encode.string report.blockedReason }
        ]


{-| Convert a CompletionStatus to its string representation.
-}
completionStatusToString : CompletionStatus -> String
completionStatusToString status =
    when status is
        ReportComplete ->
            "complete"

        ReportBlocked ->
            "blocked"

        ReportFailed ->
            "failed"


encodeStatus : TaskStatus -> Encode.Value
encodeStatus status =
    when status is
        Pending ->
            Encode.object
                [ { key = "type", value = Encode.string "pending" }
                ]

        Planning ->
            Encode.object
                [ { key = "type", value = Encode.string "planning" }
                ]

        AwaitingInput ->
            Encode.object
                [ { key = "type", value = Encode.string "awaiting_input" }
                ]

        ReadyToStart ->
            Encode.object
                [ { key = "type", value = Encode.string "planned" }
                ]

        Active ->
            Encode.object
                [ { key = "type", value = Encode.string "active" }
                ]

        Waiting ->
            Encode.object
                [ { key = "type", value = Encode.string "waiting" }
                ]

        Completed ->
            Encode.object
                [ { key = "type", value = Encode.string "completed" }
                ]

        Failed message ->
            Encode.object
                [ { key = "type", value = Encode.string "failed" }
                , { key = "message", value = Encode.string message }
                ]


encodeSourceInfo : SourceInfo -> Encode.Value
encodeSourceInfo source =
    Encode.object
        [ { key = "sourceType", value = Encode.string source.sourceType }
        , { key = "userId", value = Encode.string source.userId }
        , { key = "conversationId", value = encodeMaybe Encode.string source.conversationId }
        ]


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder maybeValue =
    when maybeValue is
        Just value ->
            encoder value

        Nothing ->
            Encode.null


encodeEvent : Event -> Encode.Value
encodeEvent event =
    Encode.object
        [ { key = "timestamp", value = Encode.int (Time.posixToMillis event.timestamp) }
        , { key = "eventType", value = Encode.string event.eventType }
        , { key = "data", value = Encode.dict identity Encode.string event.data }
        ]


encodeHistory : History -> Encode.Value
encodeHistory history =
    Encode.object
        [ { key = "events", value = Encode.array encodeEvent history.events }
        ]


encodeQueue : Queue -> Encode.Value
encodeQueue queue =
    Encode.object
        [ { key = "messages"
          , value = Encode.array encodeMessage queue.messages
          }
        ]


encodeMessage : QueuedMessage -> Encode.Value
encodeMessage msg =
    Encode.object
        [ { key = "id", value = Id.encodeMessageId msg.id }
        , { key = "content", value = Encode.string msg.content }
        , { key = "receivedAt", value = Encode.int (Time.posixToMillis msg.receivedAt) }
        ]



-- JSON DECODING


{-| Decode a task from JSON. Requires the "taskType" discriminator field.
-}
taskDecoder : Decoder Task
taskDecoder =
    Decode.field "taskType" Decode.string
        |> Decode.andThen
            (\taskType ->
                when taskType is
                    "planned" ->
                        plannedTaskDecoder

                    _ ->
                        descriptionOnlyTaskDecoder
            )


descriptionOnlyTaskDecoder : Decoder Task
descriptionOnlyTaskDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = Nothing
            , source = { sourceType = "", userId = "", conversationId = Nothing }
            , attachments = []
            , currentAgent = Nothing
            , agentChain = []
            }
        )
        (Decode.field "id" Id.taskIdDecoder)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        |> Decode.andThen
            (\task ->
                Decode.field "sessionId" (Decode.maybe Id.sessionIdDecoder)
                    |> Decode.map (\sessionId -> { task | sessionId = sessionId })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "source" sourceInfoDecoder
                    |> Decode.map (\source -> { task | source = source })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "attachments" (Decode.array attachmentDecoder)
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "currentAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\currentAgent -> { task | currentAgent = currentAgent })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "agentChain" (Decode.array handoffRecordDecoder)
                    |> Decode.map (\agentChain -> DescriptionOnly { task | agentChain = agentChain })
            )


plannedTaskDecoder : Decoder Task
plannedTaskDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = Nothing
            , source = { sourceType = "", userId = "", conversationId = Nothing }
            , attachments = []
            , currentAgent = Nothing
            , agentChain = []
            , summary = ""
            , requirements = []
            , acceptanceCriteria = []
            , plan = []
            , questions = []
            , assignedAgent = Nothing
            }
        )
        (Decode.field "id" Id.taskIdDecoder)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        |> Decode.andThen
            (\task ->
                Decode.field "sessionId" (Decode.maybe Id.sessionIdDecoder)
                    |> Decode.map (\sessionId -> { task | sessionId = sessionId })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "source" sourceInfoDecoder
                    |> Decode.map (\source -> { task | source = source })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "attachments" (Decode.array attachmentDecoder)
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "currentAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\currentAgent -> { task | currentAgent = currentAgent })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "agentChain" (Decode.array handoffRecordDecoder)
                    |> Decode.map (\agentChain -> { task | agentChain = agentChain })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "summary" Decode.string
                    |> Decode.map (\summary -> { task | summary = summary })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "requirements" (Decode.array Decode.string)
                    |> Decode.map (\requirements -> { task | requirements = requirements })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "acceptanceCriteria" (Decode.array Decode.string)
                    |> Decode.map (\acceptanceCriteria -> { task | acceptanceCriteria = acceptanceCriteria })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "plan" (Decode.array Decode.string)
                    |> Decode.map (\plan -> { task | plan = plan })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "questions" (Decode.array planningQuestionDecoder)
                    |> Decode.map (\questions -> { task | questions = questions })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "assignedAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\assignedAgent -> Planned { task | assignedAgent = assignedAgent })
            )


{-| Decode a planning question from JSON.
-}
planningQuestionDecoder : Decoder PlanningQuestion
planningQuestionDecoder =
    Decode.map2
        (\question answer ->
            { question = question
            , answer = answer
            }
        )
        (Decode.field "question" Decode.string)
        (Decode.field "answer" (Decode.maybe Decode.string))


{-| Decode a hand-off record from JSON.
-}
handoffRecordDecoder : Decoder HandoffRecord
handoffRecordDecoder =
    Decode.map5
        (\agentName startedAt completedAt input output ->
            { agentName = agentName
            , startedAt = startedAt
            , completedAt = completedAt
            , input = input
            , output = output
            , completionReport = Nothing
            }
        )
        (Decode.field "agentName" Decode.string)
        (Decode.field "startedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "completedAt" (Decode.maybe (Decode.map Time.millisToPosix Decode.int)))
        (Decode.field "input" Decode.string)
        (Decode.field "output" Decode.string)
        |> Decode.andThen
            (\record ->
                Decode.field "completionReport" (Decode.maybe completionReportDecoder)
                    |> Decode.map (\completionReport -> { record | completionReport = completionReport })
            )


{-| Decode a completion report from JSON.
-}
completionReportDecoder : Decoder CompletionReport
completionReportDecoder =
    Decode.map4
        (\status summary output blockedReason ->
            { status = status
            , summary = summary
            , output = output
            , blockedReason = blockedReason
            }
        )
        (Decode.field "status" completionStatusDecoder)
        (Decode.field "summary" Decode.string)
        (Decode.field "output" Decode.string)
        (Decode.field "blockedReason" (Decode.maybe Decode.string))


completionStatusDecoder : Decoder CompletionStatus
completionStatusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when str is
                    "complete" ->
                        Decode.succeed ReportComplete

                    "blocked" ->
                        Decode.succeed ReportBlocked

                    "failed" ->
                        Decode.succeed ReportFailed

                    _ ->
                        Decode.fail ("Unknown completion status: " ++ str)
            )


attachmentDecoder : Decoder Attachment
attachmentDecoder =
    Decode.map4
        (\filename size contentType uploadedAt ->
            { filename = filename
            , size = size
            , contentType = contentType
            , uploadedAt = uploadedAt
            }
        )
        (Decode.field "filename" Decode.string)
        (Decode.field "size" Decode.int)
        (Decode.field "contentType" Decode.string)
        (Decode.field "uploadedAt" (Decode.map Time.millisToPosix Decode.int))


statusDecoder : Decoder TaskStatus
statusDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\statusType ->
                when statusType is
                    "pending" ->
                        Decode.succeed Pending

                    "planning" ->
                        Decode.succeed Planning

                    "awaiting_input" ->
                        Decode.succeed AwaitingInput

                    "planned" ->
                        Decode.succeed ReadyToStart

                    "active" ->
                        Decode.succeed Active

                    "waiting" ->
                        Decode.succeed Waiting

                    "completed" ->
                        Decode.succeed Completed

                    "failed" ->
                        Decode.field "message" Decode.string
                            |> Decode.map Failed

                    _ ->
                        Decode.fail ("Unknown status type: " ++ statusType)
            )


sourceInfoDecoder : Decoder SourceInfo
sourceInfoDecoder =
    Decode.map3
        (\sourceType userId conversationId ->
            { sourceType = sourceType
            , userId = userId
            , conversationId = conversationId
            }
        )
        (Decode.field "sourceType" Decode.string)
        (Decode.field "userId" Decode.string)
        (Decode.field "conversationId" (Decode.maybe Decode.string))


eventDecoder : Decoder Event
eventDecoder =
    Decode.map3
        (\timestamp eventType data ->
            { timestamp = timestamp
            , eventType = eventType
            , data = data
            }
        )
        (Decode.field "timestamp" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "eventType" Decode.string)
        (Decode.field "data" (Decode.dict Decode.string))


historyDecoder : Decoder History
historyDecoder =
    Decode.map (\events -> { events = events })
        (Decode.field "events" (Decode.array eventDecoder))


queueDecoder : Decoder Queue
queueDecoder =
    Decode.map (\messages -> { messages = messages })
        (Decode.field "messages" (Decode.array messageDecoder))


messageDecoder : Decoder QueuedMessage
messageDecoder =
    Decode.map3
        (\id content receivedAt ->
            { id = id
            , content = content
            , receivedAt = receivedAt
            }
        )
        (Decode.field "id" Id.messageIdDecoder)
        (Decode.field "content" Decode.string)
        (Decode.field "receivedAt" (Decode.map Time.millisToPosix Decode.int))



-- AGENT CONFIG JSON


{-| Encode an agent config to JSON.
-}
encodeAgentConfig : AgentConfig -> Encode.Value
encodeAgentConfig config =
    let
        requiredFields =
            [ { key = "name", value = Encode.string config.name }
            , { key = "instructions", value = Encode.string config.instructions }
            , { key = "allowedTools", value = Encode.array Encode.string config.allowedTools }
            , { key = "provider", value = Encode.string config.provider }
            ]

        modelField =
            when config.model is
                Just m ->
                    [ { key = "model", value = Encode.string m } ]

                Nothing ->
                    []
    in
    Encode.object (Array.flatten [ requiredFields, modelField ])


agentConfigDecoder : Decoder AgentConfig
agentConfigDecoder =
    Decode.map5
        (\name instructions allowedTools provider model ->
            { name = name
            , instructions = instructions
            , allowedTools = allowedTools
            , provider = provider
            , model = model
            }
        )
        (Decode.field "name" Decode.string)
        (Decode.field "instructions" Decode.string)
        (Decode.field "allowedTools" (Decode.array Decode.string))
        (Decode.field "provider" Decode.string)
        (Decode.maybe (Decode.field "model" Decode.string))



-- HELPERS


{-| Convert status to display string.
-}
statusToString : TaskStatus -> String
statusToString status =
    when status is
        Pending ->
            "pending"

        Planning ->
            "planning"

        AwaitingInput ->
            "awaiting_input"

        ReadyToStart ->
            "planned"

        Active ->
            "active"

        Waiting ->
            "waiting"

        Completed ->
            "completed"

        Failed _ ->
            "failed"


{-| Parse status from string.
-}
statusFromString : String -> Maybe TaskStatus
statusFromString str =
    when str is
        "pending" ->
            Just Pending

        "planning" ->
            Just Planning

        "awaiting_input" ->
            Just AwaitingInput

        "planned" ->
            Just ReadyToStart

        "active" ->
            Just Active

        "waiting" ->
            Just Waiting

        "completed" ->
            Just Completed

        "failed" ->
            Just (Failed "")

        _ ->
            Nothing


{-| Check if two statuses are equal (for filtering).
-}
statusEquals : TaskStatus -> TaskStatus -> Bool
statusEquals a b =
    when { a = a, b = b } is
        { a = Pending, b = Pending } ->
            True

        { a = Planning, b = Planning } ->
            True

        { a = AwaitingInput, b = AwaitingInput } ->
            True

        { a = ReadyToStart, b = ReadyToStart } ->
            True

        { a = Active, b = Active } ->
            True

        { a = Waiting, b = Waiting } ->
            True

        { a = Completed, b = Completed } ->
            True

        { a = Failed _, b = Failed _ } ->
            True

        _ ->
            False
