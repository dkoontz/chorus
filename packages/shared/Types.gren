module Types exposing
    ( Task(..)
    , DescriptionOnlyTask
    , PlannedTask
    , PlanningFields
    , PlanningQuestion
    , HandoffRecord
    , CompletionReport
    , CompletionStatus(..)
    , TaskStatus(..)
    , EventType(..)
    , SourceType(..)
    , SourceInfo
    , Attachment
    , Event
    , History
    , QueuedMessage
    , Queue
    , AgentConfig(..)
    , ProviderType(..)
    , ProviderConfig
    , AgentProvider(..)
    , WorkspaceConfig
    -- Encoders
    , encodeTask
    , encodeStatus
    , encodeSourceInfo
    , encodeAttachment
    , encodeEvent
    , encodeHistory
    , encodeQueue
    , encodeMessage
    , encodeMaybe
    , encodeHandoffRecord
    , encodeCompletionReport
    , encodeAgentConfig
    , encodePlanningQuestion
    , encodeProviderType
    , encodeProviderConfig
    , encodeAgentProvider
    , encodeWorkspaceConfig
    -- Decoders
    , taskDecoder
    , statusDecoder
    , sourceInfoDecoder
    , attachmentDecoder
    , eventDecoder
    , historyDecoder
    , queueDecoder
    , messageDecoder
    , handoffRecordDecoder
    , completionReportDecoder
    , agentConfigDecoder
    , planningQuestionDecoder
    , providerTypeDecoder
    , providerConfigDecoder
    , agentProviderDecoder
    , workspaceConfigDecoder
    -- Accessors
    , taskId
    , taskDescription
    , taskStatus
    , taskCreatedAt
    , taskUpdatedAt
    , taskSessionId
    , taskSource
    , taskAttachments
    , taskCurrentAgent
    , taskAgentChain
    , taskQuestions
    , taskAssignedAgent
    , isPlanned
    -- Mutators
    , planTask
    , setTaskStatus
    , setAttachments
    , setCurrentAgent
    , setAgentChain
    -- Helpers
    , statusToString
    , statusFromString
    , statusEquals
    , completionStatusToString
    , eventTypeToString
    , eventTypeFromString
    , sourceTypeToString
    , sourceTypeFromString
    , agentConfigName
    , isInternalAgent
    , updateCurrentAgentEntry
    , findParentAgent
    )

{-| Shared types, encoders, and decoders for the Chorus API contract.

This module is the single source of truth for all types that cross the
boundary between backend and frontend. Both applications reference it
via the `source-directories` field in their `gren.json`.

Only depends on `gren-lang/core` so it compiles for both node and browser.

-}

import Dict exposing (Dict)
import Id exposing (TaskId, SessionId, MessageId)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Time



-- TYPES


{-| A task in the registry. Either description-only or fully planned.
-}
type Task
    = DescriptionOnly DescriptionOnlyTask
    | Planned PlannedTask


{-| A record of an agent hand-off on a task.
-}
type alias HandoffRecord =
    { agentName : String
    , startedAt : Time.Posix
    , completedAt : Maybe Time.Posix
    , input : String
    , output : String
    , completionReport : Maybe CompletionReport
    }


{-| Status of a completion report submitted by an agent.
-}
type CompletionStatus
    = ReportComplete
    | ReportBlocked
    | ReportFailed


{-| Structured output submitted by an agent via the completion-report tool.
-}
type alias CompletionReport =
    { status : CompletionStatus
    , summary : String
    , output : String
    , blockedReason : Maybe String
    }


{-| A task that has only a description and no planning data.
-}
type alias DescriptionOnlyTask =
    { id : TaskId
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe SessionId
    , source : SourceInfo
    , attachments : Array Attachment
    , currentAgent : Maybe String
    , agentChain : Array HandoffRecord
    }


{-| A question asked by the planning agent, with an optional user answer.
-}
type alias PlanningQuestion =
    { question : String
    , answer : Maybe String
    }


{-| A task that has been planned with summary, requirements, criteria, and steps.
-}
type alias PlannedTask =
    { id : TaskId
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , sessionId : Maybe SessionId
    , source : SourceInfo
    , attachments : Array Attachment
    , currentAgent : Maybe String
    , agentChain : Array HandoffRecord
    , summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    , questions : Array PlanningQuestion
    , assignedAgent : Maybe String
    }


{-| Planning fields used when converting a DescriptionOnly task to Planned.
-}
type alias PlanningFields =
    { summary : String
    , requirements : Array String
    , acceptanceCriteria : Array String
    , plan : Array String
    , questions : Array PlanningQuestion
    , assignedAgent : Maybe String
    }


{-| Metadata for a file attached to a task.
-}
type alias Attachment =
    { filename : String
    , size : Int
    , contentType : String
    , uploadedAt : Time.Posix
    }


{-| Task lifecycle status.
-}
type TaskStatus
    = Pending        -- created but session not started
    | Planning       -- being analyzed by planning agent
    | AwaitingInput  -- planning agent returned questions for user
    | ReadyToStart   -- plan complete, ready to start
    | Active         -- session is currently processing
    | Waiting        -- session idle, ready for more input
    | Completed      -- finished successfully
    | Failed String  -- finished with error message


{-| The type of event recorded in task history.
-}
type EventType
    = TaskCreated
    | StatusChanged
    | ToolExecuted
    | PlanningStarted
    | PlanningCompleted
    | PlanningFailed
    | PlanningQuestionsReturned
    | AnswersSubmitted
    | AgentStarted
    | AgentCompleted
    | AgentHandoffStarted
    | AgentHandoffCompleted
    | CompletionReportSubmitted


{-| The source channel that originated a task.
-}
type SourceType
    = WebSource
    | TerminalSource
    | TestSource
    | XmppSource


{-| Information about where the task originated.
-}
type alias SourceInfo =
    { sourceType : SourceType
    , userId : String
    , conversationId : Maybe String
    }


{-| Event recorded in task history.
-}
type alias Event =
    { timestamp : Time.Posix
    , eventType : EventType
    , data : Dict String String
    }


{-| Task event history.
-}
type alias History =
    { events : Array Event
    }


{-| A message waiting to be processed.
-}
type alias QueuedMessage =
    { id : MessageId
    , content : String
    , receivedAt : Time.Posix
    }


{-| Task message queue.
-}
type alias Queue =
    { messages : Array QueuedMessage
    }


{-| An agent configuration.

Internal agents are system-managed (e.g. task-validator) and only need name
and instructions. User-defined agents have the full provider/model/tools config.
-}
type AgentConfig
    = InternalAgent { name : String, instructions : String }
    | UserDefinedAgent { name : String, instructions : String, allowedTools : Array String, provider : AgentProvider, model : Maybe String }


{-| How an agent references its provider.

NotConfigured means the agent has no provider assigned and cannot be used for tasks.
ProviderRef carries the name of a configured provider.
-}
type AgentProvider
    = NotConfigured
    | ProviderRef String


{-| Provider variant type. Represents the different kinds of LLM providers.

OpenAiCompatible carries API-specific configuration fields.
ClaudeCode and OpenCode are CLI-based providers with no extra config.

Research note on OpenAI-compatible services:
- OpenRouter (https://openrouter.ai/api/v1): Fully compatible with OpenAI Chat Completions
  API format. Uses standard Authorization: Bearer header. Supports /v1/chat/completions
  with the same request/response schema. No protocol differences.
- Ollama (http://localhost:11434/v1): Provides an OpenAI-compatible endpoint at /v1.
  Supports /v1/chat/completions with the same schema. API key is optional (local service).
  No special parameters required.
- LM Studio (http://localhost:1234/v1): Fully OpenAI-compatible. Supports
  /v1/chat/completions with standard request/response format. API key is optional
  (local service). No protocol differences.

All three services are implemented as presets of the openai-compat provider type,
pre-filling the apiBaseUrl field.
-}
type ProviderType
    = OpenAiCompatible
        { apiBaseUrl : String
        , apiKey : String
        , defaultModel : String
        }
    | ClaudeCode
    | OpenCode


{-| A named provider configuration. The name is the unique identifier,
used as the filename and reference key.
-}
type alias ProviderConfig =
    { name : String
    , providerType : ProviderType
    }


{-| Workspace configuration stored in a `chorus.json` file.

Contains all settings that define a workspace: which directories agents
can access, and which provider to use for internal/system agents.
-}
type alias WorkspaceConfig =
    { allowedAgentDirectories : Array String
    , initialAgentDirectory : String
    , systemAgentProvider : AgentProvider
    , serverPort : Maybe Int
    }



-- TASK ACCESSORS


{-| Get the ID of a task.
-}
taskId : Task -> TaskId
taskId task =
    when task is
        DescriptionOnly t ->
            t.id

        Planned t ->
            t.id


{-| Get the description of a task.
-}
taskDescription : Task -> String
taskDescription task =
    when task is
        DescriptionOnly t ->
            t.description

        Planned t ->
            t.description


{-| Get the status of a task.
-}
taskStatus : Task -> TaskStatus
taskStatus task =
    when task is
        DescriptionOnly t ->
            t.status

        Planned t ->
            t.status


{-| Get the creation time of a task.
-}
taskCreatedAt : Task -> Time.Posix
taskCreatedAt task =
    when task is
        DescriptionOnly t ->
            t.createdAt

        Planned t ->
            t.createdAt


{-| Get the last update time of a task.
-}
taskUpdatedAt : Task -> Time.Posix
taskUpdatedAt task =
    when task is
        DescriptionOnly t ->
            t.updatedAt

        Planned t ->
            t.updatedAt


{-| Get the session ID of a task.
-}
taskSessionId : Task -> Maybe SessionId
taskSessionId task =
    when task is
        DescriptionOnly t ->
            t.sessionId

        Planned t ->
            t.sessionId


{-| Get the source info of a task.
-}
taskSource : Task -> SourceInfo
taskSource task =
    when task is
        DescriptionOnly t ->
            t.source

        Planned t ->
            t.source


{-| Get the attachments of a task.
-}
taskAttachments : Task -> Array Attachment
taskAttachments task =
    when task is
        DescriptionOnly t ->
            t.attachments

        Planned t ->
            t.attachments


{-| Get the current agent assigned to a task.
-}
taskCurrentAgent : Task -> Maybe String
taskCurrentAgent task =
    when task is
        DescriptionOnly t ->
            t.currentAgent

        Planned t ->
            t.currentAgent


{-| Get the agent chain (hand-off history) of a task.
-}
taskAgentChain : Task -> Array HandoffRecord
taskAgentChain task =
    when task is
        DescriptionOnly t ->
            t.agentChain

        Planned t ->
            t.agentChain


{-| Check if a task has been planned.
-}
isPlanned : Task -> Bool
isPlanned task =
    when task is
        DescriptionOnly _ ->
            False

        Planned _ ->
            True


{-| Get the planning questions for a task.
-}
taskQuestions : Task -> Array PlanningQuestion
taskQuestions task =
    when task is
        DescriptionOnly _ ->
            []

        Planned t ->
            t.questions


{-| Get the assigned agent for a task.
-}
taskAssignedAgent : Task -> Maybe String
taskAssignedAgent task =
    when task is
        DescriptionOnly _ ->
            Nothing

        Planned t ->
            t.assignedAgent



-- TASK MUTATORS


{-| Convert a task to Planned by adding planning fields.
    If the task is already Planned, the existing planning fields are replaced.
-}
planTask : Task -> PlanningFields -> Task
planTask task fields =
    when task is
        DescriptionOnly t ->
            Planned
                { id = t.id
                , description = t.description
                , status = t.status
                , createdAt = t.createdAt
                , updatedAt = t.updatedAt
                , sessionId = t.sessionId
                , source = t.source
                , attachments = t.attachments
                , currentAgent = t.currentAgent
                , agentChain = t.agentChain
                , summary = fields.summary
                , requirements = fields.requirements
                , acceptanceCriteria = fields.acceptanceCriteria
                , plan = fields.plan
                , questions = fields.questions
                , assignedAgent = fields.assignedAgent
                }

        Planned t ->
            Planned
                { t
                    | summary = fields.summary
                    , requirements = fields.requirements
                    , acceptanceCriteria = fields.acceptanceCriteria
                    , plan = fields.plan
                    , questions = fields.questions
                    , assignedAgent = fields.assignedAgent
                }


{-| Set the status on a task.
-}
setTaskStatus : TaskStatus -> Task -> Task
setTaskStatus newStatus task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | status = newStatus }

        Planned t ->
            Planned { t | status = newStatus }


{-| Set the attachments on a task.
-}
setAttachments : Array Attachment -> Task -> Task
setAttachments attachments task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | attachments = attachments }

        Planned t ->
            Planned { t | attachments = attachments }


{-| Set the current agent on a task.
-}
setCurrentAgent : Maybe String -> Task -> Task
setCurrentAgent agent task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | currentAgent = agent }

        Planned t ->
            Planned { t | currentAgent = agent }


{-| Set the agent chain (hand-off history) on a task.
-}
setAgentChain : Array HandoffRecord -> Task -> Task
setAgentChain chain task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | agentChain = chain }

        Planned t ->
            Planned { t | agentChain = chain }


{-| Update the chain entry for the current agent (last uncompleted entry
matching the given agent name). Falls back to updating the last entry
if no match is found (backwards compatibility).
-}
updateCurrentAgentEntry : String -> (HandoffRecord -> HandoffRecord) -> Array HandoffRecord -> Array HandoffRecord
updateCurrentAgentEntry agentName updateFn chain =
    let
        -- Find index of last uncompleted entry matching agent name
        targetIndex =
            chain
                |> Array.indexedMap (\i entry -> { i = i, entry = entry })
                |> Array.keepIf (\x -> x.entry.agentName == agentName && x.entry.completedAt == Nothing)
                |> Array.popLast
                |> Maybe.map (\{ last } -> last.i)
    in
    when targetIndex is
        Just idx ->
            chain
                |> Array.indexedMap
                    (\i entry ->
                        if i == idx then
                            updateFn entry
                        else
                            entry
                    )

        Nothing ->
            -- Fallback: update last entry
            when Array.popLast chain is
                Nothing ->
                    chain

                Just { last, initial } ->
                    Array.pushLast (updateFn last) initial


{-| Find the parent agent after a child completes: the last uncompleted
entry in the chain. Returns Nothing if all entries are completed.
-}
findParentAgent : Array HandoffRecord -> Maybe String
findParentAgent chain =
    chain
        |> Array.keepIf (\entry -> entry.completedAt == Nothing)
        |> Array.popLast
        |> Maybe.map (\{ last } -> last.agentName)



-- JSON ENCODING


{-| Encode a task to JSON. Includes a "taskType" discriminator field.

    The discriminator is named "taskType" rather than "type" because "type"
    is already used as the discriminator inside the nested status object
    (e.g. {"type": "active"}). Using "taskType" avoids ambiguity.
-}
encodeTask : Task -> Encode.Value
encodeTask task =
    when task is
        DescriptionOnly t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "descriptionOnly" }
                , { key = "id", value = Id.encodeTaskId t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Id.encodeSessionId t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                , { key = "currentAgent", value = encodeMaybe Encode.string t.currentAgent }
                , { key = "agentChain", value = Encode.array encodeHandoffRecord t.agentChain }
                ]

        Planned t ->
            Encode.object
                [ { key = "taskType", value = Encode.string "planned" }
                , { key = "id", value = Id.encodeTaskId t.id }
                , { key = "description", value = Encode.string t.description }
                , { key = "status", value = encodeStatus t.status }
                , { key = "createdAt", value = Encode.int (Time.posixToMillis t.createdAt) }
                , { key = "updatedAt", value = Encode.int (Time.posixToMillis t.updatedAt) }
                , { key = "sessionId", value = encodeMaybe Id.encodeSessionId t.sessionId }
                , { key = "source", value = encodeSourceInfo t.source }
                , { key = "attachments", value = Encode.array encodeAttachment t.attachments }
                , { key = "currentAgent", value = encodeMaybe Encode.string t.currentAgent }
                , { key = "agentChain", value = Encode.array encodeHandoffRecord t.agentChain }
                , { key = "summary", value = Encode.string t.summary }
                , { key = "requirements", value = Encode.array Encode.string t.requirements }
                , { key = "acceptanceCriteria", value = Encode.array Encode.string t.acceptanceCriteria }
                , { key = "plan", value = Encode.array Encode.string t.plan }
                , { key = "questions", value = Encode.array encodePlanningQuestion t.questions }
                , { key = "assignedAgent", value = encodeMaybe Encode.string t.assignedAgent }
                ]


{-| Encode an attachment to JSON.
-}
encodeAttachment : Attachment -> Encode.Value
encodeAttachment attachment =
    Encode.object
        [ { key = "filename", value = Encode.string attachment.filename }
        , { key = "size", value = Encode.int attachment.size }
        , { key = "contentType", value = Encode.string attachment.contentType }
        , { key = "uploadedAt", value = Encode.int (Time.posixToMillis attachment.uploadedAt) }
        ]


{-| Encode a planning question to JSON.
-}
encodePlanningQuestion : PlanningQuestion -> Encode.Value
encodePlanningQuestion q =
    Encode.object
        [ { key = "question", value = Encode.string q.question }
        , { key = "answer", value = encodeMaybe Encode.string q.answer }
        ]


encodeHandoffRecord : HandoffRecord -> Encode.Value
encodeHandoffRecord record =
    Encode.object
        [ { key = "agentName", value = Encode.string record.agentName }
        , { key = "startedAt", value = Encode.int (Time.posixToMillis record.startedAt) }
        , { key = "completedAt", value = encodeMaybe (\t -> Encode.int (Time.posixToMillis t)) record.completedAt }
        , { key = "input", value = Encode.string record.input }
        , { key = "output", value = Encode.string record.output }
        , { key = "completionReport", value = encodeMaybe encodeCompletionReport record.completionReport }
        ]


{-| Encode a completion report to JSON.
-}
encodeCompletionReport : CompletionReport -> Encode.Value
encodeCompletionReport report =
    Encode.object
        [ { key = "status", value = Encode.string (completionStatusToString report.status) }
        , { key = "summary", value = Encode.string report.summary }
        , { key = "output", value = Encode.string report.output }
        , { key = "blockedReason", value = encodeMaybe Encode.string report.blockedReason }
        ]


{-| Convert a CompletionStatus to its string representation.
-}
completionStatusToString : CompletionStatus -> String
completionStatusToString status =
    when status is
        ReportComplete ->
            "complete"

        ReportBlocked ->
            "blocked"

        ReportFailed ->
            "failed"


encodeStatus : TaskStatus -> Encode.Value
encodeStatus status =
    when status is
        Pending ->
            Encode.object
                [ { key = "type", value = Encode.string "pending" }
                ]

        Planning ->
            Encode.object
                [ { key = "type", value = Encode.string "planning" }
                ]

        AwaitingInput ->
            Encode.object
                [ { key = "type", value = Encode.string "awaiting_input" }
                ]

        ReadyToStart ->
            Encode.object
                [ { key = "type", value = Encode.string "planned" }
                ]

        Active ->
            Encode.object
                [ { key = "type", value = Encode.string "active" }
                ]

        Waiting ->
            Encode.object
                [ { key = "type", value = Encode.string "waiting" }
                ]

        Completed ->
            Encode.object
                [ { key = "type", value = Encode.string "completed" }
                ]

        Failed message ->
            Encode.object
                [ { key = "type", value = Encode.string "failed" }
                , { key = "message", value = Encode.string message }
                ]


encodeSourceInfo : SourceInfo -> Encode.Value
encodeSourceInfo source =
    Encode.object
        [ { key = "sourceType", value = Encode.string (sourceTypeToString source.sourceType) }
        , { key = "userId", value = Encode.string source.userId }
        , { key = "conversationId", value = encodeMaybe Encode.string source.conversationId }
        ]


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder maybeValue =
    when maybeValue is
        Just value ->
            encoder value

        Nothing ->
            Encode.null


encodeEvent : Event -> Encode.Value
encodeEvent event =
    Encode.object
        [ { key = "timestamp", value = Encode.int (Time.posixToMillis event.timestamp) }
        , { key = "eventType", value = Encode.string (eventTypeToString event.eventType) }
        , { key = "data", value = Encode.dict identity Encode.string event.data }
        ]


encodeHistory : History -> Encode.Value
encodeHistory history =
    Encode.object
        [ { key = "events", value = Encode.array encodeEvent history.events }
        ]


encodeQueue : Queue -> Encode.Value
encodeQueue queue =
    Encode.object
        [ { key = "messages"
          , value = Encode.array encodeMessage queue.messages
          }
        ]


encodeMessage : QueuedMessage -> Encode.Value
encodeMessage msg =
    Encode.object
        [ { key = "id", value = Id.encodeMessageId msg.id }
        , { key = "content", value = Encode.string msg.content }
        , { key = "receivedAt", value = Encode.int (Time.posixToMillis msg.receivedAt) }
        ]



-- JSON DECODING


{-| Decode a task from JSON. Requires the "taskType" discriminator field.
-}
taskDecoder : Decoder Task
taskDecoder =
    Decode.field "taskType" Decode.string
        |> Decode.andThen
            (\taskType ->
                when taskType is
                    "planned" ->
                        plannedTaskDecoder

                    _ ->
                        descriptionOnlyTaskDecoder
            )


descriptionOnlyTaskDecoder : Decoder Task
descriptionOnlyTaskDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = Nothing
            , source = { sourceType = WebSource, userId = "", conversationId = Nothing }
            , attachments = []
            , currentAgent = Nothing
            , agentChain = []
            }
        )
        (Decode.field "id" Id.taskIdDecoder)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        |> Decode.andThen
            (\task ->
                Decode.field "sessionId" (Decode.maybe Id.sessionIdDecoder)
                    |> Decode.map (\sessionId -> { task | sessionId = sessionId })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "source" sourceInfoDecoder
                    |> Decode.map (\source -> { task | source = source })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "attachments" (Decode.array attachmentDecoder)
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "currentAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\currentAgent -> { task | currentAgent = currentAgent })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "agentChain" (Decode.array handoffRecordDecoder)
                    |> Decode.map (\agentChain -> DescriptionOnly { task | agentChain = agentChain })
            )


plannedTaskDecoder : Decoder Task
plannedTaskDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , sessionId = Nothing
            , source = { sourceType = WebSource, userId = "", conversationId = Nothing }
            , attachments = []
            , currentAgent = Nothing
            , agentChain = []
            , summary = ""
            , requirements = []
            , acceptanceCriteria = []
            , plan = []
            , questions = []
            , assignedAgent = Nothing
            }
        )
        (Decode.field "id" Id.taskIdDecoder)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        |> Decode.andThen
            (\task ->
                Decode.field "sessionId" (Decode.maybe Id.sessionIdDecoder)
                    |> Decode.map (\sessionId -> { task | sessionId = sessionId })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "source" sourceInfoDecoder
                    |> Decode.map (\source -> { task | source = source })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "attachments" (Decode.array attachmentDecoder)
                    |> Decode.map (\attachments -> { task | attachments = attachments })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "currentAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\currentAgent -> { task | currentAgent = currentAgent })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "agentChain" (Decode.array handoffRecordDecoder)
                    |> Decode.map (\agentChain -> { task | agentChain = agentChain })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "summary" Decode.string
                    |> Decode.map (\summary -> { task | summary = summary })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "requirements" (Decode.array Decode.string)
                    |> Decode.map (\requirements -> { task | requirements = requirements })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "acceptanceCriteria" (Decode.array Decode.string)
                    |> Decode.map (\acceptanceCriteria -> { task | acceptanceCriteria = acceptanceCriteria })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "plan" (Decode.array Decode.string)
                    |> Decode.map (\plan -> { task | plan = plan })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "questions" (Decode.array planningQuestionDecoder)
                    |> Decode.map (\questions -> { task | questions = questions })
            )
        |> Decode.andThen
            (\task ->
                Decode.field "assignedAgent" (Decode.maybe Decode.string)
                    |> Decode.map (\assignedAgent -> Planned { task | assignedAgent = assignedAgent })
            )


{-| Decode a planning question from JSON.
-}
planningQuestionDecoder : Decoder PlanningQuestion
planningQuestionDecoder =
    Decode.map2
        (\question answer ->
            { question = question
            , answer = answer
            }
        )
        (Decode.field "question" Decode.string)
        (Decode.field "answer" (Decode.maybe Decode.string))


{-| Decode a hand-off record from JSON.
-}
handoffRecordDecoder : Decoder HandoffRecord
handoffRecordDecoder =
    Decode.map5
        (\agentName startedAt completedAt input output ->
            { agentName = agentName
            , startedAt = startedAt
            , completedAt = completedAt
            , input = input
            , output = output
            , completionReport = Nothing
            }
        )
        (Decode.field "agentName" Decode.string)
        (Decode.field "startedAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "completedAt" (Decode.maybe (Decode.map Time.millisToPosix Decode.int)))
        (Decode.field "input" Decode.string)
        (Decode.field "output" Decode.string)
        |> Decode.andThen
            (\record ->
                Decode.field "completionReport" (Decode.maybe completionReportDecoder)
                    |> Decode.map (\completionReport -> { record | completionReport = completionReport })
            )


{-| Decode a completion report from JSON.
-}
completionReportDecoder : Decoder CompletionReport
completionReportDecoder =
    Decode.map4
        (\status summary output blockedReason ->
            { status = status
            , summary = summary
            , output = output
            , blockedReason = blockedReason
            }
        )
        (Decode.field "status" completionStatusDecoder)
        (Decode.field "summary" Decode.string)
        (Decode.field "output" Decode.string)
        (Decode.field "blockedReason" (Decode.maybe Decode.string))


completionStatusDecoder : Decoder CompletionStatus
completionStatusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when str is
                    "complete" ->
                        Decode.succeed ReportComplete

                    "blocked" ->
                        Decode.succeed ReportBlocked

                    "failed" ->
                        Decode.succeed ReportFailed

                    _ ->
                        Decode.fail ("Unknown completion status: " ++ str)
            )


attachmentDecoder : Decoder Attachment
attachmentDecoder =
    Decode.map4
        (\filename size contentType uploadedAt ->
            { filename = filename
            , size = size
            , contentType = contentType
            , uploadedAt = uploadedAt
            }
        )
        (Decode.field "filename" Decode.string)
        (Decode.field "size" Decode.int)
        (Decode.field "contentType" Decode.string)
        (Decode.field "uploadedAt" (Decode.map Time.millisToPosix Decode.int))


statusDecoder : Decoder TaskStatus
statusDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\statusType ->
                when statusType is
                    "pending" ->
                        Decode.succeed Pending

                    "planning" ->
                        Decode.succeed Planning

                    "awaiting_input" ->
                        Decode.succeed AwaitingInput

                    "planned" ->
                        Decode.succeed ReadyToStart

                    "active" ->
                        Decode.succeed Active

                    "waiting" ->
                        Decode.succeed Waiting

                    "completed" ->
                        Decode.succeed Completed

                    "failed" ->
                        Decode.field "message" Decode.string
                            |> Decode.map Failed

                    _ ->
                        Decode.fail ("Unknown status type: " ++ statusType)
            )


sourceInfoDecoder : Decoder SourceInfo
sourceInfoDecoder =
    Decode.map3
        (\sourceType userId conversationId ->
            { sourceType = sourceType
            , userId = userId
            , conversationId = conversationId
            }
        )
        (Decode.field "sourceType" sourceTypeDecoder)
        (Decode.field "userId" Decode.string)
        (Decode.field "conversationId" (Decode.maybe Decode.string))


sourceTypeDecoder : Decoder SourceType
sourceTypeDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when sourceTypeFromString str is
                    Just sourceType ->
                        Decode.succeed sourceType

                    Nothing ->
                        Decode.fail ("Unknown source type: " ++ str)
            )


eventDecoder : Decoder Event
eventDecoder =
    Decode.map3
        (\timestamp eventType data ->
            { timestamp = timestamp
            , eventType = eventType
            , data = data
            }
        )
        (Decode.field "timestamp" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "eventType" eventTypeDecoder)
        (Decode.field "data" (Decode.dict Decode.string))


eventTypeDecoder : Decoder EventType
eventTypeDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when eventTypeFromString str is
                    Just eventType ->
                        Decode.succeed eventType

                    Nothing ->
                        Decode.fail ("Unknown event type: " ++ str)
            )


historyDecoder : Decoder History
historyDecoder =
    Decode.map (\events -> { events = events })
        (Decode.field "events" (Decode.array eventDecoder))


queueDecoder : Decoder Queue
queueDecoder =
    Decode.map (\messages -> { messages = messages })
        (Decode.field "messages" (Decode.array messageDecoder))


messageDecoder : Decoder QueuedMessage
messageDecoder =
    Decode.map3
        (\id content receivedAt ->
            { id = id
            , content = content
            , receivedAt = receivedAt
            }
        )
        (Decode.field "id" Id.messageIdDecoder)
        (Decode.field "content" Decode.string)
        (Decode.field "receivedAt" (Decode.map Time.millisToPosix Decode.int))



-- AGENT CONFIG JSON


{-| Encode an agent config to JSON.

Includes a "type" discriminator field: "internal" or "user_defined".
-}
encodeAgentConfig : AgentConfig -> Encode.Value
encodeAgentConfig config =
    when config is
        InternalAgent r ->
            Encode.object
                [ { key = "type", value = Encode.string "internal" }
                , { key = "name", value = Encode.string r.name }
                , { key = "instructions", value = Encode.string r.instructions }
                ]

        UserDefinedAgent r ->
            let
                requiredFields =
                    [ { key = "type", value = Encode.string "user_defined" }
                    , { key = "name", value = Encode.string r.name }
                    , { key = "instructions", value = Encode.string r.instructions }
                    , { key = "allowedTools", value = Encode.array Encode.string r.allowedTools }
                    , { key = "provider", value = encodeAgentProvider r.provider }
                    ]

                modelField =
                    when r.model is
                        Just m ->
                            [ { key = "model", value = Encode.string m } ]

                        Nothing ->
                            []
            in
            Encode.object (Array.flatten [ requiredFields, modelField ])


agentConfigDecoder : Decoder AgentConfig
agentConfigDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\agentType ->
                when agentType is
                    "internal" ->
                        Decode.map2
                            (\name instructions ->
                                InternalAgent { name = name, instructions = instructions }
                            )
                            (Decode.field "name" Decode.string)
                            (Decode.field "instructions" Decode.string)

                    "user_defined" ->
                        Decode.map5
                            (\name instructions allowedTools provider model ->
                                UserDefinedAgent
                                    { name = name
                                    , instructions = instructions
                                    , allowedTools = allowedTools
                                    , provider = provider
                                    , model = model
                                    }
                            )
                            (Decode.field "name" Decode.string)
                            (Decode.field "instructions" Decode.string)
                            (Decode.field "allowedTools" (Decode.array Decode.string))
                            (Decode.field "provider" agentProviderDecoder)
                            (Decode.maybe (Decode.field "model" Decode.string))

                    _ ->
                        Decode.fail ("Unknown agent config type: " ++ agentType)
            )



-- PROVIDER TYPE JSON


{-| Encode an AgentProvider to JSON.

NotConfigured encodes as the string "not-configured".
ProviderRef encodes as the provider name string.
-}
encodeAgentProvider : AgentProvider -> Encode.Value
encodeAgentProvider provider =
    when provider is
        NotConfigured ->
            Encode.string "not-configured"

        ProviderRef name ->
            Encode.string name


{-| Decode an AgentProvider from JSON.

"not-configured" decodes as NotConfigured.
Any other string decodes as ProviderRef with that string.
-}
agentProviderDecoder : Decoder AgentProvider
agentProviderDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when str is
                    "not-configured" ->
                        Decode.succeed NotConfigured

                    _ ->
                        Decode.succeed (ProviderRef str)
            )


{-| Encode a ProviderType to JSON.

Uses a "type" discriminator field with variant-specific fields at the same level.
-}
encodeProviderType : ProviderType -> Encode.Value
encodeProviderType providerType =
    when providerType is
        OpenAiCompatible config ->
            Encode.object
                [ { key = "type", value = Encode.string "openai-compat" }
                , { key = "apiBaseUrl", value = Encode.string config.apiBaseUrl }
                , { key = "apiKey", value = Encode.string config.apiKey }
                , { key = "defaultModel", value = Encode.string config.defaultModel }
                ]

        ClaudeCode ->
            Encode.object
                [ { key = "type", value = Encode.string "claude-code" }
                ]

        OpenCode ->
            Encode.object
                [ { key = "type", value = Encode.string "opencode" }
                ]


{-| Decode a ProviderType from JSON.

Matches on the "type" discriminator field.
-}
providerTypeDecoder : Decoder ProviderType
providerTypeDecoder =
    Decode.field "type" Decode.string
        |> Decode.andThen
            (\typeStr ->
                when typeStr is
                    "openai-compat" ->
                        Decode.map3
                            (\apiBaseUrl apiKey defaultModel ->
                                OpenAiCompatible
                                    { apiBaseUrl = apiBaseUrl
                                    , apiKey = apiKey
                                    , defaultModel = defaultModel
                                    }
                            )
                            (Decode.field "apiBaseUrl" Decode.string)
                            (Decode.field "apiKey" Decode.string)
                            (Decode.field "defaultModel" Decode.string)

                    "claude-code" ->
                        Decode.succeed ClaudeCode

                    "opencode" ->
                        Decode.succeed OpenCode

                    _ ->
                        Decode.fail ("Unknown provider type: " ++ typeStr)
            )


{-| Encode a ProviderConfig to JSON.
-}
encodeProviderConfig : ProviderConfig -> Encode.Value
encodeProviderConfig config =
    Encode.object
        [ { key = "name", value = Encode.string config.name }
        , { key = "providerType", value = encodeProviderType config.providerType }
        ]


{-| Decode a ProviderConfig from JSON.
-}
providerConfigDecoder : Decoder ProviderConfig
providerConfigDecoder =
    Decode.map2
        (\name providerType ->
            { name = name
            , providerType = providerType
            }
        )
        (Decode.field "name" Decode.string)
        (Decode.field "providerType" providerTypeDecoder)



-- WORKSPACE CONFIG JSON


{-| Encode a WorkspaceConfig to JSON.
-}
encodeWorkspaceConfig : WorkspaceConfig -> Encode.Value
encodeWorkspaceConfig config =
    let
        requiredFields =
            [ { key = "allowedAgentDirectories", value = Encode.array Encode.string config.allowedAgentDirectories }
            , { key = "initialAgentDirectory", value = Encode.string config.initialAgentDirectory }
            , { key = "systemAgentProvider", value = encodeAgentProvider config.systemAgentProvider }
            ]

        portField =
            when config.serverPort is
                Just p ->
                    [ { key = "port", value = Encode.int p } ]

                Nothing ->
                    []
    in
    Encode.object (Array.flatten [ requiredFields, portField ])


{-| Decode a WorkspaceConfig from JSON.
-}
workspaceConfigDecoder : Decoder WorkspaceConfig
workspaceConfigDecoder =
    Decode.map3
        (\allowedAgentDirectories initialAgentDirectory systemAgentProvider ->
            { allowedAgentDirectories = allowedAgentDirectories
            , initialAgentDirectory = initialAgentDirectory
            , systemAgentProvider = systemAgentProvider
            , serverPort = Nothing
            }
        )
        (Decode.field "allowedAgentDirectories" (Decode.array Decode.string))
        (Decode.field "initialAgentDirectory" Decode.string)
        (Decode.field "systemAgentProvider" agentProviderDecoder)
        |> Decode.andThen
            (\config ->
                Decode.maybe (Decode.field "port" Decode.int)
                    |> Decode.map (\maybePort -> { config | serverPort = maybePort })
            )



-- HELPERS


{-| Convert status to display string.
-}
statusToString : TaskStatus -> String
statusToString status =
    when status is
        Pending ->
            "pending"

        Planning ->
            "planning"

        AwaitingInput ->
            "awaiting_input"

        ReadyToStart ->
            "planned"

        Active ->
            "active"

        Waiting ->
            "waiting"

        Completed ->
            "completed"

        Failed _ ->
            "failed"


{-| Parse status from string.
-}
statusFromString : String -> Maybe TaskStatus
statusFromString str =
    when str is
        "pending" ->
            Just Pending

        "planning" ->
            Just Planning

        "awaiting_input" ->
            Just AwaitingInput

        "planned" ->
            Just ReadyToStart

        "active" ->
            Just Active

        "waiting" ->
            Just Waiting

        "completed" ->
            Just Completed

        "failed" ->
            Just (Failed "")

        _ ->
            Nothing


{-| Convert an EventType to its string representation for JSON serialization.
-}
eventTypeToString : EventType -> String
eventTypeToString eventType =
    when eventType is
        TaskCreated ->
            "task_created"

        StatusChanged ->
            "status_changed"

        ToolExecuted ->
            "tool_executed"

        PlanningStarted ->
            "planning_started"

        PlanningCompleted ->
            "planning_completed"

        PlanningFailed ->
            "planning_failed"

        PlanningQuestionsReturned ->
            "planning_questions_returned"

        AnswersSubmitted ->
            "answers_submitted"

        AgentStarted ->
            "agent_started"

        AgentCompleted ->
            "agent_completed"

        AgentHandoffStarted ->
            "agent_handoff_started"

        AgentHandoffCompleted ->
            "agent_handoff_completed"

        CompletionReportSubmitted ->
            "completion_report_submitted"


{-| Parse an EventType from its string representation.
-}
eventTypeFromString : String -> Maybe EventType
eventTypeFromString str =
    when str is
        "task_created" ->
            Just TaskCreated

        "status_changed" ->
            Just StatusChanged

        "tool_executed" ->
            Just ToolExecuted

        "planning_started" ->
            Just PlanningStarted

        "planning_completed" ->
            Just PlanningCompleted

        "planning_failed" ->
            Just PlanningFailed

        "planning_questions_returned" ->
            Just PlanningQuestionsReturned

        "answers_submitted" ->
            Just AnswersSubmitted

        "agent_started" ->
            Just AgentStarted

        "agent_completed" ->
            Just AgentCompleted

        "agent_handoff_started" ->
            Just AgentHandoffStarted

        "agent_handoff_completed" ->
            Just AgentHandoffCompleted

        "completion_report_submitted" ->
            Just CompletionReportSubmitted

        _ ->
            Nothing


{-| Convert a SourceType to its string representation for JSON serialization.
-}
sourceTypeToString : SourceType -> String
sourceTypeToString sourceType =
    when sourceType is
        WebSource ->
            "web"

        TerminalSource ->
            "terminal"

        TestSource ->
            "test"

        XmppSource ->
            "xmpp"


{-| Parse a SourceType from its string representation.
-}
sourceTypeFromString : String -> Maybe SourceType
sourceTypeFromString str =
    when str is
        "web" ->
            Just WebSource

        "terminal" ->
            Just TerminalSource

        "test" ->
            Just TestSource

        "xmpp" ->
            Just XmppSource

        _ ->
            Nothing


{-| Get the name of an agent config.
-}
agentConfigName : AgentConfig -> String
agentConfigName config =
    when config is
        InternalAgent r ->
            r.name

        UserDefinedAgent r ->
            r.name


{-| Check if an agent config is an internal agent.
-}
isInternalAgent : AgentConfig -> Bool
isInternalAgent config =
    when config is
        InternalAgent _ ->
            True

        UserDefinedAgent _ ->
            False


{-| Check if two statuses are equal (for filtering).
-}
statusEquals : TaskStatus -> TaskStatus -> Bool
statusEquals a b =
    when { a = a, b = b } is
        { a = Pending, b = Pending } ->
            True

        { a = Planning, b = Planning } ->
            True

        { a = AwaitingInput, b = AwaitingInput } ->
            True

        { a = ReadyToStart, b = ReadyToStart } ->
            True

        { a = Active, b = Active } ->
            True

        { a = Waiting, b = Waiting } ->
            True

        { a = Completed, b = Completed } ->
            True

        { a = Failed _, b = Failed _ } ->
            True

        _ ->
            False
