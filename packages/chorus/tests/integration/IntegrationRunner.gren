module IntegrationRunner exposing (main)

{-| Integration tests for Task.Registry.

These tests exercise the actual file I/O operations against the filesystem.
-}

import Bytes
import Crypto exposing (SecureContext)
import Dict
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Init
import Json.Decode as Decode
import Node
import Stream
import Task as GrenTask
import Id
import Task.Queue as Queue
import Task.Registry as Registry exposing (Registry)
import Types exposing (TaskStatus(..))
import Time


main : Node.SimpleProgram a
main =
    Node.defineSimpleProgram init


init : Node.Environment -> Init.Task (Cmd a)
init env =
    Init.await FileSystem.initialize <| \filesystemPermission ->
    Init.awaitTask (getSecureContextOrCrash env) <| \secureContext ->
        let
            tempDir =
                Path.fromPosixString "/tmp/chorus-integration-test"

            ctx =
                { filesystemPermission = filesystemPermission
                , secureContext = secureContext
                , tempDir = tempDir
                , stdout = env.stdout
                }
        in
        Stream.writeLineAsBytes "Running 19 integration tests...\n" env.stdout
            |> GrenTask.onError (\_ -> GrenTask.succeed env.stdout)
            |> GrenTask.andThen (\_ -> setupTempDir filesystemPermission tempDir)
            |> GrenTask.andThen (\_ -> runAllTests ctx)
            |> GrenTask.andThen (\results -> reportResults ctx results)
            |> GrenTask.andThen
                (\exitCode ->
                    -- Cleanup temp dir
                    FileSystem.remove filesystemPermission { recursive = True } tempDir
                        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
                        |> GrenTask.map (\_ -> exitCode)
                )
            |> GrenTask.andThen
                (\exitCode ->
                    if exitCode > 0 then
                        Node.setExitCode exitCode
                    else
                        GrenTask.succeed {}
                )
            |> Node.endSimpleProgram


{-| Get the secure context, converting the empty error type to Never.
    The error type is {} which can never actually be constructed,
    so we just need to satisfy the type system.
-}
getSecureContextOrCrash : Node.Environment -> GrenTask.Task Never SecureContext
getSecureContextOrCrash _ =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed - this should never happen")


type alias Context =
    { filesystemPermission : FileSystem.Permission
    , secureContext : SecureContext
    , tempDir : Path
    , stdout : Stream.Writable Bytes.Bytes
    }


type alias TestResult =
    { name : String
    , passed : Bool
    , message : String
    }


setupTempDir : FileSystem.Permission -> Path -> GrenTask.Task x {}
setupTempDir filesystemPermission tempDir =
    -- Remove existing temp dir if present, then create fresh
    FileSystem.remove filesystemPermission { recursive = True } tempDir
        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
        |> GrenTask.andThen (\_ -> FileSystem.makeDirectory filesystemPermission { recursive = True } tempDir)
        |> GrenTask.onError (\_ -> GrenTask.succeed tempDir)
        |> GrenTask.map (\_ -> {})


runAllTests : Context -> GrenTask.Task Never (Array TestResult)
runAllTests ctx =
    let
        tests =
            [ { name = "init creates registry directories"
              , run = testInitCreatesDirectories
              }
            , { name = "init creates registry.json"
              , run = testInitCreatesRegistryJson
              }
            , { name = "createTask creates task with UUID"
              , run = testCreateTaskCreatesTask
              }
            , { name = "createTask writes task.json"
              , run = testCreateTaskWritesTaskJson
              }
            , { name = "createTask writes queue.json"
              , run = testCreateTaskWritesQueueJson
              }
            , { name = "createTask writes history.json"
              , run = testCreateTaskWritesHistoryJson
              }
            , { name = "getTask returns created task"
              , run = testGetTaskReturnsTask
              }
            , { name = "getTask returns Nothing for missing task"
              , run = testGetTaskReturnsNothingForMissing
              }
            , { name = "updateTask modifies task status"
              , run = testUpdateTaskModifiesStatus
              }
            , { name = "listTasks returns all tasks"
              , run = testListTasksReturnsAll
              }
            , { name = "listTasks filters by status"
              , run = testListTasksFiltersByStatus
              }
            , { name = "recordEvent appends to history"
              , run = testRecordEventAppendsToHistory
              }
            -- Queue tests
            , { name = "enqueue adds message to queue"
              , run = testEnqueueAddsMessage
              }
            , { name = "dequeue returns messages in FIFO order"
              , run = testDequeueFIFO
              }
            , { name = "dequeue returns Nothing for empty queue"
              , run = testDequeueEmptyQueue
              }
            , { name = "peek returns message without removing"
              , run = testPeekDoesNotRemove
              }
            , { name = "isEmpty returns correct status"
              , run = testIsEmpty
              }
            , { name = "length returns correct count"
              , run = testQueueLength
              }
            , { name = "task summary includes currentAgent in registry index"
              , run = testTaskSummaryIncludesCurrentAgent
              }
            ]
    in
    tests
        |> Array.foldl
            (\test acc ->
                acc
                    |> GrenTask.andThen
                        (\results ->
                            runTest ctx test
                                |> GrenTask.map (\result -> Array.pushLast result results)
                        )
            )
            (GrenTask.succeed [])


runTest :
    Context
    -> { name : String, run : Context -> String -> GrenTask.Task String {} }
    -> GrenTask.Task Never TestResult
runTest ctx test =
    -- Each test gets a unique subdirectory
    let
        subdir =
            test.name
                |> String.replace " " "-"
                |> String.toLower
    in
    test.run ctx subdir
        |> GrenTask.map
            (\_ ->
                { name = test.name
                , passed = True
                , message = ""
                }
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    { name = test.name
                    , passed = False
                    , message = err
                    }
            )


reportResults : Context -> Array TestResult -> GrenTask.Task Never Int
reportResults ctx results =
    let
        passed =
            Array.keepIf .passed results
                |> Array.length

        failed =
            Array.keepIf (\r -> not r.passed) results
                |> Array.length

        failedTests =
            Array.keepIf (\r -> not r.passed) results

        summary =
            String.fromInt passed
                ++ " passed, "
                ++ String.fromInt failed
                ++ " failed"

        failureDetails =
            failedTests
                |> Array.map
                    (\r ->
                        "  FAIL: "
                            ++ r.name
                            ++ "\n    "
                            ++ r.message
                    )
                |> String.join "\n"

        output =
            if failed > 0 then
                "\n" ++ failureDetails ++ "\n\n" ++ summary ++ "\n"
            else
                summary ++ "\n"
    in
    Stream.writeLineAsBytes output ctx.stdout
        |> GrenTask.onError (\_ -> GrenTask.succeed ctx.stdout)
        |> GrenTask.map (\_ -> failed)



-- Test helpers


initRegistry : Context -> String -> GrenTask.Task String Registry
initRegistry ctx subdir =
    let
        -- Path.append prepends the second argument to the first
        -- so we need Path.append childPath parentPath to get parent/child
        registryRoot =
            Path.append (Path.fromPosixString (subdir ++ "/registry")) ctx.tempDir
    in
    Registry.init ctx.filesystemPermission ctx.secureContext
        { registryRoot = Path.toPosixString registryRoot
        }
        |> GrenTask.mapError Registry.errorToString



assertFileExists : FileSystem.Permission -> Path -> GrenTask.Task String {}
assertFileExists filesystemPermission path =
    FileSystem.checkAccess filesystemPermission [] path
        |> GrenTask.map (\_ -> {})
        |> GrenTask.mapError (\_ -> "File does not exist: " ++ Path.toPosixString path)


assertEqual : String -> a -> a -> GrenTask.Task String {}
assertEqual description expected actual =
    if expected == actual then
        GrenTask.succeed {}
    else
        GrenTask.fail (description ++ ": expected " ++ Debug.toString expected ++ " but got " ++ Debug.toString actual)


assertJust : String -> Maybe a -> GrenTask.Task String a
assertJust description maybeValue =
    when maybeValue is
        Just value ->
            GrenTask.succeed value

        Nothing ->
            GrenTask.fail (description ++ ": expected Just but got Nothing")


assertNothing : String -> Maybe a -> GrenTask.Task String {}
assertNothing description maybeValue =
    when maybeValue is
        Nothing ->
            GrenTask.succeed {}

        Just _ ->
            GrenTask.fail (description ++ ": expected Nothing but got Just")



-- Individual tests


testInitCreatesDirectories : Context -> String -> GrenTask.Task String {}
testInitCreatesDirectories ctx subdir =
    let
        registryRoot =
            Path.append (Path.fromPosixString (subdir ++ "/registry")) ctx.tempDir
    in
    initRegistry ctx subdir
        |> GrenTask.andThen (\_ -> assertFileExists ctx.filesystemPermission registryRoot)


testInitCreatesRegistryJson : Context -> String -> GrenTask.Task String {}
testInitCreatesRegistryJson ctx subdir =
    let
        registryJsonPath =
            Path.append (Path.fromPosixString (subdir ++ "/registry/registry.json")) ctx.tempDir
    in
    initRegistry ctx subdir
        |> GrenTask.andThen (\_ -> assertFileExists ctx.filesystemPermission registryJsonPath)


testCreateTaskCreatesTask : Context -> String -> GrenTask.Task String {}
testCreateTaskCreatesTask ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                -- UUID should be 36 characters (8-4-4-4-12 format)
                let
                    tidStr =
                        Id.taskIdToString (Types.taskId task)
                in
                if String.unitLength tidStr == 36 then
                    GrenTask.succeed {}
                else
                    GrenTask.fail ("Expected UUID to be 36 chars, got " ++ String.fromInt (String.unitLength tidStr))
            )


testCreateTaskWritesTaskJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesTaskJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Id.taskIdToString (Types.taskId task) ++ "/task.json")) ctx.tempDir
                in
                assertFileExists ctx.filesystemPermission taskJsonPath
            )


testCreateTaskWritesQueueJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesQueueJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    queueJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Id.taskIdToString (Types.taskId task) ++ "/queue.json")) ctx.tempDir
                in
                assertFileExists ctx.filesystemPermission queueJsonPath
            )


testCreateTaskWritesHistoryJson : Context -> String -> GrenTask.Task String {}
testCreateTaskWritesHistoryJson ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    historyJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Id.taskIdToString (Types.taskId task) ++ "/history.json")) ctx.tempDir
                in
                assertFileExists ctx.filesystemPermission historyJsonPath
            )


testGetTaskReturnsTask : Context -> String -> GrenTask.Task String {}
testGetTaskReturnsTask ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.getTask registry (Types.taskId task)
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.andThen (assertJust "getTask")
                    |> GrenTask.andThen
                        (\retrieved ->
                            assertEqual "task description" (Types.taskDescription task) (Types.taskDescription retrieved)
                        )
            )


testGetTaskReturnsNothingForMissing : Context -> String -> GrenTask.Task String {}
testGetTaskReturnsNothingForMissing ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                when Id.taskIdFromString "nonexistent-task-id" is
                    Nothing ->
                        GrenTask.fail "Could not create test TaskId"

                    Just fakeId ->
                        Registry.getTask registry fakeId
                            |> GrenTask.mapError Registry.errorToString
                            |> GrenTask.andThen (assertNothing "getTask for missing task")
            )


testUpdateTaskModifiesStatus : Context -> String -> GrenTask.Task String {}
testUpdateTaskModifiesStatus ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.updateStatus registry (Types.taskId task) Active
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\updatedTask ->
                when Types.taskStatus updatedTask is
                    Active ->
                        GrenTask.succeed {}

                    _ ->
                        GrenTask.fail ("Expected Active status, got " ++ Debug.toString (Types.taskStatus updatedTask))
            )


testListTasksReturnsAll : Context -> String -> GrenTask.Task String {}
testListTasksReturnsAll ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                -- Create two tasks
                Registry.createTask registry
                    { description = "Task 1"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Task 2"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.listTasks registry Nothing
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\tasks ->
                assertEqual "number of tasks" 2 (Array.length tasks)
            )


testListTasksFiltersByStatus : Context -> String -> GrenTask.Task String {}
testListTasksFiltersByStatus ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                -- Create a task and update it to Active
                Registry.createTask registry
                    { description = "Active Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.andThen
                        (\task ->
                            Registry.updateStatus registry (Types.taskId task) Active
                                |> GrenTask.mapError Registry.errorToString
                                |> GrenTask.map (\_ -> registry)
                        )
            )
        |> GrenTask.andThen
            (\registry ->
                -- Create a Pending task
                Registry.createTask registry
                    { description = "Pending Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\_ -> registry)
            )
        |> GrenTask.andThen
            (\registry ->
                Registry.listTasks registry (Just Active)
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\tasks ->
                assertEqual "number of Active tasks" 1 (Array.length tasks)
            )


testRecordEventAppendsToHistory : Context -> String -> GrenTask.Task String {}
testRecordEventAppendsToHistory ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                Registry.recordEvent registry (Types.taskId task)
                    { eventType = "test_event"
                    , data = Dict.singleton "key" "value"
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\_ -> task)
            )
        |> GrenTask.andThen
            (\task ->
                -- Read the history file and verify it has 2 events (created + test_event)
                let
                    historyPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Id.taskIdToString (Types.taskId task) ++ "/history.json")) ctx.tempDir
                in
                FileSystem.readFile ctx.filesystemPermission historyPath
                    |> GrenTask.mapError (\e -> "Failed to read history: " ++ FileSystem.errorToString e)
                    |> GrenTask.andThen
                        (\bytes ->
                            when Bytes.toString bytes is
                                Nothing ->
                                    GrenTask.fail "Could not decode history file as UTF-8"

                                Just content ->
                                    let
                                        eventsCountDecoder =
                                            Decode.field "events" (Decode.array (Decode.succeed {}))
                                                |> Decode.map Array.length
                                    in
                                    when Decode.decodeString eventsCountDecoder content is
                                        Ok count ->
                                            assertEqual "number of events" 2 count

                                        Err err ->
                                            GrenTask.fail ("Failed to decode history: " ++ Decode.errorToString err)
                        )
            )



-- Queue integration tests


{-| Helper to get the task directory path for queue operations.
-}
getTaskDir : Context -> String -> Id.TaskId -> Path
getTaskDir ctx subdir taskId =
    Path.append (Path.fromPosixString (subdir ++ "/registry/" ++ Id.taskIdToString taskId)) ctx.tempDir


queueErrorToString : Queue.Error -> String
queueErrorToString err =
    when err is
        Queue.FileSystemError msg ->
            "FileSystemError: " ++ msg

        Queue.JsonDecodeError msg ->
            "JsonDecodeError: " ++ msg

        Queue.TaskNotFound taskId ->
            "TaskNotFound: " ++ Id.taskIdToString taskId


testEnqueueAddsMessage : Context -> String -> GrenTask.Task String {}
testEnqueueAddsMessage ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Queue Test Task"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Types.taskId task)
                in
                Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir (Types.taskId task) "Hello, world!"
                    |> GrenTask.mapError queueErrorToString
            )
        |> GrenTask.andThen
            (\message ->
                -- Verify the message has a UUID (36 chars)
                let
                    msgIdStr =
                        Id.messageIdToString message.id
                in
                if String.unitLength msgIdStr == 36 then
                    assertEqual "message content" "Hello, world!" message.content
                else
                    GrenTask.fail ("Expected UUID to be 36 chars, got " ++ String.fromInt (String.unitLength msgIdStr))
            )


testDequeueFIFO : Context -> String -> GrenTask.Task String {}
testDequeueFIFO ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Queue FIFO Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskId =
                        Types.taskId task

                    taskDir =
                        getTaskDir ctx subdir taskId
                in
                -- Enqueue two messages
                Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "First message"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "Second message"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Dequeue first message
                Queue.dequeue ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected first message but got Nothing"

                                Just msg ->
                                    assertEqual "first message content" "First message" msg.content
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            -- Dequeue second message
                            Queue.dequeue ctx.filesystemPermission taskDir
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected second message but got Nothing"

                                Just msg ->
                                    assertEqual "second message content" "Second message" msg.content
                        )
            )


testDequeueEmptyQueue : Context -> String -> GrenTask.Task String {}
testDequeueEmptyQueue ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Empty Queue Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Types.taskId task)
                in
                Queue.dequeue ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertNothing "dequeue from empty queue")
            )


testPeekDoesNotRemove : Context -> String -> GrenTask.Task String {}
testPeekDoesNotRemove ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Peek Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskDir =
                        getTaskDir ctx subdir (Types.taskId task)
                in
                Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir (Types.taskId task) "Peek me"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Peek should return the message
                Queue.peek ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected message from peek but got Nothing"

                                Just msg ->
                                    assertEqual "peeked message content" "Peek me" msg.content
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            -- Peek again - should still return the same message (not removed)
                            Queue.peek ctx.filesystemPermission taskDir
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\maybeMsg ->
                            when maybeMsg is
                                Nothing ->
                                    GrenTask.fail "Expected message from second peek but got Nothing"

                                Just msg ->
                                    assertEqual "second peeked message content" "Peek me" msg.content
                        )
            )


testIsEmpty : Context -> String -> GrenTask.Task String {}
testIsEmpty ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "IsEmpty Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskId =
                        Types.taskId task

                    taskDir =
                        getTaskDir ctx subdir taskId
                in
                -- Should be empty initially
                Queue.isEmpty ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\empty ->
                            if empty then
                                GrenTask.succeed { taskDir = taskDir, taskId = taskId }
                            else
                                GrenTask.fail "Expected queue to be empty initially"
                        )
            )
        |> GrenTask.andThen
            (\{ taskDir, taskId } ->
                -- Add a message
                Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "Message"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Should not be empty now
                Queue.isEmpty ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\empty ->
                            if not empty then
                                GrenTask.succeed {}
                            else
                                GrenTask.fail "Expected queue to not be empty after enqueue"
                        )
            )


testQueueLength : Context -> String -> GrenTask.Task String {}
testQueueLength ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Length Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
            )
        |> GrenTask.andThen
            (\task ->
                let
                    taskId =
                        Types.taskId task

                    taskDir =
                        getTaskDir ctx subdir taskId
                in
                -- Should be 0 initially
                Queue.length ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertEqual "initial length" 0)
                    |> GrenTask.map (\_ -> { taskDir = taskDir, taskId = taskId })
            )
        |> GrenTask.andThen
            (\{ taskDir, taskId } ->
                -- Add 3 messages
                Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "One"
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "Two"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId "Three"
                                |> GrenTask.mapError queueErrorToString
                        )
                    |> GrenTask.map (\_ -> taskDir)
            )
        |> GrenTask.andThen
            (\taskDir ->
                -- Should be 3 now
                Queue.length ctx.filesystemPermission taskDir
                    |> GrenTask.mapError queueErrorToString
                    |> GrenTask.andThen (assertEqual "length after 3 enqueues" 3)
            )


testTaskSummaryIncludesCurrentAgent : Context -> String -> GrenTask.Task String {}
testTaskSummaryIncludesCurrentAgent ctx subdir =
    initRegistry ctx subdir
        |> GrenTask.andThen
            (\registry ->
                Registry.createTask registry
                    { description = "Summary Agent Test"
                    , source =
                        { sourceType = "test"
                        , userId = "tester"
                        , conversationId = Nothing
                        }
                    }
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\task -> { registry = registry, task = task })
            )
        |> GrenTask.andThen
            (\{ registry, task } ->
                -- Set currentAgent on the task
                Registry.updateTask registry (Types.taskId task)
                    (\t -> Types.setCurrentAgent (Just "developer") t)
                    |> GrenTask.mapError Registry.errorToString
                    |> GrenTask.map (\_ -> Types.taskId task)
            )
        |> GrenTask.andThen
            (\taskId ->
                -- Read registry.json and verify currentAgent appears in the summary
                let
                    registryJsonPath =
                        Path.append (Path.fromPosixString (subdir ++ "/registry/registry.json")) ctx.tempDir
                in
                FileSystem.readFile ctx.filesystemPermission registryJsonPath
                    |> GrenTask.mapError (\e -> "Failed to read registry.json: " ++ FileSystem.errorToString e)
                    |> GrenTask.andThen
                        (\bytes ->
                            when Bytes.toString bytes is
                                Nothing ->
                                    GrenTask.fail "Could not decode registry.json as UTF-8"

                                Just content ->
                                    let
                                        -- Decode the tasks array and find our task's currentAgent
                                        summaryDecoder =
                                            Decode.field "tasks"
                                                (Decode.array
                                                    (Decode.map2
                                                        (\id currentAgent -> { id = id, currentAgent = currentAgent })
                                                        (Decode.field "id" Decode.string)
                                                        (Decode.field "currentAgent" (Decode.maybe Decode.string))
                                                    )
                                                )
                                    in
                                    when Decode.decodeString summaryDecoder content is
                                        Err err ->
                                            GrenTask.fail ("Failed to decode registry.json: " ++ Decode.errorToString err)

                                        Ok summaries ->
                                            let
                                                taskIdStr =
                                                    Id.taskIdToString taskId

                                                matchingSummary =
                                                    Array.findFirst (\s -> s.id == taskIdStr) summaries
                                            in
                                            when matchingSummary is
                                                Nothing ->
                                                    GrenTask.fail "Task not found in registry.json summaries"

                                                Just { value } ->
                                                    assertEqual "currentAgent in summary" (Just "developer") value.currentAgent
                        )
            )
