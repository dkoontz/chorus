module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Agent.Registry as AgentRegistry
import Bytes
import ChildProcess
import Config exposing (Config)
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Init
import Json.Decode as Decode
import Json.Encode as Encode
import Logging exposing (LogLevel(..))
import Node
import Provider exposing (ProviderKind(..))
import Provider.ClaudeCode as ClaudeCode
import Provider.OpenAiCompat as OpenAiCompat
import Provider.OpenCode as OpenCode
import Stream
import Task as GrenTask
import Task.Registry as Registry
import Types exposing (TaskStatus(..), SourceInfo)
import Web.Api as Api
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static
import Web.ToolExecution as ToolExecution


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , agentRegistry : Maybe AgentRegistry.AgentRegistry
    , activeExecutors : Dict String ExecutorState
    , providerConfig : ClaudeCode.Config
    , filesystemPermission : FileSystem.Permission
    , childProcessPermission : ChildProcess.Permission
    , httpClientPermission : HttpClient.Permission
    , secureContext : SecureContext
    , config : Config
    , status : Status
    , pendingResponses : Array PendingResponse
    , logger : Logging.Logger
    }


{-| State of an active agent executor, keyed by task ID.
-}
type alias ExecutorState =
    { taskId : TaskId
    , agentName : String
    , agentConfig : Types.AgentConfig
    , status : ExecutorStatus
    , completionReportReceived : Bool
    }


{-| Status of an agent executor.
-}
type ExecutorStatus
    = ExecStarting
    | ExecRunning
    | ExecCompleted String
    | ExecFailed String


type alias PendingResponse =
    { response : Response
    , id : Int
    }


type Status
    = Initializing
    | Running
    | Error String


-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotAgentRegistry (Result AgentRegistry.Error AgentRegistry.AgentRegistry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | GotBinaryResult { response : Response, result : Api.BinaryResult }
    | GotToolAgentLookup { taskId : TaskId, requestBody : String, response : Response, result : Result String { agentConfig : Types.AgentConfig } }
    | GotAgentLookup { taskId : TaskId, prompt : String, response : Response, result : Result AgentRegistry.Error Types.AgentConfig }
    | GotHandoffRecorded { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig, apiResult : Api.ApiResult }
    | GotAgentComplete { taskId : TaskId, result : Result String String }
    | GotToolResult { taskId : TaskId, toolName : String, response : Response, result : Api.ApiResult }
    | GotInternalApiResult Api.ApiResult
    | GotTaskCreated { response : Response, taskId : TaskId, description : String, result : Api.ApiResult }
    | GotPlannerComplete { taskId : TaskId, result : Result String String }
    | GotAnswersSubmitted { response : Response, taskId : TaskId, enrichedPrompt : String, result : Api.ApiResult }
    | GotToolGrant { taskId : TaskId, addTools : Array String, removeTools : Array String, response : Response }
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \filesystemPermission ->
        Init.await ChildProcess.initialize <| \childProcessPermission ->
            Init.await HttpClient.initialize <| \httpClientPermission ->
                Init.awaitTask getSecureContext <| \secureContext ->
                    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                        Init.await HttpServer.initialize <| \httpPermission ->
                            let
                                baseDir =
                                    env.applicationPath
                                        |> Path.parentPath
                                        |> Maybe.map Path.toPosixString
                                        |> Maybe.withDefault "."

                                config =
                                    Config.configFromEnv baseDir envVars Config.defaultConfig

                                logger =
                                    Logging.makeLogger env.stdout config.logLevel

                                providerCfg =
                                    { childProcessPermission = childProcessPermission
                                    , chorusToolsPath = config.chorusToolsPath
                                    , baseUrl = "http://" ++ config.host ++ ":" ++ String.fromInt config.serverPort
                                    }

                                model =
                                    { env = env
                                    , server = Nothing
                                    , registry = Nothing
                                    , agentRegistry = Nothing
                                    , activeExecutors = Dict.empty
                                    , providerConfig = providerCfg
                                    , filesystemPermission = filesystemPermission
                                    , childProcessPermission = childProcessPermission
                                    , httpClientPermission = httpClientPermission
                                    , secureContext = secureContext
                                    , config = config
                                    , status = Initializing
                                    , pendingResponses = []
                                    , logger = logger
                                    }
                            in
                            Node.startProgram
                                { model = model
                                , command =
                                    Cmd.batch
                                        [ -- Initialize the HTTP server
                                          Server.createServer httpPermission
                                            { host = config.host
                                            , port_ = config.serverPort
                                            }
                                            |> GrenTask.attempt GotServer

                                        , -- Initialize the task registry
                                          Registry.init filesystemPermission secureContext
                                            { registryRoot = config.registryRoot
                                            , workspacesRoot = config.workspacesRoot
                                            }
                                            |> GrenTask.attempt GotRegistry

                                        , -- Initialize the agent registry
                                          AgentRegistry.init filesystemPermission
                                            { agentsRoot = config.agentsRoot
                                            }
                                            |> GrenTask.attempt GotAgentRegistry

                                        , -- Log startup
                                          Logging.logInfo logger ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.serverPort) NoOp
                                        ]
                                }



-- PROVIDER FACTORY


{-| Create a provider for the given agent configuration.

Dispatches based on the agent's `provider` field. Supports:
- "claude-code": CLI-based provider that spawns the claude CLI
- "opencode": CLI-based provider that spawns the opencode CLI
- "openai-compat": OpenAI-compatible API provider (OpenRouter, Ollama, etc.)

Returns Nothing if the provider name is not recognized.
-}
makeProvider : Model -> Types.AgentConfig -> Maybe (Provider.Provider Msg)
makeProvider model agentConfig =
    when agentConfig.provider is
        "claude-code" ->
            Just (ClaudeCode.provider model.providerConfig)

        "opencode" ->
            Just
                (OpenCode.provider
                    { childProcessPermission = model.childProcessPermission
                    , filesystemPermission = model.filesystemPermission
                    , chorusToolsPath = model.config.chorusToolsPath
                    , baseUrl = "http://" ++ model.config.host ++ ":" ++ String.fromInt model.config.serverPort
                    }
                )

        "openai-compat" ->
            Just
                (OpenAiCompat.provider
                    { httpClientPermission = model.httpClientPermission
                    , filesystemPermission = model.filesystemPermission
                    , secureContext = model.secureContext
                    , apiBaseUrl = model.config.apiBaseUrl
                    , apiKey = model.config.apiKey
                    , model = Maybe.withDefault model.config.defaultModel agentConfig.model
                    , conversationsDir = model.config.workspacesRoot ++ "/conversations"
                    }
                )

        _ ->
            Nothing



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = Logging.logInfo model.logger "HTTP server started" NoOp
                    }

                Err err ->
                    let
                        serverConfig =
                            { host = model.config.host
                            , port_ = model.config.serverPort
                            }

                        errMsg =
                            Server.errorToString serverConfig err
                    in
                    { model = { model | status = Error errMsg }
                    , command = Logging.logError model.logger ("Server error: " ++ errMsg) NoOp
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    { model =
                        { model
                            | registry = Just registry
                            , status = Running
                        }
                    , command = Logging.logInfo model.logger "Task registry initialized" NoOp
                    }

                Err err ->
                    { model = { model | status = Error (Registry.errorToString err) }
                    , command = Logging.logError model.logger ("Registry error: " ++ Registry.errorToString err) NoOp
                    }

        GotAgentRegistry result ->
            when result is
                Ok agentReg ->
                    { model = { model | agentRegistry = Just agentReg }
                    , command = Logging.logInfo model.logger "Agent registry initialized" NoOp
                    }

                Err err ->
                    { model = model
                    , command = Logging.logError model.logger ("Agent registry error: " ++ AgentRegistry.errorToString err) NoOp
                    }

        GotToolAgentLookup { taskId, requestBody, response, result } ->
            when result is
                Err errMsg ->
                    { model = model
                    , command = sendBadRequest response errMsg
                    }

                Ok { agentConfig } ->
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = Cmd.none
                            }

                        Just reg ->
                            let
                                toolCtx =
                                    { filesystemPermission = model.filesystemPermission
                                    , childProcessPermission = model.childProcessPermission
                                    , workspaceRoot = model.config.workspacesRoot ++ "/" ++ Id.taskIdToString taskId
                                    , allowedTools = agentConfig.allowedTools
                                    , apiContext =
                                        { registry = reg
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = Path.fromPosixString model.config.registryRoot
                                        }
                                    , taskId = taskId
                                    }

                                toolName =
                                    Decode.decodeString (Decode.field "tool" Decode.string) requestBody
                                        |> Result.withDefault "unknown"

                                toMsg =
                                    \apiResult -> GotToolResult { taskId = taskId, toolName = toolName, response = response, result = apiResult }
                            in
                            { model = model
                            , command = ToolExecution.requestExecuteTool toolCtx requestBody toMsg
                            }

        GotAgentLookup { taskId, prompt, response, result } ->
            when result is
                Err err ->
                    { model = model
                    , command = sendBadRequest response ("Agent registry error: " ++ AgentRegistry.errorToString err)
                    }

                Ok agentConfig ->
                    -- Agent found. Update the task first, then spawn the agent.
                    -- The HTTP response is sent via GotApiResult from requestStartHandoff.
                    -- The agent spawn happens via GotHandoffRecorded when the task update succeeds.
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response "Registry not available"
                            }

                        Just registry ->
                            let
                                ctx =
                                    { registry = registry
                                    , filesystemPermission = model.filesystemPermission
                                    , secureContext = model.secureContext
                                    , registryRoot = Path.fromPosixString model.config.registryRoot
                                    }

                                toMsg =
                                    \apiResult ->
                                        GotHandoffRecorded
                                            { taskId = taskId
                                            , prompt = prompt
                                            , response = response
                                            , agentConfig = agentConfig
                                            , apiResult = apiResult
                                            }
                            in
                            { model = model
                            , command =
                                Api.requestStartHandoff ctx taskId { agentName = agentConfig.name, prompt = prompt } toMsg
                            }

        GotHandoffRecorded { taskId, prompt, response, agentConfig, apiResult } ->
            -- The task update completed. Send the HTTP response first, then spawn the agent.
            let
                sendResponseCmd =
                    Api.sendApiResponse response apiResult
            in
            when apiResult is
                Api.ApiError _ ->
                    -- Task update failed (e.g., 409 conflict), just send the error response
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.ApiSuccess _ ->
                    -- Task updated successfully. Use inline instructions directly.
                    let
                        completionReportInstruction =
                            "\n\nIMPORTANT: Before finishing your work, you MUST call the completion-report tool to submit your results. Use: {\"tool\": \"completion-report\", \"status\": \"complete\", \"summary\": \"Brief summary of what was done\", \"output\": \"Detailed output\"}\nFor blocked work, use status \"blocked\" with a \"blockedReason\". For failures, use status \"failed\"."

                        systemPrompt =
                            if String.isEmpty agentConfig.instructions then
                                Just completionReportInstruction
                            else
                                Just (agentConfig.instructions ++ completionReportInstruction)

                        workspaceRoot =
                            model.config.workspacesRoot ++ "/" ++ Id.taskIdToString taskId

                        executorState =
                            { taskId = taskId
                            , agentName = agentConfig.name
                            , agentConfig = agentConfig
                            , status = ExecRunning
                            , completionReportReceived = False
                            }

                        cliArgs =
                            { systemPrompt = systemPrompt
                            , resumeSessionId = Nothing
                            , workspaceRoot = workspaceRoot
                            , chorusToolsPath = model.config.chorusToolsPath
                            , message = prompt
                            , allowedTools = Nothing
                            , taskId = Just (Id.taskIdToString taskId)
                            , baseUrl = Just model.providerConfig.baseUrl
                            }

                        shellCommand =
                            ClaudeCode.buildShellCommand cliArgs

                        options =
                            { shell = ChildProcess.NoShell
                            , workingDirectory = ChildProcess.InheritWorkingDirectory
                            , environmentVariables = ChildProcess.InheritEnvironmentVariables
                            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
                            , runDuration = ChildProcess.Milliseconds 600000
                            }
                    in
                    { model = { model | activeExecutors = Dict.set (Id.taskIdToString taskId) executorState model.activeExecutors }
                    , command =
                        Cmd.batch
                            [ sendResponseCmd
                            , ChildProcess.run model.childProcessPermission "bash" [ "-c", shellCommand ] options
                                |> GrenTask.map
                                    (\cliResult ->
                                        let
                                            output =
                                                cliResult.stdout
                                                    |> Bytes.toString
                                                    |> Maybe.withDefault ""

                                            -- Extract the result text from CLI JSON output
                                            resultText =
                                                when Decode.decodeString (Decode.field "result" Decode.string) output is
                                                    Ok text ->
                                                        text

                                                    Err _ ->
                                                        output
                                        in
                                        Ok resultText
                                    )
                                |> GrenTask.onError
                                    (\runError ->
                                        let
                                            errMsg =
                                                when runError is
                                                    ChildProcess.InitError { errorCode } ->
                                                        "Failed to start agent CLI: " ++ errorCode

                                                    ChildProcess.ProgramError { exitCode, stderr } ->
                                                        let
                                                            stderrStr =
                                                                stderr
                                                                    |> Bytes.toString
                                                                    |> Maybe.withDefault ""
                                                        in
                                                        "Agent CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                                        in
                                        GrenTask.succeed (Err errMsg)
                                    )
                                |> GrenTask.perform (\r -> GotAgentComplete { taskId = taskId, result = r })
                            , Logging.logInfo model.logger ("Spawned agent " ++ agentConfig.name ++ " for task " ++ Id.taskIdToString taskId) NoOp
                            ]
                    }

        GotAgentComplete { taskId, result } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId

                -- Check if completion report was already received
                hadCompletionReport =
                    Dict.get taskIdStr model.activeExecutors
                        |> Maybe.map .completionReportReceived
                        |> Maybe.withDefault False

                -- Remove executor from active
                updatedExecutors =
                    Dict.remove taskIdStr model.activeExecutors

                updatedModel =
                    { model | activeExecutors = updatedExecutors }
            in
            if hadCompletionReport then
                -- Completion report already handled status/output; just complete the handoff record timestamps
                when model.registry is
                    Nothing ->
                        { model = updatedModel
                        , command = Cmd.none
                        }

                    Just registry ->
                        let
                            ctx =
                                { registry = registry
                                , filesystemPermission = model.filesystemPermission
                                , secureContext = model.secureContext
                                , registryRoot = Path.fromPosixString model.config.registryRoot
                                }

                            rawOutput =
                                when result is
                                    Ok text ->
                                        text

                                    Err errMsg ->
                                        "Agent exited with error: " ++ errMsg
                        in
                        { model = updatedModel
                        , command =
                            Cmd.batch
                                [ Api.requestCompleteHandoff ctx taskId { output = rawOutput }
                                    (\apiResult -> GotInternalApiResult apiResult)
                                , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " (completion report received)") NoOp
                                ]
                        }
            else
                -- No completion report - fall back to raw output
                when result is
                    Ok outputText ->
                        when model.registry is
                            Nothing ->
                                { model = updatedModel
                                , command = Logging.logError model.logger "Agent completed but registry not available" NoOp
                                }

                            Just registry ->
                                let
                                    ctx =
                                        { registry = registry
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = Path.fromPosixString model.config.registryRoot
                                        }
                                in
                                { model = updatedModel
                                , command =
                                    Cmd.batch
                                        [ Api.requestCompleteHandoff ctx taskId { output = outputText }
                                            (\apiResult -> GotInternalApiResult apiResult)
                                        , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " without completion report (output length: " ++ String.fromInt (String.unitLength outputText) ++ ")") NoOp
                                        ]
                                }

                    Err errMsg ->
                        when model.registry is
                            Nothing ->
                                { model = updatedModel
                                , command = Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                }

                            Just registry ->
                                let
                                    ctx =
                                        { registry = registry
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = Path.fromPosixString model.config.registryRoot
                                        }
                                in
                                { model = updatedModel
                                , command =
                                    Cmd.batch
                                        [ Api.requestCompleteHandoff ctx taskId { output = "Agent failed: " ++ errMsg }
                                            (\apiResult -> GotInternalApiResult apiResult)
                                        , Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                        ]
                                }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            Logging.logDebug model.logger ("Request body: " ++ bodyStr) NoOp
            in
            { model = model
            , command =
                Cmd.batch
                    [ Logging.logInfo model.logger
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                        NoOp
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotToolResult { taskId, toolName, response, result } ->
            let
                status =
                    when result is
                        Api.ApiSuccess _ ->
                            "success"

                        Api.ApiError _ ->
                            "error"

                logCmd =
                    when model.registry is
                        Nothing ->
                            Cmd.none

                        Just reg ->
                            Registry.recordEvent reg taskId
                                { eventType = "tool_executed"
                                , data =
                                    Dict.empty
                                        |> Dict.set "tool" toolName
                                        |> Dict.set "status" status
                                }
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                |> GrenTask.perform (\_ -> NoOp)

                -- Track successful completion-report submissions
                updatedModel =
                    if toolName == "completion-report" && status == "success" then
                        let
                            taskIdStr =
                                Id.taskIdToString taskId

                            updatedExecutors =
                                when Dict.get taskIdStr model.activeExecutors is
                                    Just executor ->
                                        Dict.set taskIdStr { executor | completionReportReceived = True } model.activeExecutors

                                    Nothing ->
                                        model.activeExecutors
                        in
                        { model | activeExecutors = updatedExecutors }
                    else
                        model
            in
            { model = updatedModel
            , command =
                Cmd.batch
                    [ Api.sendApiResponse response result
                    , logCmd
                    ]
            }

        GotBinaryResult { response, result } ->
            { model = model
            , command = Api.sendBinaryResponse response result
            }

        GotInternalApiResult _ ->
            -- Internal API result from agent completion; no HTTP response to send
            { model = model
            , command = Cmd.none
            }

        GotTaskCreated { response, taskId, description, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess _ ->
                    -- Task created. Dispatch the _planner agent.
                    when model.agentRegistry is
                        Just agentReg ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , dispatchPlanner model agentReg taskId description
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

        GotPlannerComplete { taskId, result } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId
            in
            when model.registry is
                Nothing ->
                    { model = model, command = Cmd.none }

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , filesystemPermission = model.filesystemPermission
                            , secureContext = model.secureContext
                            , registryRoot = Path.fromPosixString model.config.registryRoot
                            }
                    in
                    when result is
                        Ok output ->
                            when parsePlannerOutput output is
                                PlanResult fields ->
                                    let
                                        mergeInto =
                                            \source target -> Dict.foldl Dict.set target source

                                        baseDict =
                                            Dict.empty
                                                |> Dict.set "summary" fields.summary
                                                |> mergeInto (indexedArrayToDict "requirement_" fields.requirements)
                                                |> mergeInto (indexedArrayToDict "acceptance_criteria_" fields.acceptanceCriteria)
                                                |> mergeInto (indexedArrayToDict "plan_step_" fields.plan)

                                        planningCompletedData =
                                            when fields.assignedAgent is
                                                Just agent ->
                                                    baseDict
                                                        |> Dict.set "assigned_agent" agent

                                                Nothing ->
                                                    baseDict
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestApplyPlan ctx taskId fields planningCompletedData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logInfo model.logger ("Planner produced plan for task " ++ taskIdStr) NoOp
                                            ]
                                    }

                                QuestionsResult questions ->
                                    let
                                        questionsEventData =
                                            indexedArrayToDict "question_" questions
                                                |> Dict.set "questionCount" (String.fromInt (Array.length questions))
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestSetQuestions ctx taskId questions questionsEventData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logInfo model.logger ("Planner asked " ++ String.fromInt (Array.length questions) ++ " questions for task " ++ taskIdStr) NoOp
                                            ]
                                    }

                                PlannerParseError errMsg ->
                                    let
                                        planningFailedEvent =
                                            Just
                                                { eventType = "planning_failed"
                                                , data =
                                                    Dict.empty
                                                        |> Dict.set "error" ("Planner output parse error: " ++ errMsg)
                                                }
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner output parse error: " ++ errMsg)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logError model.logger ("Planner parse error for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                            ]
                                    }

                        Err errMsg ->
                            let
                                planningFailedEvent =
                                    Just
                                        { eventType = "planning_failed"
                                        , data =
                                            Dict.empty
                                                |> Dict.set "error" ("Planner failed: " ++ errMsg)
                                        }
                            in
                            { model = model
                            , command =
                                Cmd.batch
                                    [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner failed: " ++ errMsg)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                    , Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                    ]
                            }

        GotAnswersSubmitted { response, taskId, enrichedPrompt, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess _ ->
                    when model.agentRegistry is
                        Just agentReg ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , dispatchPlanner model agentReg taskId enrichedPrompt
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

        GotToolGrant { taskId, addTools, removeTools, response } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId
            in
            when Dict.get taskIdStr model.activeExecutors is
                Nothing ->
                    { model = model
                    , command = sendBadRequest response ("No active executor for task: " ++ taskIdStr)
                    }

                Just executor ->
                    let
                        currentTools =
                            executor.agentConfig.allowedTools

                        withAdded =
                            Array.foldl
                                (\tool tools ->
                                    if Array.any (\t -> t == tool) tools then
                                        tools
                                    else
                                        Array.pushLast tool tools
                                )
                                currentTools
                                addTools

                        withRemoved =
                            Array.keepIf
                                (\tool ->
                                    not (Array.any (\r -> r == tool) removeTools)
                                )
                                withAdded

                        updatedConfig =
                            { agentConfig | allowedTools = withRemoved }

                        updatedExecutor =
                            { executor | agentConfig = updatedConfig }

                        updatedExecutors =
                            Dict.set taskIdStr updatedExecutor model.activeExecutors

                        agentConfig =
                            executor.agentConfig

                        responseBody =
                            Encode.object
                                [ { key = "allowedTools", value = Encode.array Encode.string withRemoved }
                                ]
                                |> Encode.encode 0
                    in
                    { model = { model | activeExecutors = updatedExecutors }
                    , command =
                        Cmd.batch
                            [ response
                                |> Response.setStatus 200
                                |> Response.setHeader "Content-Type" "application/json"
                                |> Response.setBody responseBody
                                |> Response.send
                            , Logging.logInfo model.logger ("Updated tools for task " ++ taskIdStr ++ ": " ++ String.join ", " withRemoved) NoOp
                            ]
                    }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { filesystemPermission = model.filesystemPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        _ ->
            -- API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , filesystemPermission = model.filesystemPermission
                            , secureContext = model.secureContext
                            , registryRoot = Path.fromPosixString model.config.registryRoot
                            }

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params
                                        (\apiResult ->
                                            let
                                                taskIdResult =
                                                    when apiResult is
                                                        Api.ApiSuccess { body } ->
                                                            Decode.decodeString (Decode.at [ "data", "id" ] Decode.string) body
                                                                |> Result.mapError Decode.errorToString
                                                                |> Result.andThen (\idStr ->
                                                                    when Id.taskIdFromString idStr is
                                                                        Just taskId -> Ok taskId
                                                                        Nothing -> Err "Invalid task ID"
                                                                )

                                                        _ ->
                                                            Err "Create failed"
                                            in
                                            when taskIdResult is
                                                Ok taskId ->
                                                    GotTaskCreated { response = response, taskId = taskId, description = params.description, result = apiResult }

                                                Err _ ->
                                                    GotApiResult { response = response, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status Nothing toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskPlanning taskId ->
                            when parseUpdatePlanningBody request is
                                Ok params ->
                                    Api.requestUpdatePlanning ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UploadAttachment { taskId, filename } ->
                            Api.requestUploadAttachment ctx taskId filename request.body model.config.uploadDir toMsg

                        Router.DownloadAttachment { taskId, filename } ->
                            let
                                toBinaryMsg =
                                    \binaryResult -> GotBinaryResult { response = response, result = binaryResult }
                            in
                            Api.requestDownloadAttachment ctx taskId filename model.config.uploadDir toBinaryMsg

                        Router.DeleteAttachment { taskId, filename } ->
                            Api.requestDeleteAttachment ctx taskId filename model.config.uploadDir toMsg

                        Router.ExecuteTool taskId ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendBadRequest response "Agent registry not initialized"

                                Just agentReg ->
                                    let
                                        bodyStr =
                                            Bytes.toString request.body
                                                |> Maybe.withDefault ""

                                        -- Look up task to find current agent, then look up agent config
                                        lookupTask =
                                            Registry.getTask registry taskId
                                                |> GrenTask.mapError (\err -> Registry.errorToString err)
                                                |> GrenTask.andThen
                                                    (\maybeTask ->
                                                        when maybeTask is
                                                            Nothing ->
                                                                GrenTask.fail ("Task not found: " ++ Id.taskIdToString taskId)

                                                            Just task ->
                                                                when Types.taskCurrentAgent task is
                                                                    Nothing ->
                                                                        GrenTask.fail "No agent currently active on this task"

                                                                    Just agentName ->
                                                                        AgentRegistry.getAgent agentReg agentName
                                                                            |> GrenTask.mapError (\err -> "Agent not found: " ++ AgentRegistry.errorToString err)
                                                                            |> GrenTask.map (\config -> { agentConfig = config })
                                                    )
                                    in
                                    lookupTask
                                        |> GrenTask.attempt
                                            (\result ->
                                                GotToolAgentLookup
                                                    { taskId = taskId
                                                    , requestBody = bodyStr
                                                    , response = response
                                                    , result = result
                                                    }
                                            )

                        Router.UpdateAgentTools taskId ->
                            when parseToolGrantBody request is
                                Ok params ->
                                    GrenTask.succeed {}
                                        |> GrenTask.perform
                                            (\_ ->
                                                GotToolGrant
                                                    { taskId = taskId
                                                    , addTools = params.addTools
                                                    , removeTools = params.removeTools
                                                    , response = response
                                                    }
                                            )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.SubmitAnswers taskId ->
                            when parseSubmitAnswersBody request is
                                Ok answers ->
                                    Api.requestSubmitAnswers ctx taskId answers
                                        (\{ apiResult, enrichedPrompt } ->
                                            GotAnswersSubmitted { response = response, taskId = taskId, enrichedPrompt = enrichedPrompt, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.StartHandoff taskId ->
                            when parseStartHandoffBody request is
                                Ok params ->
                                    when model.agentRegistry is
                                        Nothing ->
                                            sendBadRequest response "Agent registry not initialized"

                                        Just agentReg ->
                                            -- Look up the agent first; only update the task if the agent exists
                                            AgentRegistry.getAgent agentReg params.agentName
                                                |> GrenTask.attempt
                                                    (\result ->
                                                        GotAgentLookup
                                                            { taskId = taskId
                                                            , prompt = params.prompt
                                                            , response = response
                                                            , result = result
                                                            }
                                                    )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.CompleteHandoff taskId ->
                            when parseCompleteHandoffBody request is
                                Ok params ->
                                    Api.requestCompleteHandoff ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.ListAgents ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgents agentReg toMsg

                        Router.GetAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgent agentReg agentName toMsg

                        Router.CreateAgent ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestCreateAgent agentReg agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestUpdateAgent agentReg agentName agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestDeleteAgent agentReg agentName toMsg

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    let
        body =
            Encode.object
                [ { key = "error"
                  , value =
                        Encode.object
                            [ { key = "code", value = Encode.string "BAD_REQUEST" }
                            , { key = "message", value = Encode.string message }
                            ]
                  }
                ]
                |> Encode.encode 0
    in
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\description source ->
                    { description = description
                    , source = source
                    }
                )
                (Decode.field "description" Decode.string)
                (Decode.field "source" Types.sourceInfoDecoder)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.

    The frontend sends status as a nested object matching the encoding format:
    {"status": {"type": "active"}} or {"status": {"type": "failed", "message": "..."}}
    We also accept the flat format {"status": "active"} for backward compatibility
    with direct API callers.
-}
parseStatusBody : HttpServer.Request -> Result String TaskStatus
parseStatusBody request =
    let
        -- Nested object format: {"status": {"type": "active"}}
        nestedDecoder =
            Decode.field "status"
                (Decode.field "type" Decode.string
                    |> Decode.andThen
                        (\statusType ->
                            when statusType is
                                "pending" ->
                                    Decode.succeed Pending

                                "planning" ->
                                    Decode.succeed Planning

                                "awaiting_input" ->
                                    Decode.succeed AwaitingInput

                                "planned" ->
                                    Decode.succeed ReadyToStart

                                "active" ->
                                    Decode.succeed Active

                                "waiting" ->
                                    Decode.succeed Waiting

                                "completed" ->
                                    Decode.succeed Completed

                                "failed" ->
                                    Decode.oneOf
                                        [ Decode.field "message" Decode.string
                                            |> Decode.map Failed
                                        , Decode.succeed (Failed "")
                                        ]

                                _ ->
                                    Decode.fail ("Unknown status type: " ++ statusType)
                        )
                )

        -- Flat string format: {"status": "active"} (backward compatibility)
        flatDecoder =
            Decode.field "status" Decode.string
                |> Decode.andThen
                    (\statusStr ->
                        when statusStr is
                            "pending" ->
                                Decode.succeed Pending

                            "planning" ->
                                Decode.succeed Planning

                            "awaiting_input" ->
                                Decode.succeed AwaitingInput

                            "planned" ->
                                Decode.succeed ReadyToStart

                            "active" ->
                                Decode.succeed Active

                            "waiting" ->
                                Decode.succeed Waiting

                            "completed" ->
                                Decode.succeed Completed

                            "failed" ->
                                Decode.succeed (Failed "")

                            _ ->
                                Decode.fail ("Unknown status: " ++ statusStr)
                    )

        decoder =
            Decode.oneOf [ nestedDecoder, flatDecoder ]
    in
    when HttpServer.bodyFromJson decoder request is
        Ok status ->
            Ok status

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"


{-| Parse the body for PUT /api/tasks/:id/planning.
-}
parseUpdatePlanningBody : HttpServer.Request -> Result String Api.UpdatePlanningParams
parseUpdatePlanningBody request =
    let
        decoder =
            Decode.map4
                (\summary requirements acceptanceCriteria plan ->
                    { summary = summary
                    , requirements = requirements
                    , acceptanceCriteria = acceptanceCriteria
                    , plan = plan
                    }
                )
                (Decode.maybe (Decode.field "summary" Decode.string))
                (Decode.maybe (Decode.field "requirements" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "acceptanceCriteria" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "plan" (Decode.array Decode.string)))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for planning update"



{-| Parse the body for POST /api/tasks/:id/handoff.
-}
parseStartHandoffBody : HttpServer.Request -> Result String Api.StartHandoffParams
parseStartHandoffBody request =
    let
        decoder =
            Decode.map2
                (\agentName prompt ->
                    { agentName = agentName
                    , prompt = prompt
                    }
                )
                (Decode.field "agentName" Decode.string)
                (Decode.field "prompt" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff"


{-| Parse the body for PUT /api/tasks/:id/handoff/complete.
-}
parseCompleteHandoffBody : HttpServer.Request -> Result String Api.CompleteHandoffParams
parseCompleteHandoffBody request =
    let
        decoder =
            Decode.map (\output -> { output = output })
                (Decode.field "output" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff completion"


{-| Parse the body for POST /api/tasks/:id/answers.
-}
parseSubmitAnswersBody : HttpServer.Request -> Result String (Array String)
parseSubmitAnswersBody request =
    let
        decoder =
            Decode.field "answers" (Decode.array Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok answers ->
            Ok answers

        Err _ ->
            Err "Invalid JSON body for answer submission"


{-| Parse the body for PUT /api/tasks/:id/agent-tools.
-}
parseToolGrantBody : HttpServer.Request -> Result String { addTools : Array String, removeTools : Array String }
parseToolGrantBody request =
    let
        decoder =
            Decode.map2
                (\addTools removeTools ->
                    { addTools = addTools
                    , removeTools = removeTools
                    }
                )
                (Decode.maybe (Decode.field "addTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
                (Decode.maybe (Decode.field "removeTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for tool grant"


{-| Parse the body for POST /api/agents or PUT /api/agents/:name.
-}
parseAgentBody : HttpServer.Request -> Result String Types.AgentConfig
parseAgentBody request =
    when HttpServer.bodyFromJson Types.agentConfigDecoder request is
        Ok agentConfig ->
            Ok agentConfig

        Err _ ->
            Err "Invalid JSON body for agent config"


-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

        Nothing ->
            Sub.none



-- PLANNER


{-| Parsed output from the system planner agent.
-}
type PlannerOutput
    = PlanResult Types.PlanningFields
    | QuestionsResult (Array String)
    | PlannerParseError String


{-| Spawn the _planner agent for a newly created task.
-}
dispatchPlanner : Model -> AgentRegistry.AgentRegistry -> TaskId -> String -> Cmd Msg
dispatchPlanner model agentReg taskId description =
    AgentRegistry.getAgent agentReg "_planner"
        |> GrenTask.andThen
            (\agentConfig ->
                -- Set task status to Planning and record planning_started event
                when model.registry is
                    Nothing ->
                        GrenTask.succeed agentConfig

                    Just registry ->
                        Registry.updateStatus registry taskId Types.Planning
                            |> GrenTask.andThen
                                (\_ ->
                                    Registry.recordEvent registry taskId
                                        { eventType = "planning_started"
                                        , data =
                                            Dict.empty
                                                |> Dict.set "description" description
                                        }
                                        |> GrenTask.map (\_ -> agentConfig)
                                )
                            |> GrenTask.onError (\_ -> GrenTask.succeed agentConfig)
            )
        |> GrenTask.andThen
            (\agentConfig ->
                let
                    systemPrompt =
                        if String.isEmpty agentConfig.instructions then
                            Nothing
                        else
                            Just agentConfig.instructions

                    workspaceRoot =
                        model.config.workspacesRoot ++ "/" ++ Id.taskIdToString taskId

                    cliArgs =
                        { systemPrompt = systemPrompt
                        , resumeSessionId = Nothing
                        , workspaceRoot = workspaceRoot
                        , chorusToolsPath = model.config.chorusToolsPath
                        , message = description
                        , allowedTools = Nothing
                        , taskId = Just (Id.taskIdToString taskId)
                        , baseUrl = Just model.providerConfig.baseUrl
                        }

                    shellCommand =
                        ClaudeCode.buildShellCommand cliArgs

                    options =
                        { shell = ChildProcess.NoShell
                        , workingDirectory = ChildProcess.InheritWorkingDirectory
                        , environmentVariables = ChildProcess.InheritEnvironmentVariables
                        , maximumBytesWrittenToStreams = 10 * 1024 * 1024
                        , runDuration = ChildProcess.Milliseconds 300000
                        }
                in
                ChildProcess.run model.childProcessPermission "bash" [ "-c", shellCommand ] options
                    |> GrenTask.map
                        (\cliResult ->
                            let
                                output =
                                    cliResult.stdout
                                        |> Bytes.toString
                                        |> Maybe.withDefault ""

                                resultText =
                                    when Decode.decodeString (Decode.field "result" Decode.string) output is
                                        Ok text ->
                                            text

                                        Err _ ->
                                            output
                            in
                            Ok resultText
                        )
                    |> GrenTask.onError
                        (\runError ->
                            let
                                errMsg =
                                    when runError is
                                        ChildProcess.InitError { errorCode } ->
                                            "Failed to start planner CLI: " ++ errorCode

                                        ChildProcess.ProgramError { exitCode, stderr } ->
                                            let
                                                stderrStr =
                                                    stderr
                                                        |> Bytes.toString
                                                        |> Maybe.withDefault ""
                                            in
                                            "Planner CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                            in
                            GrenTask.succeed (Err errMsg)
                        )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (Err "_planner agent not found")
            )
        |> GrenTask.perform (\r -> GotPlannerComplete { taskId = taskId, result = r })


{-| Parse planner output. Extracts JSON from a code fence in the output.
-}
parsePlannerOutput : String -> PlannerOutput
parsePlannerOutput output =
    let
        -- Extract JSON from ```json ... ``` code fence
        jsonStr =
            extractJsonCodeFence output
    in
    when jsonStr is
        Nothing ->
            PlannerParseError "No JSON code fence found in planner output"

        Just json ->
            when Decode.decodeString (Decode.field "type" Decode.string) json is
                Err _ ->
                    PlannerParseError "Missing 'type' field in planner JSON"

                Ok planType ->
                    when planType is
                        "plan" ->
                            when Decode.decodeString planResultDecoder json is
                                Ok fields ->
                                    PlanResult fields

                                Err err ->
                                    PlannerParseError ("Invalid plan JSON: " ++ Decode.errorToString err)

                        "questions" ->
                            when Decode.decodeString questionsResultDecoder json is
                                Ok questions ->
                                    QuestionsResult questions

                                Err err ->
                                    PlannerParseError ("Invalid questions JSON: " ++ Decode.errorToString err)

                        _ ->
                            PlannerParseError ("Unknown planner output type: " ++ planType)


{-| Extract the first JSON code fence from text.
-}
extractJsonCodeFence : String -> Maybe String
extractJsonCodeFence text =
    let
        lines =
            String.split "\n" text

        findStart remainingLines =
            when Array.first remainingLines is
                Nothing ->
                    Nothing

                Just line ->
                    let
                        trimmed =
                            String.trim line
                    in
                    if trimmed == "```json" || trimmed == "```" then
                        findEnd (Array.dropFirst 1 remainingLines) []
                    else
                        findStart (Array.dropFirst 1 remainingLines)

        findEnd remainingLines acc =
            when Array.first remainingLines is
                Nothing ->
                    Nothing

                Just line ->
                    if String.trim line == "```" then
                        Just (String.join "\n" acc)
                    else
                        findEnd (Array.dropFirst 1 remainingLines) (Array.pushLast line acc)
    in
    findStart lines


planResultDecoder : Decode.Decoder Types.PlanningFields
planResultDecoder =
    Decode.map5
        (\summary requirements acceptanceCriteria plan assignedAgent ->
            { summary = summary
            , requirements = requirements
            , acceptanceCriteria = acceptanceCriteria
            , plan = plan
            , questions = []
            , assignedAgent = assignedAgent
            }
        )
        (Decode.field "summary" Decode.string)
        (Decode.field "requirements" (Decode.array Decode.string))
        (Decode.field "acceptanceCriteria" (Decode.array Decode.string))
        (Decode.field "plan" (Decode.array Decode.string))
        (Decode.maybe (Decode.field "assignedAgent" Decode.string))


questionsResultDecoder : Decode.Decoder (Array String)
questionsResultDecoder =
    Decode.field "questions" (Decode.array Decode.string)



-- HELPERS


{-| Convert an Array of strings into a Dict with numbered keys.
    `indexedArrayToDict "requirement_" ["A", "B"]` produces
    `Dict.fromArray [{ key = "requirement_1", value = "A" }, { key = "requirement_2", value = "B" }]`
-}
indexedArrayToDict : String -> Array String -> Dict String String
indexedArrayToDict prefix items =
    items
        |> Array.indexedMap
            (\i v ->
                { key = prefix ++ String.fromInt (i + 1)
                , value = v
                }
            )
        |> Array.foldl (\entry d -> Dict.set entry.key entry.value d) Dict.empty


{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")
