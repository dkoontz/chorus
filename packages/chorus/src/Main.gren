module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Agent.Registry as AgentRegistry
import Bytes
import ChildProcess
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Init
import Json.Decode as Decode
import Json.Encode as Encode
import Logging exposing (LogLevel(..))
import Node
import Provider.ClaudeCode as ClaudeCode
import Stream
import Task as GrenTask
import Task.Registry as Registry
import Types exposing (TaskStatus(..), SourceInfo)
import Web.Api as Api
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , agentRegistry : Maybe AgentRegistry.AgentRegistry
    , activeExecutors : Dict String ExecutorState
    , providerConfig : ClaudeCode.Config
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , secureContext : SecureContext
    , config : Config
    , status : Status
    , pendingResponses : Array PendingResponse
    , logger : Logging.Logger
    }


{-| State of an active agent executor, keyed by task ID.
-}
type alias ExecutorState =
    { taskId : TaskId
    , agentName : String
    , agentConfig : Types.AgentConfig
    , status : ExecutorStatus
    }


{-| Status of an agent executor.
-}
type ExecutorStatus
    = ExecStarting
    | ExecRunning
    | ExecCompleted String
    | ExecFailed String


type alias PendingResponse =
    { response : Response
    , id : Int
    }


type alias Config =
    { host : String
    , port_ : Int
    , registryRoot : String
    , workspacesRoot : String
    , staticRoot : String
    , uploadDir : String
    , agentsRoot : String
    , fileToolsPath : String
    , logLevel : LogLevel
    }


type Status
    = Initializing
    | Running
    | Error String


defaultConfig : Config
defaultConfig =
    { host = "0.0.0.0"
    , port_ = 8080
    , registryRoot = "./data/registry"
    , workspacesRoot = "./data/workspaces"
    , staticRoot = "./static"
    , uploadDir = "./data/uploads"
    , agentsRoot = "./data/agents"
    , fileToolsPath = "./tools/file-tools"
    , logLevel = LogInfo
    }


{-| Create configuration from environment variables.

    Supported environment variables:
    - CHORUS_HOST: Server host (default: 0.0.0.0)
    - CHORUS_PORT: Server port (default: 8080)
    - CHORUS_DATA_DIR: Base data directory (default: ./data)
    - CHORUS_STATIC_DIR: Static files directory (default: ./static)
    - CHORUS_LOG_LEVEL: Log level - error, warn, info, debug (default: info)

-}
configFromEnv : Dict String String -> Config -> Config
configFromEnv envVars config =
    let
        host =
            Dict.get "CHORUS_HOST" envVars
                |> Maybe.withDefault config.host

        port_ =
            Dict.get "CHORUS_PORT" envVars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault config.port_

        dataDir =
            Dict.get "CHORUS_DATA_DIR" envVars
                |> Maybe.withDefault "./data"

        staticRoot =
            Dict.get "CHORUS_STATIC_DIR" envVars
                |> Maybe.withDefault config.staticRoot

        logLevel =
            Dict.get "CHORUS_LOG_LEVEL" envVars
                |> Maybe.andThen Logging.parseLogLevel
                |> Maybe.withDefault config.logLevel

        uploadDir =
            Dict.get "CHORUS_UPLOAD_DIR" envVars
                |> Maybe.withDefault (dataDir ++ "/uploads")
    in
    { host = host
    , port_ = port_
    , registryRoot = dataDir ++ "/registry"
    , workspacesRoot = dataDir ++ "/workspaces"
    , staticRoot = staticRoot
    , uploadDir = uploadDir
    , agentsRoot = dataDir ++ "/agents"
    , fileToolsPath = Dict.get "CHORUS_FILE_TOOLS_PATH" envVars |> Maybe.withDefault config.fileToolsPath
    , logLevel = logLevel
    }


-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotAgentRegistry (Result AgentRegistry.Error AgentRegistry.AgentRegistry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | GotBinaryResult { response : Response, result : Api.BinaryResult }
    | GotAgentLookup { taskId : TaskId, prompt : String, response : Response, result : Result AgentRegistry.Error Types.AgentConfig }
    | GotHandoffRecorded { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig, apiResult : Api.ApiResult }
    | GotAgentComplete { taskId : TaskId, result : Result String String }
    | GotInternalApiResult Api.ApiResult
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
        Init.await ChildProcess.initialize <| \cpPermission ->
            Init.awaitTask getSecureContext <| \secureContext ->
                Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                    Init.await HttpServer.initialize <| \httpPermission ->
                        let
                            config =
                                configFromEnv envVars defaultConfig

                            logger =
                                Logging.makeLogger env.stdout config.logLevel

                            providerCfg =
                                { childProcessPermission = cpPermission
                                , fileToolsPath = config.fileToolsPath
                                }

                            model =
                                { env = env
                                , server = Nothing
                                , registry = Nothing
                                , agentRegistry = Nothing
                                , activeExecutors = Dict.empty
                                , providerConfig = providerCfg
                                , fsPermission = fsPermission
                                , cpPermission = cpPermission
                                , secureContext = secureContext
                                , config = config
                                , status = Initializing
                                , pendingResponses = []
                                , logger = logger
                                }
                        in
                        Node.startProgram
                            { model = model
                            , command =
                                Cmd.batch
                                    [ -- Initialize the HTTP server
                                      Server.createServer httpPermission
                                        { host = config.host
                                        , port_ = config.port_
                                        }
                                        |> GrenTask.attempt GotServer

                                    , -- Initialize the task registry
                                      Registry.init fsPermission secureContext
                                        { registryRoot = config.registryRoot
                                        , workspacesRoot = config.workspacesRoot
                                        }
                                        |> GrenTask.attempt GotRegistry

                                    , -- Initialize the agent registry
                                      AgentRegistry.init fsPermission
                                        { agentsRoot = config.agentsRoot
                                        }
                                        |> GrenTask.attempt GotAgentRegistry

                                    , -- Log startup
                                      Logging.logInfo logger ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.port_) NoOp
                                    ]
                            }



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = Logging.logInfo model.logger "HTTP server started" NoOp
                    }

                Err err ->
                    { model = { model | status = Error (Server.errorToString err) }
                    , command = Logging.logError model.logger ("Server error: " ++ Server.errorToString err) NoOp
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    { model =
                        { model
                            | registry = Just registry
                            , status = Running
                        }
                    , command = Logging.logInfo model.logger "Task registry initialized" NoOp
                    }

                Err err ->
                    { model = { model | status = Error (Registry.errorToString err) }
                    , command = Logging.logError model.logger ("Registry error: " ++ Registry.errorToString err) NoOp
                    }

        GotAgentRegistry result ->
            when result is
                Ok agentReg ->
                    { model = { model | agentRegistry = Just agentReg }
                    , command = Logging.logInfo model.logger "Agent registry initialized" NoOp
                    }

                Err err ->
                    { model = model
                    , command = Logging.logError model.logger ("Agent registry error: " ++ AgentRegistry.errorToString err) NoOp
                    }

        GotAgentLookup { taskId, prompt, response, result } ->
            when result is
                Err err ->
                    { model = model
                    , command = sendBadRequest response ("Agent registry error: " ++ AgentRegistry.errorToString err)
                    }

                Ok agentConfig ->
                    -- Agent found. Update the task first, then spawn the agent.
                    -- The HTTP response is sent via GotApiResult from requestStartHandoff.
                    -- The agent spawn happens via GotHandoffRecorded when the task update succeeds.
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response "Registry not available"
                            }

                        Just registry ->
                            let
                                ctx =
                                    { registry = registry
                                    , fsPermission = model.fsPermission
                                    , secureContext = model.secureContext
                                    , registryRoot = Path.fromPosixString model.config.registryRoot
                                    }

                                toMsg =
                                    \apiResult ->
                                        GotHandoffRecorded
                                            { taskId = taskId
                                            , prompt = prompt
                                            , response = response
                                            , agentConfig = agentConfig
                                            , apiResult = apiResult
                                            }
                            in
                            { model = model
                            , command =
                                Api.requestStartHandoff ctx taskId { agentName = agentConfig.name, prompt = prompt } toMsg
                            }

        GotHandoffRecorded { taskId, prompt, response, agentConfig, apiResult } ->
            -- The task update completed. Send the HTTP response first, then spawn the agent.
            let
                sendResponseCmd =
                    Api.sendApiResponse response apiResult
            in
            when apiResult is
                Api.ApiError _ ->
                    -- Task update failed (e.g., 409 conflict), just send the error response
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.ApiSuccess _ ->
                    -- Task updated successfully. Use inline instructions directly.
                    let
                        systemPrompt =
                            if String.isEmpty agentConfig.instructions then
                                Nothing
                            else
                                Just agentConfig.instructions

                        workspaceRoot =
                            model.config.workspacesRoot ++ "/" ++ Id.taskIdToString taskId

                        executorState =
                            { taskId = taskId
                            , agentName = agentConfig.name
                            , agentConfig = agentConfig
                            , status = ExecRunning
                            }

                        cliArgs =
                            { systemPrompt = systemPrompt
                            , resumeSessionId = Nothing
                            , workspaceRoot = workspaceRoot
                            , fileToolsPath = model.config.fileToolsPath
                            , message = prompt
                            , allowedTools = Just (String.join " " agentConfig.allowedTools)
                            }

                        shellCommand =
                            ClaudeCode.buildShellCommand cliArgs

                        options =
                            { shell = ChildProcess.NoShell
                            , workingDirectory = ChildProcess.InheritWorkingDirectory
                            , environmentVariables = ChildProcess.InheritEnvironmentVariables
                            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
                            , runDuration = ChildProcess.Milliseconds 600000
                            }
                    in
                    { model = { model | activeExecutors = Dict.set (Id.taskIdToString taskId) executorState model.activeExecutors }
                    , command =
                        Cmd.batch
                            [ sendResponseCmd
                            , ChildProcess.run model.cpPermission "bash" [ "-c", shellCommand ] options
                                |> GrenTask.map
                                    (\cliResult ->
                                        let
                                            output =
                                                cliResult.stdout
                                                    |> Bytes.toString
                                                    |> Maybe.withDefault ""

                                            -- Extract the result text from CLI JSON output
                                            resultText =
                                                when Decode.decodeString (Decode.field "result" Decode.string) output is
                                                    Ok text ->
                                                        text

                                                    Err _ ->
                                                        output
                                        in
                                        Ok resultText
                                    )
                                |> GrenTask.onError
                                    (\runError ->
                                        let
                                            errMsg =
                                                when runError is
                                                    ChildProcess.InitError { errorCode } ->
                                                        "Failed to start agent CLI: " ++ errorCode

                                                    ChildProcess.ProgramError { exitCode, stderr } ->
                                                        let
                                                            stderrStr =
                                                                stderr
                                                                    |> Bytes.toString
                                                                    |> Maybe.withDefault ""
                                                        in
                                                        "Agent CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                                        in
                                        GrenTask.succeed (Err errMsg)
                                    )
                                |> GrenTask.perform (\r -> GotAgentComplete { taskId = taskId, result = r })
                            , Logging.logInfo model.logger ("Spawned agent " ++ agentConfig.name ++ " for task " ++ Id.taskIdToString taskId) NoOp
                            ]
                    }

        GotAgentComplete { taskId, result } ->
            let
                -- Remove executor from active
                updatedExecutors =
                    Dict.remove (Id.taskIdToString taskId) model.activeExecutors

                updatedModel =
                    { model | activeExecutors = updatedExecutors }
            in
            when result is
                Ok outputText ->
                    when model.registry is
                        Nothing ->
                            { model = updatedModel
                            , command = Logging.logError model.logger "Agent completed but registry not available" NoOp
                            }

                        Just registry ->
                            let
                                ctx =
                                    { registry = registry
                                    , fsPermission = model.fsPermission
                                    , secureContext = model.secureContext
                                    , registryRoot = Path.fromPosixString model.config.registryRoot
                                    }
                            in
                            { model = updatedModel
                            , command =
                                Cmd.batch
                                    [ Api.requestCompleteHandoff ctx taskId { output = outputText }
                                        (\apiResult -> GotInternalApiResult apiResult)
                                    , Logging.logInfo model.logger ("Agent completed for task " ++ Id.taskIdToString taskId ++ " (output length: " ++ String.fromInt (String.unitLength outputText) ++ ")") NoOp
                                    ]
                            }

                Err errMsg ->
                    when model.registry is
                        Nothing ->
                            { model = updatedModel
                            , command = Logging.logError model.logger ("Agent failed for task " ++ Id.taskIdToString taskId ++ ": " ++ errMsg) NoOp
                            }

                        Just registry ->
                            let
                                ctx =
                                    { registry = registry
                                    , fsPermission = model.fsPermission
                                    , secureContext = model.secureContext
                                    , registryRoot = Path.fromPosixString model.config.registryRoot
                                    }
                            in
                            { model = updatedModel
                            , command =
                                Cmd.batch
                                    [ Api.requestCompleteHandoff ctx taskId { output = "Agent failed: " ++ errMsg }
                                        (\apiResult -> GotInternalApiResult apiResult)
                                    , Logging.logError model.logger ("Agent failed for task " ++ Id.taskIdToString taskId ++ ": " ++ errMsg) NoOp
                                    ]
                            }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            Logging.logDebug model.logger ("Request body: " ++ bodyStr) NoOp
            in
            { model = model
            , command =
                Cmd.batch
                    [ Logging.logInfo model.logger
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                        NoOp
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotBinaryResult { response, result } ->
            { model = model
            , command = Api.sendBinaryResponse response result
            }

        GotInternalApiResult _ ->
            -- Internal API result from agent completion; no HTTP response to send
            { model = model
            , command = Cmd.none
            }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { fsPermission = model.fsPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        _ ->
            -- API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , fsPermission = model.fsPermission
                            , secureContext = model.secureContext
                            , registryRoot = Path.fromPosixString model.config.registryRoot
                            }

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskPlanning taskId ->
                            when parseUpdatePlanningBody request is
                                Ok params ->
                                    Api.requestUpdatePlanning ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UploadAttachment { taskId, filename } ->
                            Api.requestUploadAttachment ctx taskId filename request.body model.config.uploadDir toMsg

                        Router.DownloadAttachment { taskId, filename } ->
                            let
                                toBinaryMsg =
                                    \binaryResult -> GotBinaryResult { response = response, result = binaryResult }
                            in
                            Api.requestDownloadAttachment ctx taskId filename model.config.uploadDir toBinaryMsg

                        Router.DeleteAttachment { taskId, filename } ->
                            Api.requestDeleteAttachment ctx taskId filename model.config.uploadDir toMsg

                        Router.StartHandoff taskId ->
                            when parseStartHandoffBody request is
                                Ok params ->
                                    when model.agentRegistry is
                                        Nothing ->
                                            sendBadRequest response "Agent registry not initialized"

                                        Just agentReg ->
                                            -- Look up the agent first; only update the task if the agent exists
                                            AgentRegistry.getAgent agentReg params.agentName
                                                |> GrenTask.attempt
                                                    (\result ->
                                                        GotAgentLookup
                                                            { taskId = taskId
                                                            , prompt = params.prompt
                                                            , response = response
                                                            , result = result
                                                            }
                                                    )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.CompleteHandoff taskId ->
                            when parseCompleteHandoffBody request is
                                Ok params ->
                                    Api.requestCompleteHandoff ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.ListAgents ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgents agentReg toMsg

                        Router.GetAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgent agentReg agentName toMsg

                        Router.CreateAgent ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestCreateAgent agentReg agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestUpdateAgent agentReg agentName agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestDeleteAgent agentReg agentName toMsg

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    let
        body =
            Encode.object
                [ { key = "error"
                  , value =
                        Encode.object
                            [ { key = "code", value = Encode.string "BAD_REQUEST" }
                            , { key = "message", value = Encode.string message }
                            ]
                  }
                ]
                |> Encode.encode 0
    in
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\description source ->
                    { description = description
                    , source = source
                    }
                )
                (Decode.field "description" Decode.string)
                (Decode.field "source" Types.sourceInfoDecoder)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.

    The frontend sends status as a nested object matching the encoding format:
    {"status": {"type": "active"}} or {"status": {"type": "failed", "message": "..."}}
    We also accept the flat format {"status": "active"} for backward compatibility
    with direct API callers.
-}
parseStatusBody : HttpServer.Request -> Result String TaskStatus
parseStatusBody request =
    let
        -- Nested object format: {"status": {"type": "active"}}
        nestedDecoder =
            Decode.field "status"
                (Decode.field "type" Decode.string
                    |> Decode.andThen
                        (\statusType ->
                            when statusType is
                                "pending" ->
                                    Decode.succeed Pending

                                "planning" ->
                                    Decode.succeed Planning

                                "awaiting_input" ->
                                    Decode.succeed AwaitingInput

                                "planned" ->
                                    Decode.succeed ReadyToStart

                                "active" ->
                                    Decode.succeed Active

                                "waiting" ->
                                    Decode.succeed Waiting

                                "completed" ->
                                    Decode.succeed Completed

                                "failed" ->
                                    Decode.oneOf
                                        [ Decode.field "message" Decode.string
                                            |> Decode.map Failed
                                        , Decode.succeed (Failed "")
                                        ]

                                _ ->
                                    Decode.fail ("Unknown status type: " ++ statusType)
                        )
                )

        -- Flat string format: {"status": "active"} (backward compatibility)
        flatDecoder =
            Decode.field "status" Decode.string
                |> Decode.andThen
                    (\statusStr ->
                        when statusStr is
                            "pending" ->
                                Decode.succeed Pending

                            "planning" ->
                                Decode.succeed Planning

                            "awaiting_input" ->
                                Decode.succeed AwaitingInput

                            "planned" ->
                                Decode.succeed ReadyToStart

                            "active" ->
                                Decode.succeed Active

                            "waiting" ->
                                Decode.succeed Waiting

                            "completed" ->
                                Decode.succeed Completed

                            "failed" ->
                                Decode.succeed (Failed "")

                            _ ->
                                Decode.fail ("Unknown status: " ++ statusStr)
                    )

        decoder =
            Decode.oneOf [ nestedDecoder, flatDecoder ]
    in
    when HttpServer.bodyFromJson decoder request is
        Ok status ->
            Ok status

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"


{-| Parse the body for PUT /api/tasks/:id/planning.
-}
parseUpdatePlanningBody : HttpServer.Request -> Result String Api.UpdatePlanningParams
parseUpdatePlanningBody request =
    let
        decoder =
            Decode.map4
                (\summary requirements acceptanceCriteria plan ->
                    { summary = summary
                    , requirements = requirements
                    , acceptanceCriteria = acceptanceCriteria
                    , plan = plan
                    }
                )
                (Decode.maybe (Decode.field "summary" Decode.string))
                (Decode.maybe (Decode.field "requirements" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "acceptanceCriteria" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "plan" (Decode.array Decode.string)))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for planning update"



{-| Parse the body for POST /api/tasks/:id/handoff.
-}
parseStartHandoffBody : HttpServer.Request -> Result String Api.StartHandoffParams
parseStartHandoffBody request =
    let
        decoder =
            Decode.map2
                (\agentName prompt ->
                    { agentName = agentName
                    , prompt = prompt
                    }
                )
                (Decode.field "agentName" Decode.string)
                (Decode.field "prompt" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff"


{-| Parse the body for PUT /api/tasks/:id/handoff/complete.
-}
parseCompleteHandoffBody : HttpServer.Request -> Result String Api.CompleteHandoffParams
parseCompleteHandoffBody request =
    let
        decoder =
            Decode.map (\output -> { output = output })
                (Decode.field "output" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff completion"


{-| Parse the body for POST /api/agents or PUT /api/agents/:name.
-}
parseAgentBody : HttpServer.Request -> Result String Types.AgentConfig
parseAgentBody request =
    when HttpServer.bodyFromJson Types.agentConfigDecoder request is
        Ok agentConfig ->
            Ok agentConfig

        Err _ ->
            Err "Invalid JSON body for agent config"


-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

        Nothing ->
            Sub.none



-- HELPERS



{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")
