module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Agent.Executor as Executor
import Agent.Manager as AgentManager
import Agent.Registry as AgentRegistry
import Agent.ToolContext exposing (toolContextForAgent)
import Bytes
import ChildProcess
import Config exposing (Config)
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Init
import Json.Decode as Decode
import Json.Encode as Encode
import Logging exposing (LogLevel(..))
import Node
import Provider exposing (ProviderKind(..))
import Provider.ClaudeCode as ClaudeCode
import Provider.OpenCode as OpenCode
import Provider.Registry as ProviderRegistry
import Stream
import Time
import Task as GrenTask
import Task.Registry as Registry
import Types exposing (AgentConfig(..), AgentProvider(..), EventType(..), PlannerOutput(..), ProviderType(..), TaskStatus(..), SourceInfo, WorkspaceConfig)
import Web.Api as Api exposing (indexedArrayToDict)
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static
import Web.ToolExecution as ToolExecution
import WebSocketServer
import WebSocketServer.Connection as WsConnection


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , agentRegistry : Maybe AgentRegistry.AgentRegistry
    , providerRegistry : Maybe ProviderRegistry.ProviderRegistry
    , activeExecutors : Dict String ExecutorState
    , filesystemPermission : FileSystem.Permission
    , childProcessPermission : ChildProcess.Permission
    , httpClientPermission : HttpClient.Permission
    , secureContext : SecureContext
    , config : Config
    , workspaceConfig : Maybe WorkspaceConfig
    , workspaceConfigPath : Maybe String
    , status : Status
    , pendingConfigResponse : Maybe PendingConfigResponse
    , logger : Logging.Logger
    , cliPort : Maybe Int
    , websocketServer : Maybe WebSocketServer.Server
    , websocketClients : Dict Int WebSocketServer.Connection
    , workspacesPath : String
    }


{-| State of an agent executor, keyed by task ID.

Lifecycle phases are encoded as union variants:

- `Spawning`: Provider is resolving asynchronously. No agent process is running.
  Tool calls arriving in this state are rejected.
- `AgentActive`: Provider is resolved and agent is running. Tool calls are routed
  through the provider.
- `ActiveHandoff`: Same as AgentActive but this agent was spawned via a deferred
  handoff. Carries the HTTP response handle that must be resolved when the
  agent completes.

-}
type ExecutorState
    = Spawning SpawningExecutor
    | AgentActive ActiveExecutor
    | ActiveHandoff { executor : ActiveExecutor, deferredResponse : Response }


{-| Fields present while the provider is still resolving.

The `deferredResponse` field carries the HTTP response handle for deferred
handoffs. When the provider resolves and the executor transitions to AgentActive,
the presence of this field determines whether the state becomes `AgentActive`
or `ActiveHandoff`.
-}
type alias SpawningExecutor =
    { taskId : TaskId
    , agentName : String
    , agentConfig : Types.AgentConfig
    , agentKind : AgentKind
    , deferredResponse : Maybe Response
    }


{-| Fields present when the agent is actively running.
-}
type alias ActiveExecutor =
    { taskId : TaskId
    , agentName : String
    , agentConfig : Types.AgentConfig
    , agentKind : AgentKind
    , executorModel : Executor.Model
    , providerState : Provider.ProviderState
    , provider : Provider.Provider Msg
    , retryCount : Int
    , sessionId : Maybe String
    }


{-| Whether an executor is running a system agent (planner) or a user-defined agent.
-}
type AgentKind
    = SystemAgent
    | UserAgent


type alias PendingConfigResponse =
    { response : Response
    , config : WorkspaceConfig
    , configPath : String
    }


type Status
    = Initializing
    | Running
    | Error String


-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotAgentRegistry (Result AgentRegistry.Error AgentRegistry.AgentRegistry)
    | GotProviderRegistry (Result ProviderRegistry.Error ProviderRegistry.ProviderRegistry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | GotBinaryResult { response : Response, result : Api.BinaryResult }
    | GotToolAgentLookup { taskId : TaskId, requestBody : String, response : Response, result : Result String { agentConfig : Types.AgentConfig } }
    | GotAgentLookup { taskId : TaskId, prompt : String, response : Response, result : Result AgentRegistry.Error Types.AgentConfig }
    | GotHandoffRecorded { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig, apiResult : Api.ApiResult }
    | GotDeferredHandoffLookup { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig }
    | GotDeferredHandoffStarted { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig, apiResult : Api.ApiResult }
    | GotAgentComplete { taskId : TaskId, result : Result String String }
    | GotToolResult { taskId : TaskId, toolName : String, requestBody : String, response : Response, result : Api.ApiResult }
    | GotProviderEvent { taskId : TaskId, event : Provider.ProviderEvent }
    | GotExecutorMsg { taskId : TaskId, msg : Executor.Msg }
    | GotProviderResolved { taskId : TaskId, prompt : String, agentConfig : Types.AgentConfig, providerConfig : Types.ProviderConfig, isSystemAgent : Bool }
    | GotInternalApiResult Api.ApiResult
    | GotMutatingApiResult { broadcastType : String, response : Response, result : Api.ApiResult }
    | GotTaskCreated { response : Response, taskId : TaskId, description : String, result : Api.ApiResult }
    | GotPlanTaskResult { response : Response, taskId : TaskId, description : String, result : Api.ApiResult }
    | GotAnswersSubmitted { response : Response, taskId : TaskId, enrichedPrompt : String, result : Api.ApiResult }
    | GotToolGrant { taskId : TaskId, addTools : Array String, removeTools : Array String, response : Response }
    | GotConfigLoaded { response : Maybe Response, deferResponse : Bool, result : Result String { config : WorkspaceConfig, configPath : String } }
    | GotWebSocketServer (Result WebSocketServer.ServerError WebSocketServer.Server)
    | WsClientConnected WebSocketServer.Connection
    | WsClientDisconnected { connection : WebSocketServer.Connection, reason : WebSocketServer.CloseReason }
    | WsClientError { connection : WebSocketServer.Connection, error : String }
    | WsBroadcastResult (Result WsConnection.Error {})
    | GotWorkspaceRecorded (Result String {})
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \filesystemPermission ->
        Init.await ChildProcess.initialize <| \childProcessPermission ->
            Init.await HttpClient.initialize <| \httpClientPermission ->
                Init.awaitTask getSecureContext <| \secureContext ->
                    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                        Init.await HttpServer.initialize <| \httpPermission ->
                            Init.await WebSocketServer.initialize <| \websocketPermission ->
                            let
                                baseDir =
                                    env.applicationPath
                                        |> Path.parentPath
                                        |> Maybe.map Path.toPosixString
                                        |> Maybe.withDefault "."

                                -- Parse --port from CLI args
                                portResult =
                                    Config.parsePortFromArgs env.args

                                cliPort =
                                    when portResult is
                                        Ok maybePort ->
                                            maybePort

                                        Err _ ->
                                            Nothing

                                -- Build config: default -> env vars -> CLI args
                                baseConfig =
                                    Config.defaultConfig
                                        |> Config.configFromEnv baseDir envVars
                                        |> Config.applyCliPort cliPort
                            in
                            -- If CHORUS_CONFIG is set, load it before creating the server
                            -- so the workspace port is applied before the server binds.
                            let
                                loadConfigTask =
                                    when baseConfig.chorusConfigPath is
                                        Just configPath ->
                                            loadWorkspaceConfig filesystemPermission configPath

                                        Nothing ->
                                            GrenTask.succeed (Err "no-config")
                            in
                            Init.awaitTask loadConfigTask <| \preloadedConfigResult ->
                                let
                                    -- Apply workspace config port (if loaded) before server creation
                                    workspacePort =
                                        when preloadedConfigResult is
                                            Ok loaded ->
                                                loaded.config.serverPort

                                            Err _ ->
                                                Nothing

                                    config =
                                        baseConfig
                                            |> Config.applyWorkspacePort cliPort workspacePort

                                    logger =
                                        Logging.makeLogger env.stdout config.logLevel

                                    model =
                                        { env = env
                                        , server = Nothing
                                        , registry = Nothing
                                        , agentRegistry = Nothing
                                        , providerRegistry = Nothing
                                        , activeExecutors = Dict.empty
                                        , filesystemPermission = filesystemPermission
                                        , childProcessPermission = childProcessPermission
                                        , httpClientPermission = httpClientPermission
                                        , secureContext = secureContext
                                        , config = config
                                        , workspaceConfig = Nothing
                                        , workspaceConfigPath = Nothing
                                        , status = Initializing
                                        , pendingConfigResponse = Nothing
                                        , logger = logger
                                        , cliPort = cliPort
                                        , websocketServer = Nothing
                                        , websocketClients = Dict.empty
                                        , workspacesPath = baseDir ++ "/workspaces.json"
                                        }

                                    -- Deliver pre-loaded config to GotConfigLoaded for registry init
                                    configCmd =
                                        when preloadedConfigResult is
                                            Ok _ ->
                                                GrenTask.succeed preloadedConfigResult
                                                    |> GrenTask.perform
                                                        (\result ->
                                                            GotConfigLoaded { response = Nothing, deferResponse = False, result = result }
                                                        )

                                            Err _ ->
                                                Cmd.none

                                    -- Handle invalid port: log error and exit
                                    portErrorCmd =
                                        when portResult is
                                            Err errMsg ->
                                                Cmd.batch
                                                    [ Logging.logError logger ("Invalid --port argument: " ++ errMsg) NoOp
                                                    , Stream.writeLineAsBytes ("Error: " ++ errMsg ++ "\n") env.stderr
                                                        |> GrenTask.onError (\_ -> GrenTask.succeed env.stderr)
                                                        |> GrenTask.andThen (\_ -> Node.setExitCode 1)
                                                        |> GrenTask.perform (\_ -> NoOp)
                                                    ]

                                            Ok _ ->
                                                Cmd.none
                                in
                                Node.startProgram
                                    { model = model
                                    , command =
                                        when portResult is
                                            Err _ ->
                                                portErrorCmd

                                            Ok _ ->
                                                Cmd.batch
                                                    [ -- Initialize the HTTP server
                                                      Server.createServer httpPermission
                                                        { host = config.host
                                                        , port_ = config.serverPort
                                                        }
                                                        |> GrenTask.attempt GotServer

                                                    , -- Deliver pre-loaded config for registry initialization
                                                      configCmd

                                                    , -- Initialize the WebSocket server on port + 1
                                                      WebSocketServer.createServer websocketPermission
                                                        { host = config.host
                                                        , port_ = config.serverPort + 1
                                                        }
                                                        |> GrenTask.attempt GotWebSocketServer

                                                    , -- Log startup
                                                      Logging.logInfo logger ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.serverPort) NoOp
                                                    ]
                                    }



-- PROVIDER FACTORY


{-| Create a provider for the given agent configuration.

Dispatches based on the agent's `provider` field and creates a `Provider`
that implements the event-driven interface. Returns Nothing if the provider
name is not recognized or the agent is internal.
-}
makeProvider : Model -> Types.AgentConfig -> Types.ProviderConfig -> Maybe (Provider.Provider Msg)
makeProvider model agentConfig providerConfig =
    when agentConfig is
        InternalAgent _ ->
            -- Internal agents use the system agent provider
            let
                baseUrl =
                    "http://" ++ model.config.host ++ ":" ++ String.fromInt model.config.serverPort
            in
            when providerConfig.providerType is
                Types.ClaudeCode ->
                    Just
                        (ClaudeCode.provider
                            { childProcessPermission = model.childProcessPermission
                            , chorusToolsPath = model.config.chorusToolsPath
                            , baseUrl = baseUrl
                            }
                        )

                Types.OpenCode ->
                    Just
                        (OpenCode.provider
                            { childProcessPermission = model.childProcessPermission
                            , filesystemPermission = model.filesystemPermission
                            , chorusToolsPath = model.config.chorusToolsPath
                            , baseUrl = baseUrl
                            }
                        )

                Types.OpenAiCompatible _ ->
                    Nothing

        UserDefinedAgent _ ->
            let
                baseUrl =
                    "http://" ++ model.config.host ++ ":" ++ String.fromInt model.config.serverPort
            in
            when providerConfig.providerType is
                Types.ClaudeCode ->
                    Just
                        (ClaudeCode.provider
                            { childProcessPermission = model.childProcessPermission
                            , chorusToolsPath = model.config.chorusToolsPath
                            , baseUrl = baseUrl
                            }
                        )

                Types.OpenCode ->
                    Just
                        (OpenCode.provider
                            { childProcessPermission = model.childProcessPermission
                            , filesystemPermission = model.filesystemPermission
                            , chorusToolsPath = model.config.chorusToolsPath
                            , baseUrl = baseUrl
                            }
                        )

                Types.OpenAiCompatible _ ->
                    -- API providers not yet supported
                    Nothing


{-| Spawn an agent.

1. Resolves the provider config for the agent
2. Creates a Provider instance
3. Builds the system prompt (agent instructions + tool context + output tool instruction)
4. Initializes the Executor model and Provider state
5. Calls provider.startAgent with the message
6. Returns the executor state and spawn command

For system agents (planners), uses the planner-output tool instruction
instead of the completion-report instruction.
-}
spawnAgent :
    Model
    -> TaskId
    -> String
    -> Types.AgentConfig
    -> Types.ProviderConfig
    -> Bool
    -> { executorState : ExecutorState, spawnCmd : Cmd Msg }
spawnAgent model taskId prompt agentConfig providerConfig isSystemAgent =
    let
        agentName =
            Types.agentConfigName agentConfig

        taskIdStr =
            Id.taskIdToString taskId

        agentKind =
            if isSystemAgent then
                SystemAgent
            else
                UserAgent

        agentInstructions =
            when agentConfig is
                InternalAgent r ->
                    r.instructions

                UserDefinedAgent r ->
                    r.instructions

        toolContext =
            when agentConfig is
                InternalAgent _ ->
                    ""

                UserDefinedAgent r ->
                    toolContextForAgent r.allowedTools

        outputToolInstruction =
            if isSystemAgent then
                "\n\nRemember: you must call the planner-output tool via chorus-tools before finishing. Use Bash to invoke:\nchorus-tools <workspace-root> '{\"tool\": \"planner-output\", ...}'"
            else
                "\n\nIMPORTANT: Before finishing your work, you MUST call the completion-report tool to submit your results. Use: {\"tool\": \"completion-report\", \"status\": \"complete\", \"summary\": \"Brief summary of what was done\", \"output\": \"Detailed output\"}\nFor blocked work, use status \"blocked\" with a \"blockedReason\". For failures, use status \"failed\"."

        systemPrompt =
            if String.isEmpty agentInstructions then
                toolContext ++ outputToolInstruction
            else
                agentInstructions ++ toolContext ++ outputToolInstruction

        allowedToolsFlag =
            when agentConfig is
                UserDefinedAgent r ->
                    when r.allowedTools is
                        [] ->
                            Nothing

                        tools ->
                            Just (String.join " " tools)

                InternalAgent _ ->
                    Nothing

        maybeProvider =
            makeProvider model agentConfig providerConfig
    in
    when maybeProvider is
        Nothing ->
            -- Provider could not be created; emit an AgentFailed event
            -- so that the executor lifecycle handles it correctly.
            { executorState =
                Spawning
                    { taskId = taskId
                    , agentName = agentName
                    , agentConfig = agentConfig
                    , agentKind = agentKind
                    , deferredResponse = Nothing
                    }
            , spawnCmd =
                GrenTask.succeed {}
                    |> GrenTask.perform
                        (\_ ->
                            GotProviderEvent
                                { taskId = taskId
                                , event = Provider.AgentFailed ("Could not create provider for agent: " ++ agentName)
                                }
                        )
            }

        Just resolvedProvider ->
            let
                startConfig =
                    { agentSpec =
                        { name = agentName
                        , systemPrompt = systemPrompt
                        }
                    , message = prompt
                    , workspaceRoot = initialAgentDir model
                    , taskId = Just taskIdStr
                    , allowedTools = allowedToolsFlag
                    , resumeSessionId = Nothing
                    , onEvent = \event -> GotProviderEvent { taskId = taskId, event = event }
                    }

                startResult =
                    resolvedProvider.startAgent resolvedProvider.initState startConfig

                executorState =
                    AgentActive
                        { taskId = taskId
                        , agentName = agentName
                        , agentConfig = agentConfig
                        , agentKind = agentKind
                        , executorModel = Executor.Idle
                        , providerState = startResult.state
                        , provider = resolvedProvider
                        , retryCount = 0
                        , sessionId = Nothing
                        }
            in
            { executorState = executorState
            , spawnCmd = startResult.cmd
            }


{-| Resolve the provider config and spawn an agent.

Creates a placeholder executor state immediately, then asynchronously resolves
the provider config. On success, emits `GotProviderResolved` which creates
the provider and starts the agent. On failure, emits
`GotProviderEvent AgentFailed`.
-}
resolveAndSpawnAgent :
    Model
    -> TaskId
    -> String
    -> Types.AgentConfig
    -> Bool
    -> { executorState : ExecutorState, spawnCmd : Cmd Msg, agentName : String }
resolveAndSpawnAgent model taskId prompt agentConfig isSystemAgent =
    let
        agentName =
            Types.agentConfigName agentConfig

        agentKind =
            if isSystemAgent then
                SystemAgent
            else
                UserAgent

        executorState =
            Spawning
                { taskId = taskId
                , agentName = agentName
                , agentConfig = agentConfig
                , agentKind = agentKind
                , deferredResponse = Nothing
                }

        -- Resolve the provider config asynchronously. On success, emit
        -- GotProviderResolved to trigger the agent start. On failure, emit
        -- GotProviderEvent AgentFailed.
        spawnCmd =
            resolveProviderConfig model agentConfig
                |> GrenTask.map Ok
                |> GrenTask.onError
                    (\errMsg ->
                        GrenTask.succeed (Err errMsg)
                    )
                |> GrenTask.perform
                    (\result ->
                        when result is
                            Err errMsg ->
                                GotProviderEvent
                                    { taskId = taskId
                                    , event = Provider.AgentFailed ("Provider resolution failed: " ++ errMsg)
                                    }

                            Ok providerConfig ->
                                GotProviderResolved
                                    { taskId = taskId
                                    , prompt = prompt
                                    , agentConfig = agentConfig
                                    , providerConfig = providerConfig
                                    , isSystemAgent = isSystemAgent
                                    }
                    )
    in
    { executorState = executorState
    , spawnCmd = spawnCmd
    , agentName = agentName
    }


{-| Build the ToolExecutionContext for the executor.

Used when creating an `Executor.Config` for processing tool calls.
-}
makeToolExecutionContext : Model -> TaskId -> Types.AgentConfig -> ToolExecution.ToolExecutionContext
makeToolExecutionContext model taskId agentConfig =
    let
        allowedTools =
            when agentConfig is
                UserDefinedAgent r ->
                    r.allowedTools

                InternalAgent _ ->
                    []

        allowedDirs =
            when model.workspaceConfig is
                Just wc ->
                    wc.allowedAgentDirectories

                Nothing ->
                    []
    in
    when model.registry is
        Just reg ->
            { filesystemPermission = model.filesystemPermission
            , childProcessPermission = model.childProcessPermission
            , allowedDirectories = allowedDirs
            , allowedTools = allowedTools
            , apiContext = makeApiContext model reg
            , taskId = taskId
            }

        Nothing ->
            -- This should not happen since spawnAgent is only called when registry is available.
            -- But we need a complete record, so provide a minimal context.
            Debug.todo "makeToolExecutionContext called without a loaded registry"




{-| Resolve a provider config for a given agent, returning an async Task.

Looks up the agent's provider reference in the provider registry.
Returns an error if the agent has no provider configured or the provider is not found.
-}
resolveProviderConfig : Model -> Types.AgentConfig -> GrenTask.Task String Types.ProviderConfig
resolveProviderConfig model agentConfig =
    when agentConfig is
        InternalAgent r ->
            GrenTask.fail ("Cannot resolve provider for internal agent: " ++ r.name)

        UserDefinedAgent r ->
            when r.provider is
                NotConfigured ->
                    GrenTask.fail ("Agent '" ++ r.name ++ "' has no provider configured")

                ProviderRef providerName ->
                    when model.providerRegistry is
                        Nothing ->
                            GrenTask.fail "Provider registry not available"

                        Just providerReg ->
                            ProviderRegistry.getProvider providerReg providerName
                                |> GrenTask.mapError
                                    (\err ->
                                        "Agent '" ++ r.name ++ "' references provider '" ++ providerName ++ "' which does not exist"
                                    )





-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = Logging.logInfo model.logger "HTTP server started" NoOp
                    }

                Err err ->
                    let
                        serverConfig =
                            { host = model.config.host
                            , port_ = model.config.serverPort
                            }

                        errMsg =
                            Server.errorToString serverConfig err
                    in
                    { model = { model | status = Error errMsg }
                    , command = Logging.logError model.logger ("Server error: " ++ errMsg) NoOp
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    let
                        newModel =
                            { model
                                | registry = Just registry
                                , status = Running
                            }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Task registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            Registry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Registry error: " ++ errMsg)
                    in
                    { model = { errorFlush.model | status = Error errMsg }
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotAgentRegistry result ->
            when result is
                Ok agentReg ->
                    let
                        newModel =
                            { model | agentRegistry = Just agentReg }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Agent registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            AgentRegistry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Agent registry error: " ++ errMsg)
                    in
                    { model = errorFlush.model
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Agent registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotProviderRegistry result ->
            when result is
                Ok providerReg ->
                    let
                        newModel =
                            { model | providerRegistry = Just providerReg }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Provider registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            ProviderRegistry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Provider registry error: " ++ errMsg)
                    in
                    { model = errorFlush.model
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Provider registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotToolAgentLookup { taskId, requestBody, response, result } ->
            when result is
                Err errMsg ->
                    { model = model
                    , command = sendBadRequest response errMsg
                    }

                Ok { agentConfig } ->
                    let
                        taskIdStr =
                            Id.taskIdToString taskId

                        maybeExecutor =
                            Dict.get taskIdStr model.activeExecutors
                    in
                    when maybeExecutor is
                        Nothing ->
                            -- No active executor — reject with error
                            { model = model
                            , command =
                                Cmd.batch
                                    [ sendBadRequest response "No active agent session for this task"
                                    , Logging.logWarn model.logger
                                        ("Tool request rejected for task " ++ taskIdStr ++ ": no active executor")
                                        NoOp
                                    ]
                            }

                        Just (Spawning _) ->
                            -- Provider still resolving — reject, agent not ready yet
                            { model = model
                            , command = sendBadRequest response "Agent is still starting"
                            }

                        Just (AgentActive executor) ->
                            routeToolCallToExecutor model taskId taskIdStr executor requestBody response

                        Just (ActiveHandoff { executor }) ->
                            routeToolCallToExecutor model taskId taskIdStr executor requestBody response

        GotAgentLookup { taskId, prompt, response, result } ->
            when result is
                Err err ->
                    { model = model
                    , command = sendBadRequest response ("Agent registry error: " ++ AgentRegistry.errorToString err)
                    }

                Ok agentConfig ->
                    if Types.isInternalAgent agentConfig then
                        { model = model
                        , command = sendBadRequest response ("Cannot hand off to internal agent: " ++ Types.agentConfigName agentConfig)
                        }
                    else
                    -- Agent found and provider validated (validation done in StartHandoff handler).
                    -- Update the task first, then spawn the agent.
                    -- The HTTP response is sent via GotApiResult from requestStartHandoff.
                    -- The agent spawn happens via GotHandoffRecorded when the task update succeeds.
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response "Registry not available"
                            }

                        Just registry ->
                            let
                                ctx =
                                    makeApiContext model registry

                                toMsg =
                                    \apiResult ->
                                        GotHandoffRecorded
                                            { taskId = taskId
                                            , prompt = prompt
                                            , response = response
                                            , agentConfig = agentConfig
                                            , apiResult = apiResult
                                            }
                            in
                            { model = model
                            , command =
                                Api.requestStartAgent ctx taskId { agentName = Types.agentConfigName agentConfig, prompt = prompt } toMsg
                            }

        GotHandoffRecorded { taskId, prompt, response, agentConfig, apiResult } ->
            -- The task update completed. Send the HTTP response first, then spawn the agent.
            let
                sendResponseCmd =
                    Api.sendApiResponse response apiResult
            in
            when apiResult is
                Api.ApiError _ ->
                    -- Task update failed (e.g., 409 conflict), just send the error response
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.DeferredHandoff _ ->
                    -- Should not happen in this handler
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.DeferredPlannerOutput _ ->
                    -- Should not happen in this handler
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.ApiSuccess { body } ->
                    -- Task updated successfully. Resolve the provider and spawn the agent.
                    let
                        taskIdStr =
                            Id.taskIdToString taskId

                        spawnResult =
                            resolveAndSpawnAgent model taskId prompt agentConfig False
                    in
                    { model = { model | activeExecutors = Dict.set taskIdStr spawnResult.executorState model.activeExecutors }
                    , command =
                        Cmd.batch
                            [ sendResponseCmd
                            , spawnResult.spawnCmd
                            , broadcastToClients model "tasks_changed" (Encode.string body)
                            , Logging.logInfo model.logger ("Spawned agent " ++ spawnResult.agentName ++ " for task " ++ taskIdStr) NoOp
                            ]
                    }

        GotDeferredHandoffLookup { taskId, prompt, response, agentConfig } ->
            -- Agent found for deferred handoff. Start the handoff in the registry.
            when model.registry is
                Nothing ->
                    { model = model
                    , command = sendBadRequest response "Registry not available"
                    }

                Just registry ->
                    let
                        ctx =
                            makeApiContext model registry

                        toMsg =
                            \apiResult ->
                                GotDeferredHandoffStarted
                                    { taskId = taskId
                                    , prompt = prompt
                                    , response = response
                                    , agentConfig = agentConfig
                                    , apiResult = apiResult
                                    }
                    in
                    { model = model
                    , command =
                        Api.requestStartHandoff ctx taskId { agentName = Types.agentConfigName agentConfig, prompt = prompt } toMsg
                    }

        GotDeferredHandoffStarted { taskId, prompt, response, agentConfig, apiResult } ->
            -- Handoff recorded in registry. Store the deferred response and spawn the agent.
            when apiResult is
                Api.ApiError err ->
                    -- Handoff start failed (e.g., 409 conflict), send error to tool binary
                    { model = model
                    , command =
                        Api.sendApiResponse response (Api.ApiError err)
                    }

                Api.DeferredHandoff _ ->
                    -- Should not happen in this handler (requestStartHandoff returns ApiSuccess/ApiError)
                    { model = model
                    , command =
                        Api.sendApiResponse response
                            (Api.ApiError { statusCode = 500, code = "INTERNAL_ERROR", message = "Unexpected DeferredHandoff result in GotDeferredHandoffStarted" })
                    }

                Api.DeferredPlannerOutput _ ->
                    -- Should not happen in this handler
                    { model = model
                    , command =
                        Api.sendApiResponse response
                            (Api.ApiError { statusCode = 500, code = "INTERNAL_ERROR", message = "Unexpected DeferredPlannerOutput result in GotDeferredHandoffStarted" })
                    }

                Api.ApiSuccess _ ->
                    -- Handoff started successfully. Store the HTTP response on the
                    -- Spawning executor so it carries through to ActiveHandoff when
                    -- the provider resolves.
                    let
                        spawnResult =
                            resolveAndSpawnAgent model taskId prompt agentConfig False

                        taskIdStr =
                            Id.taskIdToString taskId

                        -- Attach the deferred response to the Spawning executor
                        executorWithResponse =
                            when spawnResult.executorState is
                                Spawning spawning ->
                                    Spawning { spawning | deferredResponse = Just response }

                                other ->
                                    -- Should not happen — resolveAndSpawnAgent always returns Spawning
                                    other

                        updatedModel =
                            { model
                                | activeExecutors = Dict.set taskIdStr executorWithResponse model.activeExecutors
                            }
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ spawnResult.spawnCmd
                            , Logging.logInfo model.logger ("Spawned deferred handoff agent " ++ spawnResult.agentName ++ " for task " ++ taskIdStr) NoOp
                            ]
                    }

        GotAgentComplete { taskId, result } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId

                maybeExecutorState =
                    Dict.get taskIdStr model.activeExecutors
            in
            when maybeExecutorState is
                Nothing ->
                    { model = model
                    , command = Logging.logWarn model.logger ("GotAgentComplete for unknown executor: " ++ taskIdStr) NoOp
                    }

                Just (Spawning _) ->
                    -- Should not happen — agent hasn't started yet
                    { model = { model | activeExecutors = Dict.remove taskIdStr model.activeExecutors }
                    , command = Logging.logWarn model.logger ("GotAgentComplete for spawning executor: " ++ taskIdStr) NoOp
                    }

                Just (AgentActive executor) ->
                    when executor.agentKind is
                        SystemAgent ->
                            handlePlannerComplete model taskId taskIdStr executor result

                        UserAgent ->
                            handleUserAgentComplete model taskId taskIdStr executor Nothing result

                Just (ActiveHandoff { executor, deferredResponse }) ->
                    when executor.agentKind is
                        SystemAgent ->
                            handlePlannerComplete model taskId taskIdStr executor result

                        UserAgent ->
                            handleUserAgentComplete model taskId taskIdStr executor (Just deferredResponse) result

        GotProviderEvent { taskId, event } ->
            handleProviderEvent model taskId event

        GotExecutorMsg { taskId, msg = executorMsg } ->
            handleExecutorMsg model taskId executorMsg

        GotProviderResolved { taskId, prompt, agentConfig, providerConfig, isSystemAgent } ->
            -- Provider config resolved. Create the provider and start the agent.
            let
                taskIdStr =
                    Id.taskIdToString taskId

                -- Check if the previous Spawning state had a deferred handoff response
                maybeDeferredResponse =
                    when Dict.get taskIdStr model.activeExecutors is
                        Just (Spawning spawning) ->
                            spawning.deferredResponse

                        _ ->
                            Nothing

                spawnResult =
                    spawnAgent model taskId prompt agentConfig providerConfig isSystemAgent

                -- If there was a deferred response, wrap the AgentActive executor in ActiveHandoff.
                -- If the provider failed (Spawning state), attach the deferred response so
                -- the AgentFailed handler can resolve it.
                finalExecutorState =
                    when maybeDeferredResponse is
                        Just deferredResponse ->
                            when spawnResult.executorState is
                                AgentActive executor ->
                                    ActiveHandoff { executor = executor, deferredResponse = deferredResponse }

                                Spawning spawning ->
                                    Spawning { spawning | deferredResponse = Just deferredResponse }

                                ActiveHandoff record ->
                                    -- Should not happen — spawnAgent doesn't return ActiveHandoff
                                    ActiveHandoff record

                        Nothing ->
                            spawnResult.executorState

                updatedModel =
                    { model | activeExecutors = Dict.set taskIdStr finalExecutorState model.activeExecutors }
            in
            { model = updatedModel
            , command = spawnResult.spawnCmd
            }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            Logging.logDebug model.logger ("Request body: " ++ bodyStr) NoOp
            in
            { model = model
            , command =
                Cmd.batch
                    [ Logging.logInfo model.logger
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                        NoOp
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotMutatingApiResult { broadcastType, response, result } ->
            let
                broadcastCmd =
                    when result is
                        Api.ApiSuccess { body } ->
                            broadcastToClients model broadcastType (Encode.string body)

                        _ ->
                            Cmd.none
            in
            { model = model
            , command =
                Cmd.batch
                    [ Api.sendApiResponse response result
                    , broadcastCmd
                    ]
            }

        GotToolResult { taskId, toolName, requestBody, response, result } ->
            when result is
                Api.DeferredHandoff { agentName, prompt } ->
                    -- Handoff requested through tool binary: look up agent, start handoff, defer response
                    when model.agentRegistry is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response "Agent registry not available"
                            }

                        Just agentReg ->
                            { model = model
                            , command =
                                AgentRegistry.getAgent agentReg agentName
                                    |> GrenTask.mapError AgentRegistry.errorToString
                                    |> GrenTask.andThen
                                        (\agentConfig ->
                                            if Types.isInternalAgent agentConfig then
                                                GrenTask.fail ("Cannot hand off to internal agent: " ++ Types.agentConfigName agentConfig)
                                            else
                                                GrenTask.succeed agentConfig
                                        )
                                    |> GrenTask.attempt
                                        (\lookupResult ->
                                            when lookupResult is
                                                Err errMsg ->
                                                    GotApiResult { response = response, result = Api.ApiError { statusCode = 400, code = "BAD_REQUEST", message = errMsg } }

                                                Ok agentConfig ->
                                                    GotDeferredHandoffLookup
                                                        { taskId = taskId
                                                        , prompt = prompt
                                                        , response = response
                                                        , agentConfig = agentConfig
                                                        }
                                        )
                            }

                Api.DeferredPlannerOutput plannerOutput ->
                    -- Planner output submitted without an active executor. This path is
                    -- a fallback; the primary path is through the Executor's
                    -- DeferredActionRequired effect.
                    let
                        taskIdStr =
                            Id.taskIdToString taskId

                        maybeActiveExecutor =
                            Dict.get taskIdStr model.activeExecutors
                                |> Maybe.andThen activeExecutorFromState
                    in
                    when maybeActiveExecutor is
                        Nothing ->
                            { model = model
                            , command = Api.sendApiResponse response (Api.ApiError { statusCode = 400, code = "BAD_REQUEST", message = "No active executor for task: " ++ taskIdStr })
                            }

                        Just executor ->
                            when extractPlannerOutput executor.executorModel is
                                Just _ ->
                                    -- Already received - exactly-once enforcement
                                    { model = model
                                    , command = Api.sendApiResponse response (Api.ApiError { statusCode = 409, code = "CONFLICT", message = "Planner output already submitted for this task" })
                                    }

                                Nothing ->
                                    let
                                        successResponse =
                                            Api.ApiSuccess
                                                { statusCode = 200
                                                , body =
                                                    Encode.encode 0
                                                        (Encode.object
                                                            [ { key = "success", value = Encode.bool True }
                                                            ]
                                                        )
                                                }

                                        recordEventCmd =
                                            when model.registry is
                                                Nothing ->
                                                    Cmd.none

                                                Just reg ->
                                                    Registry.recordEvent reg taskId
                                                        { eventType = PlannerOutputSubmitted
                                                        , data =
                                                            Dict.empty
                                                                |> Dict.set "tool" "planner-output"
                                                                |> Dict.set "input" requestBody
                                                        }
                                                        |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                                        |> GrenTask.perform (\_ -> NoOp)
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.sendApiResponse response successResponse
                                            , recordEventCmd
                                            ]
                                    }

                _ ->
                    -- This branch handles tool results that arrive without an active
                    -- executor (e.g., orphaned tool calls). Since the no-executor
                    -- fallback has been removed from GotToolAgentLookup, this path
                    -- should not be reached in normal operation. Log and reject.
                    { model = model
                    , command =
                        Cmd.batch
                            [ Api.sendApiResponse response (Api.ApiError { statusCode = 400, code = "BAD_REQUEST", message = "Unexpected GotToolResult: no active executor" })
                            , Logging.logWarn model.logger ("GotToolResult received for tool " ++ toolName ++ " but no active executor") NoOp
                            ]
                    }

        GotBinaryResult { response, result } ->
            { model = model
            , command = Api.sendBinaryResponse response result
            }

        GotInternalApiResult _ ->
            -- Internal API result from agent/planner completion; broadcast to WebSocket clients
            { model = model
            , command = broadcastToClients model "tasks_changed" Encode.null
            }

        GotTaskCreated { response, taskId, description, result } ->
            -- Task created. Remains in Pending status; user must trigger planning.
            let
                broadcastCmd =
                    when result is
                        Api.ApiSuccess { body } ->
                            broadcastToClients model "tasks_changed" (Encode.string body)

                        _ ->
                            Cmd.none
            in
            { model = model
            , command =
                Cmd.batch
                    [ Api.sendApiResponse response result
                    , broadcastCmd
                    ]
            }

        GotPlanTaskResult { response, taskId, description, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess { body } ->
                    -- Plan endpoint succeeded. Dispatch the task-validator agent.
                    when model.agentRegistry is
                        Just agentReg ->
                            let
                                plannerResult =
                                    dispatchPlanner model agentReg taskId description
                            in
                            { model = plannerResult.model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , plannerResult.command
                                    , broadcastToClients plannerResult.model "tasks_changed" (Encode.string body)
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

                Api.DeferredHandoff _ ->
                    { model = model, command = sendResponseCmd }

                Api.DeferredPlannerOutput _ ->
                    { model = model, command = sendResponseCmd }

        GotAnswersSubmitted { response, taskId, enrichedPrompt, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess { body } ->
                    when model.agentRegistry is
                        Just agentReg ->
                            let
                                plannerResult =
                                    dispatchPlanner model agentReg taskId enrichedPrompt
                            in
                            { model = plannerResult.model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , plannerResult.command
                                    , broadcastToClients plannerResult.model "tasks_changed" (Encode.string body)
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

                Api.DeferredHandoff _ ->
                    { model = model, command = sendResponseCmd }

                Api.DeferredPlannerOutput _ ->
                    { model = model, command = sendResponseCmd }

        GotToolGrant { taskId, addTools, removeTools, response } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId

                executorState =
                    Dict.get taskIdStr model.activeExecutors
            in
            when executorState is
                Nothing ->
                    { model = model
                    , command = sendBadRequest response ("No active executor for task: " ++ taskIdStr)
                    }

                Just (Spawning _) ->
                    { model = model
                    , command = sendBadRequest response ("Agent is still starting for task: " ++ taskIdStr)
                    }

                Just currentState ->
                    when activeExecutorFromState currentState is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response ("No active executor for task: " ++ taskIdStr)
                            }

                        Just executor ->
                            let
                                agentConfig =
                                    executor.agentConfig

                                currentTools =
                                    when agentConfig is
                                        UserDefinedAgent r ->
                                            r.allowedTools

                                        InternalAgent _ ->
                                            []

                                withAdded =
                                    Array.foldl
                                        (\tool tools ->
                                            if Array.any (\t -> t == tool) tools then
                                                tools
                                            else
                                                Array.pushLast tool tools
                                        )
                                        currentTools
                                        addTools

                                withRemoved =
                                    Array.keepIf
                                        (\tool ->
                                            not (Array.any (\r -> r == tool) removeTools)
                                        )
                                        withAdded

                                updatedConfig =
                                    when agentConfig is
                                        UserDefinedAgent r ->
                                            UserDefinedAgent { r | allowedTools = withRemoved }

                                        InternalAgent _ ->
                                            agentConfig

                                updatedExecutorState =
                                    updateActiveExecutor (\e -> { e | agentConfig = updatedConfig }) currentState

                                updatedExecutors =
                                    Dict.set taskIdStr updatedExecutorState model.activeExecutors

                                responseBody =
                                    Encode.object
                                        [ { key = "allowedTools", value = Encode.array Encode.string withRemoved }
                                        ]
                                        |> Encode.encode 0
                            in
                            { model = { model | activeExecutors = updatedExecutors }
                            , command =
                                Cmd.batch
                                    [ response
                                        |> Response.setStatus 200
                                        |> Response.setHeader "Content-Type" "application/json"
                                        |> Response.setBody responseBody
                                        |> Response.send
                                    , Logging.logInfo model.logger ("Updated tools for task " ++ taskIdStr ++ ": " ++ String.join ", " withRemoved) NoOp
                                    ]
                            }

        GotConfigLoaded { response, deferResponse, result } ->
            when result is
                Err errMsg ->
                    let
                        responseCmd =
                            when response is
                                Just resp ->
                                    sendBadRequest resp errMsg

                                Nothing ->
                                    Cmd.none
                    in
                    { model = model
                    , command =
                        Cmd.batch
                            [ responseCmd
                            , Logging.logError model.logger ("Config load failed: " ++ errMsg) NoOp
                            ]
                    }

                Ok { config, configPath } ->
                    let
                        -- Derive paths from workspace root (parent of chorus.json)
                        configRoot =
                            parentDirectory configPath

                        registryRoot =
                            configRoot ++ "/registry"

                        providersRoot =
                            configRoot ++ "/providers"

                        uploadDirPath =
                            configRoot ++ "/uploads"

                        -- Initialize all registries
                        initRegistryCmd =
                            Registry.init model.filesystemPermission model.secureContext
                                { registryRoot = registryRoot }
                                |> GrenTask.attempt GotRegistry

                        agentsRoot =
                            configRoot ++ "/agents"

                        initAgentRegistryCmd =
                            AgentRegistry.init model.filesystemPermission
                                { agentsRoot = agentsRoot }
                                |> GrenTask.attempt GotAgentRegistry

                        initProviderRegistryCmd =
                            ProviderRegistry.init model.filesystemPermission
                                { providersRoot = providersRoot }
                                |> GrenTask.attempt GotProviderRegistry

                        -- Ensure upload directory exists
                        ensureUploadDirCmd =
                            FileSystem.makeDirectory model.filesystemPermission { recursive = True } (Path.fromPosixString uploadDirPath)
                                |> GrenTask.map (\_ -> {})
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                |> GrenTask.perform (\_ -> NoOp)

                        -- Either defer the response (select/create) or send immediately (update/startup)
                        shouldDefer =
                            deferResponse && response /= Nothing

                        responseCmd =
                            if shouldDefer then
                                Cmd.none
                            else
                                when response is
                                    Just resp ->
                                        sendConfigResponse resp config configPath

                                    Nothing ->
                                        Cmd.none

                        pendingConfig =
                            if shouldDefer then
                                when response is
                                    Just resp ->
                                        Just { response = resp, config = config, configPath = configPath }

                                    Nothing ->
                                        Nothing
                            else
                                Nothing
                    in
                    let
                        -- Apply workspace config port with CLI port precedence
                        updatedConfig =
                            Config.applyWorkspacePort model.cliPort config.serverPort model.config

                        -- Warn if the workspace config port differs from the running server port
                        portWarningCmd =
                            when config.serverPort is
                                Just wsPort ->
                                    if wsPort /= model.config.serverPort then
                                        Logging.logWarn model.logger ("Workspace config specifies port " ++ String.fromInt wsPort ++ " but server is running on " ++ String.fromInt model.config.serverPort ++ ". Restart required for port change to take effect.") NoOp
                                    else
                                        Cmd.none

                                Nothing ->
                                    Cmd.none
                    in
                    { model =
                        { model
                            | workspaceConfig = Just config
                            , workspaceConfigPath = Just configPath
                            , config = updatedConfig
                            , pendingConfigResponse = pendingConfig
                            , registry =
                                if shouldDefer then Nothing else model.registry
                            , agentRegistry =
                                if shouldDefer then Nothing else model.agentRegistry
                            , providerRegistry =
                                if shouldDefer then Nothing else model.providerRegistry
                        }
                    , command =
                        Cmd.batch
                            [ initRegistryCmd
                            , initAgentRegistryCmd
                            , initProviderRegistryCmd
                            , ensureUploadDirCmd
                            , responseCmd
                            , portWarningCmd
                            , broadcastToClients model "config_changed" Encode.null
                            , Logging.logInfo model.logger ("Workspace config loaded from: " ++ configPath) NoOp
                            , recordWorkspaceEntry model.filesystemPermission model.workspacesPath configPath
                                |> GrenTask.perform GotWorkspaceRecorded
                            ]
                    }

        GotWebSocketServer result ->
            when result is
                Ok wsServer ->
                    { model = { model | websocketServer = Just wsServer }
                    , command = Logging.logInfo model.logger ("WebSocket server started on port " ++ String.fromInt (model.config.serverPort + 1)) NoOp
                    }

                Err (WebSocketServer.ServerError { code, message }) ->
                    { model = model
                    , command = Logging.logError model.logger ("WebSocket server error: " ++ message ++ " (" ++ code ++ ")") NoOp
                    }

        WsClientConnected connection ->
            let
                clientId =
                    connection
                        |> WebSocketServer.connectionId
                        |> WebSocketServer.connectionIdToInt
            in
            { model = { model | websocketClients = Dict.set clientId connection model.websocketClients }
            , command = Logging.logDebug model.logger ("WebSocket client connected: " ++ String.fromInt clientId) NoOp
            }

        WsClientDisconnected { connection } ->
            let
                clientId =
                    connection
                        |> WebSocketServer.connectionId
                        |> WebSocketServer.connectionIdToInt
            in
            { model = { model | websocketClients = Dict.remove clientId model.websocketClients }
            , command = Logging.logDebug model.logger ("WebSocket client disconnected: " ++ String.fromInt clientId) NoOp
            }

        WsClientError { connection, error } ->
            let
                clientId =
                    connection
                        |> WebSocketServer.connectionId
                        |> WebSocketServer.connectionIdToInt
            in
            { model = { model | websocketClients = Dict.remove clientId model.websocketClients }
            , command = Logging.logDebug model.logger ("WebSocket client error: " ++ String.fromInt clientId ++ " - " ++ error) NoOp
            }

        WsBroadcastResult _ ->
            -- Fire-and-forget; stale connections are cleaned up via WsClientDisconnected/WsClientError
            { model = model
            , command = Cmd.none
            }

        GotWorkspaceRecorded result ->
            when result is
                Ok _ ->
                    { model = model
                    , command = Cmd.none
                    }

                Err errMsg ->
                    { model = model
                    , command = Logging.logError model.logger ("Failed to record workspace entry: " ++ errMsg) NoOp
                    }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { filesystemPermission = model.filesystemPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        -- Config routes work without registry (they set up the workspace)
        Router.GetConfig ->
            handleGetConfig model response

        Router.UpdateConfig ->
            handleUpdateConfig model request response

        Router.SelectConfig ->
            handleSelectConfig model request response

        Router.CreateConfig ->
            handleCreateConfig model request response

        Router.GetConfigDefaults ->
            handleGetConfigDefaults model response

        Router.ListWorkspaces ->
            handleListWorkspaces model response

        Router.RemoveWorkspace path ->
            handleRemoveWorkspace model path response

        _ ->
            -- All other API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            makeApiContext model registry

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }

                        mutatingToMsg =
                            \broadcastType apiResult -> GotMutatingApiResult { broadcastType = broadcastType, response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params
                                        (\apiResult ->
                                            let
                                                taskIdResult =
                                                    when apiResult is
                                                        Api.ApiSuccess { body } ->
                                                            Decode.decodeString (Decode.at [ "data", "id" ] Decode.string) body
                                                                |> Result.mapError Decode.errorToString
                                                                |> Result.andThen (\idStr ->
                                                                    when Id.taskIdFromString idStr is
                                                                        Just taskId -> Ok taskId
                                                                        Nothing -> Err "Invalid task ID"
                                                                )

                                                        _ ->
                                                            Err "Create failed"
                                            in
                                            when taskIdResult is
                                                Ok taskId ->
                                                    GotTaskCreated { response = response, taskId = taskId, description = params.description, result = apiResult }

                                                Err _ ->
                                                    GotApiResult { response = response, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status Nothing (mutatingToMsg "tasks_changed")

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskPlanning taskId ->
                            when parseUpdatePlanningBody request is
                                Ok params ->
                                    Api.requestUpdatePlanning ctx taskId params (mutatingToMsg "tasks_changed")

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content (mutatingToMsg "tasks_changed")

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UploadAttachment { taskId, filename } ->
                            Api.requestUploadAttachment ctx taskId filename request.body (uploadDir model) (mutatingToMsg "tasks_changed")

                        Router.DownloadAttachment { taskId, filename } ->
                            let
                                toBinaryMsg =
                                    \binaryResult -> GotBinaryResult { response = response, result = binaryResult }
                            in
                            Api.requestDownloadAttachment ctx taskId filename (uploadDir model) toBinaryMsg

                        Router.DeleteAttachment { taskId, filename } ->
                            Api.requestDeleteAttachment ctx taskId filename (uploadDir model) (mutatingToMsg "tasks_changed")

                        Router.ExecuteTool taskId ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendBadRequest response "Agent registry not initialized"

                                Just agentReg ->
                                    let
                                        bodyStr =
                                            Bytes.toString request.body
                                                |> Maybe.withDefault ""

                                        -- Look up task to find current agent, then look up agent config
                                        lookupTask =
                                            Registry.getTask registry taskId
                                                |> GrenTask.mapError (\err -> Registry.errorToString err)
                                                |> GrenTask.andThen
                                                    (\maybeTask ->
                                                        when maybeTask is
                                                            Nothing ->
                                                                GrenTask.fail ("Task not found: " ++ Id.taskIdToString taskId)

                                                            Just task ->
                                                                when Types.taskCurrentAgent task is
                                                                    Nothing ->
                                                                        GrenTask.fail "No agent currently active on this task"

                                                                    Just agentName ->
                                                                        AgentRegistry.getAgent agentReg agentName
                                                                            |> GrenTask.mapError (\err -> "Agent not found: " ++ AgentRegistry.errorToString err)
                                                                            |> GrenTask.map (\config -> { agentConfig = config })
                                                    )
                                    in
                                    lookupTask
                                        |> GrenTask.attempt
                                            (\result ->
                                                GotToolAgentLookup
                                                    { taskId = taskId
                                                    , requestBody = bodyStr
                                                    , response = response
                                                    , result = result
                                                    }
                                            )

                        Router.UpdateAgentTools taskId ->
                            when parseToolGrantBody request is
                                Ok params ->
                                    GrenTask.succeed {}
                                        |> GrenTask.perform
                                            (\_ ->
                                                GotToolGrant
                                                    { taskId = taskId
                                                    , addTools = params.addTools
                                                    , removeTools = params.removeTools
                                                    , response = response
                                                    }
                                            )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.SubmitAnswers taskId ->
                            when parseSubmitAnswersBody request is
                                Ok answers ->
                                    Api.requestSubmitAnswers ctx taskId answers
                                        (\{ apiResult, enrichedPrompt } ->
                                            GotAnswersSubmitted { response = response, taskId = taskId, enrichedPrompt = enrichedPrompt, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.PlanTask taskId ->
                            when Maybe.map .systemAgentProvider model.workspaceConfig is
                                Just NotConfigured ->
                                    sendConflict response "System agent provider is not configured. Please configure it in System Settings."

                                Nothing ->
                                    sendConflict response "No workspace config loaded"

                                Just (ProviderRef _) ->
                                    Api.requestPlanTask ctx taskId
                                        (\{ apiResult, description } ->
                                            GotPlanTaskResult { response = response, taskId = taskId, description = description, result = apiResult }
                                        )

                        Router.StartHandoff taskId ->
                            when Maybe.map .systemAgentProvider model.workspaceConfig is
                                Just NotConfigured ->
                                    sendConflict response "System agent provider is not configured. Please configure it in System Settings."

                                Nothing ->
                                    sendConflict response "No workspace config loaded"

                                Just (ProviderRef _) ->
                                    when parseStartHandoffBody request is
                                        Ok params ->
                                            when model.agentRegistry is
                                                Nothing ->
                                                    sendBadRequest response "Agent registry not initialized"

                                                Just agentReg ->
                                                    -- Look up the agent, then validate its provider exists
                                                    AgentRegistry.getAgent agentReg params.agentName
                                                        |> GrenTask.andThen
                                                            (\agentConfig ->
                                                                -- Validate provider exists for user-defined agents
                                                                when agentConfig is
                                                                    UserDefinedAgent r ->
                                                                        when r.provider is
                                                                            NotConfigured ->
                                                                                GrenTask.fail (AgentRegistry.FileSystemError ("Agent '" ++ params.agentName ++ "' has no provider configured"))

                                                                            ProviderRef providerName ->
                                                                                when model.providerRegistry is
                                                                                    Nothing ->
                                                                                        GrenTask.fail (AgentRegistry.FileSystemError "Provider registry not available")

                                                                                    Just providerReg ->
                                                                                        ProviderRegistry.getProvider providerReg providerName
                                                                                            |> GrenTask.map (\_ -> agentConfig)
                                                                                            |> GrenTask.onError
                                                                                                (\_ ->
                                                                                                    GrenTask.fail (AgentRegistry.FileSystemError ("Agent '" ++ params.agentName ++ "' references provider '" ++ providerName ++ "' which does not exist"))
                                                                                                )

                                                                    InternalAgent _ ->
                                                                        GrenTask.succeed agentConfig
                                                            )
                                                        |> GrenTask.attempt
                                                            (\result ->
                                                                GotAgentLookup
                                                                    { taskId = taskId
                                                                    , prompt = params.prompt
                                                                    , response = response
                                                                    , result = result
                                                                    }
                                                            )

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.CompleteHandoff taskId ->
                            when parseCompleteHandoffBody request is
                                Ok params ->
                                    Api.requestCompleteHandoff ctx taskId params (mutatingToMsg "tasks_changed")

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.ListAgents ->
                            when { agentReg = model.agentRegistry, providerReg = model.providerRegistry } is
                                { agentReg = Just ar, providerReg = Just pr } ->
                                    Api.requestAgents ar pr toMsg

                                _ ->
                                    sendServiceUnavailable response

                        Router.GetAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgent agentReg agentName toMsg

                        Router.CreateAgent ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestCreateAgent agentReg agentConfig (mutatingToMsg "agents_changed")

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestUpdateAgent agentReg agentName agentConfig (mutatingToMsg "agents_changed")

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestDeleteAgent agentReg agentName (mutatingToMsg "agents_changed")

                        Router.ListProviders ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    Api.requestProviders providerReg toMsg

                        Router.GetProvider providerName ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    Api.requestProvider providerReg providerName toMsg

                        Router.CreateProvider ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    when parseProviderBody request is
                                        Ok providerConfig ->
                                            Api.requestCreateProvider providerReg providerConfig (mutatingToMsg "providers_changed")

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateProvider providerName ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    when parseProviderBody request is
                                        Ok providerConfig ->
                                            Api.requestUpdateProvider providerReg providerName providerConfig (mutatingToMsg "providers_changed")

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteProvider providerName ->
                            when { providerReg = model.providerRegistry, agentReg = model.agentRegistry } is
                                { providerReg = Just pr, agentReg = Just ar } ->
                                    Api.requestDeleteProvider pr ar providerName (mutatingToMsg "providers_changed")

                                _ ->
                                    sendServiceUnavailable response

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response

                        -- Config routes are handled in the outer when branch
                        Router.GetConfig ->
                            sendNotFound response

                        Router.UpdateConfig ->
                            sendNotFound response

                        Router.SelectConfig ->
                            sendNotFound response

                        Router.CreateConfig ->
                            sendNotFound response

                        Router.GetConfigDefaults ->
                            sendNotFound response

                        Router.ListWorkspaces ->
                            sendNotFound response

                        Router.RemoveWorkspace _ ->
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    let
        body =
            Encode.object
                [ { key = "error"
                  , value =
                        Encode.object
                            [ { key = "code", value = Encode.string "BAD_REQUEST" }
                            , { key = "message", value = Encode.string message }
                            ]
                  }
                ]
                |> Encode.encode 0
    in
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| Send a 409 Conflict response.
-}
sendConflict : Response -> String -> Cmd Msg
sendConflict response message =
    let
        body =
            Encode.object
                [ { key = "error"
                  , value =
                        Encode.object
                            [ { key = "code", value = Encode.string "CONFLICT" }
                            , { key = "message", value = Encode.string message }
                            ]
                  }
                ]
                |> Encode.encode 0
    in
    response
        |> Response.setStatus 409
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\description source ->
                    { description = description
                    , source = source
                    }
                )
                (Decode.field "description" Decode.string)
                (Decode.field "source" Types.sourceInfoDecoder)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.

    The frontend sends status as a nested object matching the encoding format:
    {"status": {"type": "active"}} or {"status": {"type": "failed", "message": "..."}}
    We also accept the flat format {"status": "active"} for backward compatibility
    with direct API callers.
-}
parseStatusBody : HttpServer.Request -> Result String TaskStatus
parseStatusBody request =
    let
        -- Nested object format: {"status": {"type": "active", "agent": "name"}}
        nestedDecoder =
            Decode.field "status"
                (Decode.field "type" Decode.string
                    |> Decode.andThen
                        (\statusType ->
                            when statusType is
                                "pending" ->
                                    Decode.succeed Pending

                                "planning" ->
                                    Decode.oneOf
                                        [ Decode.field "agent" Decode.string
                                            |> Decode.map (\agent -> Planning { agentName = agent })
                                        , Decode.succeed (Planning { agentName = "" })
                                        ]

                                "awaiting_input" ->
                                    Decode.succeed AwaitingInput

                                "planned" ->
                                    Decode.succeed ReadyToStart

                                "active" ->
                                    Decode.oneOf
                                        [ Decode.field "agent" Decode.string
                                            |> Decode.map (\agent -> Active { agentName = agent })
                                        , Decode.succeed (Active { agentName = "" })
                                        ]

                                "waiting" ->
                                    Decode.oneOf
                                        [ Decode.field "agent" Decode.string
                                            |> Decode.map (\agent -> Waiting { agentName = agent })
                                        , Decode.succeed (Waiting { agentName = "" })
                                        ]

                                "completed" ->
                                    Decode.succeed Completed

                                "failed" ->
                                    Decode.oneOf
                                        [ Decode.field "message" Decode.string
                                            |> Decode.map Failed
                                        , Decode.succeed (Failed "")
                                        ]

                                _ ->
                                    Decode.fail ("Unknown status type: " ++ statusType)
                        )
                )

        -- Flat string format: {"status": "active"} (backward compatibility)
        -- Agent info placeholder (empty) — requestUpdateStatus resolves from current task
        flatDecoder =
            Decode.field "status" Decode.string
                |> Decode.andThen
                    (\statusStr ->
                        when statusStr is
                            "pending" ->
                                Decode.succeed Pending

                            "planning" ->
                                Decode.succeed (Planning { agentName = "" })

                            "awaiting_input" ->
                                Decode.succeed AwaitingInput

                            "planned" ->
                                Decode.succeed ReadyToStart

                            "active" ->
                                Decode.succeed (Active { agentName = "" })

                            "waiting" ->
                                Decode.succeed (Waiting { agentName = "" })

                            "completed" ->
                                Decode.succeed Completed

                            "failed" ->
                                Decode.succeed (Failed "")

                            _ ->
                                Decode.fail ("Unknown status: " ++ statusStr)
                    )

        decoder =
            Decode.oneOf [ nestedDecoder, flatDecoder ]
    in
    when HttpServer.bodyFromJson decoder request is
        Ok status ->
            Ok status

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"


{-| Parse the body for PUT /api/tasks/:id/planning.
-}
parseUpdatePlanningBody : HttpServer.Request -> Result String Api.UpdatePlanningParams
parseUpdatePlanningBody request =
    let
        decoder =
            Decode.map4
                (\summary requirements acceptanceCriteria plan ->
                    { summary = summary
                    , requirements = requirements
                    , acceptanceCriteria = acceptanceCriteria
                    , plan = plan
                    }
                )
                (Decode.maybe (Decode.field "summary" Decode.string))
                (Decode.maybe (Decode.field "requirements" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "acceptanceCriteria" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "plan" (Decode.array Decode.string)))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for planning update"



{-| Parse the body for POST /api/tasks/:id/handoff.
-}
parseStartHandoffBody : HttpServer.Request -> Result String Api.StartAgentParams
parseStartHandoffBody request =
    let
        decoder =
            Decode.map2
                (\agentName prompt ->
                    { agentName = agentName
                    , prompt = prompt
                    }
                )
                (Decode.field "agentName" Decode.string)
                (Decode.field "prompt" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff"


{-| Parse the body for PUT /api/tasks/:id/handoff/complete.
-}
parseCompleteHandoffBody : HttpServer.Request -> Result String Api.CompleteAgentParams
parseCompleteHandoffBody request =
    let
        decoder =
            Decode.map (\output -> { output = output })
                (Decode.field "output" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff completion"


{-| Parse the body for POST /api/tasks/:id/answers.
-}
parseSubmitAnswersBody : HttpServer.Request -> Result String (Array String)
parseSubmitAnswersBody request =
    let
        decoder =
            Decode.field "answers" (Decode.array Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok answers ->
            Ok answers

        Err _ ->
            Err "Invalid JSON body for answer submission"


{-| Parse the body for PUT /api/tasks/:id/agent-tools.
-}
parseToolGrantBody : HttpServer.Request -> Result String { addTools : Array String, removeTools : Array String }
parseToolGrantBody request =
    let
        decoder =
            Decode.map2
                (\addTools removeTools ->
                    { addTools = addTools
                    , removeTools = removeTools
                    }
                )
                (Decode.maybe (Decode.field "addTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
                (Decode.maybe (Decode.field "removeTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for tool grant"


{-| Parse the body for POST /api/agents or PUT /api/agents/:name.
-}
parseAgentBody : HttpServer.Request -> Result String Types.AgentConfig
parseAgentBody request =
    when HttpServer.bodyFromJson Types.agentConfigDecoder request is
        Ok agentConfig ->
            Ok agentConfig

        Err _ ->
            Err "Invalid JSON body for agent config"


{-| Parse the body for POST /api/providers or PUT /api/providers/:name.
-}
parseProviderBody : HttpServer.Request -> Result String Types.ProviderConfig
parseProviderBody request =
    when HttpServer.bodyFromJson Types.providerConfigDecoder request is
        Ok providerConfig ->
            Ok providerConfig

        Err _ ->
            Err "Invalid JSON body for provider config"


-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        httpSub =
            when model.server is
                Just server ->
                    HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

                Nothing ->
                    Sub.none

        wsSubs =
            when model.websocketServer is
                Just wsServer ->
                    Sub.batch
                        [ WebSocketServer.onConnection wsServer WsClientConnected
                        , WebSocketServer.onClose wsServer (\conn reason -> WsClientDisconnected { connection = conn, reason = reason })
                        , WebSocketServer.onError wsServer (\conn err -> WsClientError { connection = conn, error = err })
                        ]

                Nothing ->
                    Sub.none
    in
    Sub.batch
        [ httpSub
        , wsSubs
        ]



-- WEBSOCKET BROADCAST


{-| Broadcast a JSON message to all connected WebSocket clients.

The message is a JSON object with `type` and `data` fields.
This is fire-and-forget: errors on individual connections are ignored.
Stale connections are cleaned up by the WsClientDisconnected and
WsClientError subscription handlers.
-}
broadcastToClients : Model -> String -> Encode.Value -> Cmd Msg
broadcastToClients model messageType data =
    let
        payload =
            Encode.object
                [ { key = "type", value = Encode.string messageType }
                , { key = "data", value = data }
                ]
                |> Encode.encode 0

        sendToOne connection =
            WsConnection.send connection payload
                |> GrenTask.attempt WsBroadcastResult
    in
    model.websocketClients
        |> Dict.values
        |> Array.map sendToOne
        |> Cmd.batch



-- PROVIDER/EXECUTOR EVENT HANDLING


{-| Handle a ProviderEvent from a running agent.

Provider events are emitted asynchronously by the Provider during agent
execution. This function routes each event to the appropriate Executor
message.

- `ToolCallReceived`: A tool call arrived (for CLI agents, from an HTTP
  callback). Forward to the Executor for tool processing.
- `AgentCompleted`: The agent finished. Forward to the Executor and
  then delegate to the appropriate completion handler.
- `AgentFailed`: The agent errored. Forward to the Executor and then
  delegate to the appropriate failure handler.
-}
handleProviderEvent : Model -> TaskId -> Provider.ProviderEvent -> { model : Model, command : Cmd Msg }
handleProviderEvent model taskId event =
    let
        taskIdStr =
            Id.taskIdToString taskId
    in
    when Dict.get taskIdStr model.activeExecutors is
        Nothing ->
            -- No executor found. For AgentFailed events this can happen if the
            -- provider resolution itself failed (the Spawning executor was already
            -- cleaned up). Just log and move on.
            { model = model
            , command = Logging.logWarn model.logger ("ProviderEvent for unknown executor: " ++ taskIdStr) NoOp
            }

        Just (Spawning spawning) ->
            -- Provider event arrived for a spawning executor. This happens when
            -- provider resolution fails — the async task emits AgentFailed.
            -- Clean up the spawning placeholder and resolve any deferred response.
            when event is
                Provider.AgentFailed error ->
                    let
                        deferredCmd =
                            when spawning.deferredResponse is
                                Just deferredResponse ->
                                    Api.sendApiResponse deferredResponse
                                        (Api.ApiError { statusCode = 500, code = "AGENT_FAILED", message = error })

                                Nothing ->
                                    Cmd.none
                    in
                    { model = { model | activeExecutors = Dict.remove taskIdStr model.activeExecutors }
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Agent failed during spawn for task " ++ taskIdStr ++ ": " ++ error) NoOp
                            , deferredCmd
                            ]
                    }

                _ ->
                    -- Unexpected event for a spawning executor; discard
                    { model = model
                    , command = Logging.logWarn model.logger ("Unexpected ProviderEvent for spawning executor: " ++ taskIdStr) NoOp
                    }

        Just (AgentActive executor) ->
            handleProviderEventForExecutor model taskId taskIdStr executor event

        Just (ActiveHandoff { executor }) ->
            handleProviderEventForExecutor model taskId taskIdStr executor event


{-| Handle a provider event for an active executor.
-}
handleProviderEventForExecutor :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> Provider.ProviderEvent
    -> { model : Model, command : Cmd Msg }
handleProviderEventForExecutor model taskId taskIdStr executor event =
    -- Convert ProviderEvent to an Executor message and process it
    let
        -- Extract session ID from AgentCompleted and store it on the executor
        currentState =
            Maybe.withDefault (AgentActive executor) (Dict.get taskIdStr model.activeExecutors)

        updatedExecutorState =
            when event is
                Provider.AgentCompleted { sessionId } ->
                    when sessionId is
                        Just sid ->
                            updateActiveExecutor (\e -> { e | sessionId = Just sid }) currentState

                        Nothing ->
                            currentState

                _ ->
                    currentState

        modelWithSessionId =
            { model | activeExecutors = Dict.set taskIdStr updatedExecutorState model.activeExecutors }

        executorMsg =
            when event is
                Provider.ToolCallReceived toolCall ->
                    Executor.ToolCallReceived
                        { id = toolCall.id
                        , name = toolCall.name
                        , input = toolCall.input
                        }

                Provider.AgentCompleted { output } ->
                    Executor.AgentCompleted output

                Provider.AgentFailed error ->
                    Executor.AgentFailed error
    in
    handleExecutorMsg modelWithSessionId taskId executorMsg


{-| Handle a message for the Executor.

Runs `Executor.update` with the message, then inspects the returned
`UpdateEffect` to determine what action to take:

- `NoEffect`: Just update the executor state.
- `DeliverToolResults`: All pending tool calls are complete. Call
  `provider.deliverToolResults` to send results back to the agent.
- `DeferredActionRequired`: A tool call produced a deferred result
  (handoff or planner output) that needs special handling.

When the Executor transitions to `Complete` or `Failed`,
delegates to the appropriate completion handler.
-}
handleExecutorMsg : Model -> TaskId -> Executor.Msg -> { model : Model, command : Cmd Msg }
handleExecutorMsg model taskId executorMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId
    in
    when Dict.get taskIdStr model.activeExecutors is
        Nothing ->
            { model = model
            , command = Logging.logWarn model.logger ("ExecutorMsg for unknown executor: " ++ taskIdStr) NoOp
            }

        Just (Spawning _) ->
            -- Executor is still spawning — discard the message
            { model = model
            , command = Logging.logWarn model.logger ("ExecutorMsg for spawning executor: " ++ taskIdStr) NoOp
            }

        Just executorState ->
            -- executorState is AgentActive or ActiveHandoff — extract the active executor
            when activeExecutorFromState executorState is
                Nothing ->
                    -- Should not happen since we already handled Spawning above
                    { model = model
                    , command = Cmd.none
                    }

                Just executor ->
                    let
                        toolExecutionContext =
                            makeToolExecutionContext model taskId executor.agentConfig

                        executorConfig =
                            { executeTool =
                                ToolExecution.executeToolCall toolExecutionContext
                            , toMsg =
                                \msg -> GotExecutorMsg { taskId = taskId, msg = msg }
                            }

                        updateResult =
                            Executor.update executorMsg executor.executorModel executorConfig

                        updatedExecutor =
                            { executor | executorModel = updateResult.model }

                        updatedExecutorState =
                            updateActiveExecutor (\_ -> updatedExecutor) executorState

                        updatedModel =
                            { model | activeExecutors = Dict.set taskIdStr updatedExecutorState model.activeExecutors }
                    in
                    -- Handle the effect
                    when updateResult.effect is
                        Executor.NoEffect ->
                            -- Check if executor transitioned to complete/failed
                            handleExecutorStateTransition updatedModel taskId taskIdStr updatedExecutor updateResult.cmd

                        Executor.DeliverToolResults results ->
                            -- Send results back to the agent via the provider
                            let
                                deliverResult =
                                    executor.provider.deliverToolResults updatedExecutor.providerState results

                                executorWithUpdatedProvider =
                                    { updatedExecutor | providerState = deliverResult.state }

                                finalExecutorState =
                                    updateActiveExecutor (\_ -> executorWithUpdatedProvider) executorState

                                finalModel =
                                    { model | activeExecutors = Dict.set taskIdStr finalExecutorState model.activeExecutors }

                                -- Record tool events for each result
                                logToolEvents =
                                    results
                                        |> Array.map
                                            (\toolResult ->
                                                when model.registry is
                                                    Just reg ->
                                                        Registry.recordEvent reg taskId
                                                            { eventType = ToolExecuted
                                                            , data =
                                                                Dict.empty
                                                                    |> Dict.set "tool" toolResult.toolName
                                                                    |> Dict.set "status" (if toolResult.isError then "error" else "success")
                                                                    |> Dict.set "output" toolResult.output
                                                            }
                                                            |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                                            |> GrenTask.perform (\_ -> NoOp)

                                                    Nothing ->
                                                        Cmd.none
                                            )
                                            |> Cmd.batch
                            in
                            { model = finalModel
                            , command =
                                Cmd.batch
                                    [ updateResult.cmd
                                    , deliverResult.cmd
                                    , logToolEvents
                                    , broadcastToClients finalModel "tasks_changed" Encode.null
                                    ]
                            }

                        Executor.DeferredActionRequired action ->
                            handleDeferredAction updatedModel taskId taskIdStr updatedExecutor action updateResult.cmd


{-| Check if the executor has transitioned to a terminal state and handle it.
-}
handleExecutorStateTransition :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> Cmd Msg
    -> { model : Model, command : Cmd Msg }
handleExecutorStateTransition model taskId taskIdStr executor additionalCmd =
    let
        -- Look up the handoff response from the executor state if this is an ActiveHandoff
        maybeHandoffResponse =
            when Dict.get taskIdStr model.activeExecutors is
                Just (ActiveHandoff { deferredResponse }) ->
                    Just deferredResponse

                _ ->
                    Nothing

        dispatchCompletion result =
            when executor.agentKind is
                SystemAgent ->
                    handlePlannerComplete model taskId taskIdStr executor result

                UserAgent ->
                    handleUserAgentComplete model taskId taskIdStr executor maybeHandoffResponse result
    in
    when executor.executorModel is
        Executor.Complete { output } ->
            let
                completionResult =
                    dispatchCompletion (Ok output)
            in
            { model = completionResult.model
            , command = Cmd.batch [ completionResult.command, additionalCmd ]
            }

        Executor.Failed { error } ->
            let
                completionResult =
                    dispatchCompletion (Err error)
            in
            { model = completionResult.model
            , command = Cmd.batch [ completionResult.command, additionalCmd ]
            }

        _ ->
            -- Executor is still running or idle
            { model = model
            , command = additionalCmd
            }


{-| Handle a deferred action from the Executor.

Deferred actions require Main.gren to intervene before the executor can
continue (or before the conversation ends):

- `Handoff`: Look up the target agent and start a deferred handoff.
- `PlannerOutputReady`: Store the planner output and acknowledge it.
-}
handleDeferredAction :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> Executor.DeferredAction
    -> Cmd Msg
    -> { model : Model, command : Cmd Msg }
handleDeferredAction model taskId taskIdStr executor action additionalCmd =
    when action is
        Executor.Handoff { toolCallId, agentName, prompt } ->
            -- Look up the target agent for the deferred handoff
            when model.agentRegistry is
                Nothing ->
                    { model = model
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Deferred handoff failed: Agent registry not available") NoOp
                            , additionalCmd
                            ]
                    }

                Just agentReg ->
                    -- Look up the pending HTTP response for the handoff tool call
                    -- by its tool call ID from the provider state.
                    let
                        pendingResponse =
                            when executor.providerState is
                                Provider.CliProviderState cliState ->
                                    Dict.get toolCallId cliState.pendingHttpResponses

                                _ ->
                                    Nothing
                    in
                    when pendingResponse is
                        Nothing ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ Logging.logError model.logger ("Deferred handoff: no pending HTTP response for tool call") NoOp
                                    , additionalCmd
                                    ]
                            }

                        Just response ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ AgentRegistry.getAgent agentReg agentName
                                        |> GrenTask.mapError AgentRegistry.errorToString
                                        |> GrenTask.andThen
                                            (\agentConfig ->
                                                if Types.isInternalAgent agentConfig then
                                                    GrenTask.fail ("Cannot hand off to internal agent: " ++ Types.agentConfigName agentConfig)
                                                else
                                                    GrenTask.succeed agentConfig
                                            )
                                        |> GrenTask.attempt
                                            (\lookupResult ->
                                                when lookupResult is
                                                    Err errMsg ->
                                                        GotApiResult { response = response, result = Api.ApiError { statusCode = 400, code = "BAD_REQUEST", message = errMsg } }

                                                    Ok agentConfig ->
                                                        GotDeferredHandoffLookup
                                                            { taskId = taskId
                                                            , prompt = prompt
                                                            , response = response
                                                            , agentConfig = agentConfig
                                                            }
                                            )
                                    , additionalCmd
                                    ]
                            }

        Executor.PlannerOutputReady { toolCallId, plannerOutput } ->
            -- Store the planner output on the executor state and acknowledge
            -- the tool call by sending a success response back to chorus-tools.
            let
                -- Record the planner output event
                recordEventCmd =
                    when model.registry is
                        Nothing ->
                            Cmd.none

                        Just reg ->
                            Registry.recordEvent reg taskId
                                { eventType = PlannerOutputSubmitted
                                , data =
                                    Dict.empty
                                        |> Dict.set "tool" "planner-output"
                                }
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                |> GrenTask.perform (\_ -> NoOp)

                -- Deliver a success result back to the provider for the planner-output tool
                deliverResult =
                    executor.provider.deliverToolResults executor.providerState
                        [ { toolCallId = toolCallId
                          , toolName = "planner-output"
                          , output = Encode.encode 0 (Encode.object [ { key = "success", value = Encode.bool True } ])
                          , isError = False
                          }
                        ]

                executorWithProvider =
                    { executor | providerState = deliverResult.state }

                -- Transition executor back to Running with the planner output stored
                -- so extractPlannerOutput can find it when the agent completes.
                executorWithOutput =
                    { executorWithProvider
                        | executorModel =
                            Executor.Running
                                { pendingToolCalls = Dict.empty
                                , completedResults = []
                                , completionReport = Nothing
                                , plannerOutput = Just plannerOutput
                                }
                    }

                -- Preserve the executor variant (AgentActive or ActiveHandoff)
                finalExecutorState =
                    when Dict.get taskIdStr model.activeExecutors is
                        Just (ActiveHandoff { deferredResponse }) ->
                            ActiveHandoff { executor = executorWithOutput, deferredResponse = deferredResponse }

                        _ ->
                            AgentActive executorWithOutput

                finalModel =
                    { model | activeExecutors = Dict.set taskIdStr finalExecutorState model.activeExecutors }
            in
            { model = finalModel
            , command =
                Cmd.batch
                    [ recordEventCmd
                    , deliverResult.cmd
                    , additionalCmd
                    ]
            }


{-| Extract the completion report from an executor model, if available.
-}
extractCompletionReport : Executor.Model -> Maybe Types.CompletionReport
extractCompletionReport executorModel =
    when executorModel is
        Executor.Running state ->
            state.completionReport

        Executor.Complete state ->
            state.completionReport

        Executor.Failed state ->
            state.completionReport

        _ ->
            Nothing


{-| Extract the planner output from an executor model, if available.
-}
extractPlannerOutput : Executor.Model -> Maybe Types.PlannerOutput
extractPlannerOutput executorModel =
    when executorModel is
        Executor.Running state ->
            state.plannerOutput

        Executor.Complete state ->
            state.plannerOutput

        Executor.Failed state ->
            state.plannerOutput

        _ ->
            Nothing



-- PLANNER


{-| Spawn the task-validator agent for a newly created task.

Registers the planner as an active executor with isSystemAgent=True,
sets the task status to Planning with agent "task-validator", and emits GotAgentComplete
when the planner process exits. The planner submits its structured output
via the planner-output tool during execution.
-}
dispatchPlanner : Model -> AgentRegistry.AgentRegistry -> TaskId -> String -> { model : Model, command : Cmd Msg }
dispatchPlanner model agentReg taskId description =
    let
        taskIdStr =
            Id.taskIdToString taskId
    in
    -- First check if system agent provider is configured
    when model.workspaceConfig is
        Nothing ->
            failPlannerEarly model taskId "No workspace config loaded - cannot run system agent"

        Just wc ->
            when wc.systemAgentProvider is
                NotConfigured ->
                    failPlannerEarly model taskId "System agent provider is not configured. Please configure it in System Settings."

                ProviderRef providerName ->
                    let
                        -- Async task chain:
                        -- 1. Look up "task-validator" agent config
                        -- 2. Set task status to Planning (with agent), record PlanningStarted event
                        -- 3. Resolve the system agent provider config
                        -- 4. Emit GotProviderResolved to trigger spawn
                        spawnCmd =
                            AgentRegistry.getAgent agentReg "task-validator"
                                |> GrenTask.mapError AgentRegistry.errorToString
                                |> GrenTask.andThen
                                    (\agentConfig ->
                                        -- Set task status to Planning and record planning_started event
                                        when model.registry is
                                            Nothing ->
                                                GrenTask.succeed agentConfig

                                            Just registry ->
                                                Registry.updateStatus registry taskId (Types.Planning { agentName = "task-validator" })
                                                    |> GrenTask.andThen
                                                        (\_ ->
                                                            Registry.recordEvent registry taskId
                                                                { eventType = PlanningStarted
                                                                , data =
                                                                    Dict.empty
                                                                        |> Dict.set "description" description
                                                                }
                                                                |> GrenTask.map (\_ -> agentConfig)
                                                        )
                                                    |> GrenTask.onError (\_ -> GrenTask.succeed agentConfig)
                                    )
                                |> GrenTask.andThen
                                    (\agentConfig ->
                                        -- Resolve the system agent provider
                                        when model.providerRegistry is
                                            Nothing ->
                                                GrenTask.fail "Provider registry not available"

                                            Just providerReg ->
                                                ProviderRegistry.getProvider providerReg providerName
                                                    |> GrenTask.mapError (\_ -> "System agent provider '" ++ providerName ++ "' not found in provider registry")
                                                    |> GrenTask.map (\providerConfig -> { agentConfig = agentConfig, providerConfig = providerConfig })
                                    )
                                |> GrenTask.map Ok
                                |> GrenTask.onError
                                    (\errMsg ->
                                        GrenTask.succeed (Err errMsg)
                                    )
                                |> GrenTask.perform
                                    (\result ->
                                        when result is
                                            Err errMsg ->
                                                GotProviderEvent
                                                    { taskId = taskId
                                                    , event = Provider.AgentFailed ("Planner dispatch failed: " ++ errMsg)
                                                    }

                                            Ok { agentConfig, providerConfig } ->
                                                GotProviderResolved
                                                    { taskId = taskId
                                                    , prompt = description
                                                    , agentConfig = agentConfig
                                                    , providerConfig = providerConfig
                                                    , isSystemAgent = True
                                                    }
                                    )

                        -- Register a Spawning executor state immediately so that
                        -- tool calls arriving before GotProviderResolved are rejected
                        -- with "Agent is still starting" rather than silently discarded.
                        executorState =
                            Spawning
                                { taskId = taskId
                                , agentName = "task-validator"
                                , agentConfig = InternalAgent { name = "task-validator", instructions = "" }
                                , agentKind = SystemAgent
                                , deferredResponse = Nothing
                                }
                    in
                    { model =
                        { model
                            | activeExecutors = Dict.set taskIdStr executorState model.activeExecutors
                        }
                    , command = spawnCmd
                    }


{-| Fail a planner dispatch early due to a configuration error.

When the workspace config is missing or the system agent provider is not
configured, we cannot spawn a planner. Instead of emitting GotAgentComplete
(which would fail to find an executor in activeExecutors), we fail the task
directly with a descriptive error.
-}
failPlannerEarly : Model -> TaskId -> String -> { model : Model, command : Cmd Msg }
failPlannerEarly model taskId errorMessage =
    let
        taskIdStr =
            Id.taskIdToString taskId
    in
    when model.registry is
        Nothing ->
            { model = model
            , command = Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errorMessage) NoOp
            }

        Just registry ->
            let
                planningFailedEvent =
                    Just
                        { eventType = PlanningFailed
                        , data =
                            Dict.empty
                                |> Dict.set "error" ("Planner failed: " ++ errorMessage)
                        }

                ctx =
                    makeApiContext model registry
            in
            { model = model
            , command =
                Cmd.batch
                    [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner failed: " ++ errorMessage)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                    , Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errorMessage) NoOp
                    , broadcastToClients model "tasks_changed" Encode.null
                    ]
            }


{-| Handle planner (system agent) completion.

Uses AgentManager.processPlannerCompletion to determine the result, then
applies the plan, sets questions, retries, or records a failure.
-}
handlePlannerComplete :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> Result String String
    -> { model : Model, command : Cmd Msg }
handlePlannerComplete model taskId taskIdStr executor result =
    let
        exitResult =
            result

        plannerOutput =
            extractPlannerOutput executor.executorModel

        completionResult =
            AgentManager.processPlannerCompletion
                { exitResult = exitResult
                , plannerOutput = plannerOutput
                }

        -- Remove executor from active state
        updatedModel =
            { model | activeExecutors = Dict.remove taskIdStr model.activeExecutors }
    in
    when completionResult is
        AgentManager.PlanReady fields ->
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command = Logging.logError model.logger "Planner completed but registry not available" NoOp
                    }

                Just registry ->
                    let
                        mergeInto =
                            \source target -> Dict.foldl Dict.set target source

                        baseDict =
                            Dict.empty
                                |> Dict.set "summary" fields.summary
                                |> mergeInto (indexedArrayToDict "requirement_" fields.requirements)
                                |> mergeInto (indexedArrayToDict "acceptance_criteria_" fields.acceptanceCriteria)
                                |> mergeInto (indexedArrayToDict "plan_step_" fields.plan)

                        planningCompletedData =
                            when fields.assignedAgent is
                                Just agent ->
                                    baseDict
                                        |> Dict.set "assigned_agent" agent

                                Nothing ->
                                    baseDict

                        ctx =
                            makeApiContext model registry
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ Api.requestApplyPlan ctx taskId fields planningCompletedData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                            , Logging.logInfo model.logger ("Planner produced plan for task " ++ taskIdStr) NoOp
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }

        AgentManager.QuestionsReady questions ->
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command = Logging.logError model.logger "Planner completed but registry not available" NoOp
                    }

                Just registry ->
                    let
                        questionsEventData =
                            indexedArrayToDict "question_" questions
                                |> Dict.set "questionCount" (String.fromInt (Array.length questions))

                        ctx =
                            makeApiContext model registry
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ Api.requestSetQuestions ctx taskId questions questionsEventData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                            , Logging.logInfo model.logger ("Planner asked " ++ String.fromInt (Array.length questions) ++ " questions for task " ++ taskIdStr) NoOp
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }

        AgentManager.PlannerExitError errMsg ->
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command = Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                    }

                Just registry ->
                    let
                        planningFailedEvent =
                            Just
                                { eventType = PlanningFailed
                                , data =
                                    Dict.empty
                                        |> Dict.set "error" ("Planner failed: " ++ errMsg)
                                }

                        ctx =
                            makeApiContext model registry
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner failed: " ++ errMsg)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                            , Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }

        AgentManager.PlannerOutputMissing ->
            -- Planner exited without calling planner-output tool
            -- Attempt to resume the session with a reminder before failing
            let
                canRetry =
                    AgentManager.shouldRetry { retryCount = executor.retryCount, maxRetries = 1 }

                hasSessionId =
                    executor.sessionId /= Nothing
            in
            if canRetry && hasSessionId then
                -- Resume the session with a reminder to call planner-output
                let
                    resumeSessionId =
                        executor.sessionId

                    reminderMessage =
                        "You exited without calling the planner-output tool. You MUST call it before finishing. Use Bash to invoke:\nchorus-tools <workspace-root> '{\"tool\": \"planner-output\", ...}'"

                    resumeStartConfig =
                        { agentSpec =
                            { name = executor.agentName
                            , systemPrompt = ""
                            }
                        , message = reminderMessage
                        , workspaceRoot = initialAgentDir model
                        , taskId = Just taskIdStr
                        , allowedTools = Nothing
                        , resumeSessionId = resumeSessionId
                        , onEvent = \event -> GotProviderEvent { taskId = taskId, event = event }
                        }

                    startResult =
                        executor.provider.startAgent executor.providerState resumeStartConfig

                    retriedExecutor =
                        { executor
                            | retryCount = executor.retryCount + 1
                            , executorModel = Executor.Idle
                            , sessionId = Nothing
                            , providerState = startResult.state
                        }

                    -- Use `model` (not `updatedModel`) to preserve the executor in activeExecutors
                    retryModel =
                        { model | activeExecutors = Dict.set taskIdStr (AgentActive retriedExecutor) model.activeExecutors }
                in
                { model = retryModel
                , command =
                    Cmd.batch
                        [ startResult.cmd
                        , Logging.logWarn model.logger ("Planner exited without calling planner-output tool for task " ++ taskIdStr ++ " — resuming session (retry " ++ String.fromInt (executor.retryCount + 1) ++ ")") NoOp
                        ]
                }

            else
                -- No retry possible — fail the task
                when model.registry is
                    Nothing ->
                        { model = updatedModel
                        , command = Logging.logError model.logger ("Planner exited without calling planner-output tool for task " ++ taskIdStr) NoOp
                        }

                    Just registry ->
                        let
                            planningFailedEvent =
                                Just
                                    { eventType = PlanningFailed
                                    , data =
                                        Dict.empty
                                            |> Dict.set "error" "Planner exited without calling planner-output tool"
                                    }

                            ctx =
                                makeApiContext model registry
                        in
                        { model = updatedModel
                        , command =
                            Cmd.batch
                                [ Api.requestUpdateStatus ctx taskId (Types.Failed "Planner exited without calling planner-output tool") planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                , Logging.logError model.logger ("Planner exited without calling planner-output tool for task " ++ taskIdStr) NoOp
                                , broadcastToClients updatedModel "tasks_changed" Encode.null
                                ]
                        }


{-| Handle user agent (non-system) completion.

Uses AgentManager.processAgentCompletion to determine the result, then
completes the handoff record and resolves any deferred responses.
-}
handleUserAgentComplete :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> Maybe Response
    -> Result String String
    -> { model : Model, command : Cmd Msg }
handleUserAgentComplete model taskId taskIdStr executor maybeDeferredResponse result =
    let
        completionReport =
            extractCompletionReport executor.executorModel

        completionResult =
            AgentManager.processAgentCompletion
                { exitResult = result
                , completionReport = completionReport
                }

        -- Use the appropriate complete function based on whether this was a handoff
        requestComplete =
            when maybeDeferredResponse is
                Just _ ->
                    Api.requestCompleteHandoff

                Nothing ->
                    Api.requestCompleteAgent

        -- Remove executor from active state
        updatedModel =
            { model
                | activeExecutors = Dict.remove taskIdStr model.activeExecutors
            }

        -- Build the deferred response command if there's a pending response
        deferredResponseCmd =
            when maybeDeferredResponse is
                Nothing ->
                    Cmd.none

                Just deferredResponse ->
                    let
                        rawOutput =
                            when result is
                                Ok text ->
                                    text

                                Err errMsg ->
                                    "Agent failed: " ++ errMsg

                        responseBody =
                            Encode.object
                                [ { key = "agent_name", value = Encode.string executor.agentName }
                                , { key = "output", value = Encode.string rawOutput }
                                ]
                                |> Encode.encode 0
                    in
                    Api.sendApiResponse deferredResponse
                        (Api.ApiSuccess { statusCode = 200, body = responseBody })
    in
    when completionResult is
        AgentManager.CompletedWithReport _ ->
            -- Completion report already handled status/output via tool; just complete handoff record timestamps
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command = deferredResponseCmd
                    }

                Just registry ->
                    let
                        ctx =
                            makeApiContext model registry

                        rawOutput =
                            when result is
                                Ok text ->
                                    text

                                Err errMsg ->
                                    "Agent exited with error: " ++ errMsg
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ requestComplete ctx taskId { output = rawOutput }
                                (\apiResult -> GotInternalApiResult apiResult)
                            , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " (completion report received)") NoOp
                            , deferredResponseCmd
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }

        AgentManager.CompletedWithoutReport outputText ->
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger "Agent completed but registry not available" NoOp
                            , deferredResponseCmd
                            ]
                    }

                Just registry ->
                    let
                        ctx =
                            makeApiContext model registry
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ requestComplete ctx taskId { output = outputText }
                                (\apiResult -> GotInternalApiResult apiResult)
                            , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " without completion report (output length: " ++ String.fromInt (String.unitLength outputText) ++ ")") NoOp
                            , deferredResponseCmd
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }

        AgentManager.AgentExitError errMsg ->
            when model.registry is
                Nothing ->
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                            , deferredResponseCmd
                            ]
                    }

                Just registry ->
                    let
                        ctx =
                            makeApiContext model registry
                    in
                    { model = updatedModel
                    , command =
                        Cmd.batch
                            [ requestComplete ctx taskId { output = "Agent failed: " ++ errMsg }
                                (\apiResult -> GotInternalApiResult apiResult)
                            , Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                            , deferredResponseCmd
                            , broadcastToClients updatedModel "tasks_changed" Encode.null
                            ]
                    }



-- WORKSPACE CONFIG


{-| Return the parent directory of a file path by stripping the last segment.

For example, `parentDirectory "/home/user/chorus.json"` returns `"/home/user"`.
-}
parentDirectory : String -> String
parentDirectory path =
    path
        |> String.split "/"
        |> Array.dropLast 1
        |> String.join "/"


{-| Derive the workspace root directory from the config file path.

Strips the filename (chorus.json) from the config path to get the directory.
This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
workspaceRoot : Model -> String
workspaceRoot model =
    when model.workspaceConfigPath is
        Just configPath ->
            parentDirectory configPath

        Nothing ->
            Debug.todo "workspaceRoot called without a loaded workspace config"


{-| Derive the registry root path from workspace root.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
registryRootPath : Model -> Path
registryRootPath model =
    Path.fromPosixString (workspaceRoot model ++ "/registry")


{-| Build an ApiContext from the model and a registry.

This is a convenience helper to avoid repeating the same record construction
in every branch that needs a registry context.
-}
makeApiContext : Model -> Registry.Registry -> Api.ApiContext
makeApiContext model registry =
    { registry = registry
    , filesystemPermission = model.filesystemPermission
    , secureContext = model.secureContext
    , registryRoot = registryRootPath model
    }


{-| Derive the upload directory from workspace root.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
uploadDir : Model -> String
uploadDir model =
    workspaceRoot model ++ "/uploads"


{-| Get the initial agent directory from workspace config.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
initialAgentDir : Model -> String
initialAgentDir model =
    when model.workspaceConfig is
        Just workspaceConfig ->
            workspaceConfig.initialAgentDirectory

        Nothing ->
            Debug.todo "initialAgentDir called without a loaded workspace config"


{-| Load a workspace config from a filesystem path.

Reads and decodes the `chorus.json` file at the given path.
Returns the decoded config and the path it was loaded from.
-}
loadWorkspaceConfig : FileSystem.Permission -> String -> GrenTask.Task Never (Result String { config : WorkspaceConfig, configPath : String })
loadWorkspaceConfig filesystemPermission configPath =
    let
        path =
            Path.fromPosixString configPath
    in
    FileSystem.readFile filesystemPermission path
        |> GrenTask.mapError (\e -> FileSystem.errorToString e)
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail "Could not decode config file as UTF-8"

                    Just content ->
                        when Decode.decodeString Types.workspaceConfigDecoder content is
                            Ok config ->
                                GrenTask.succeed { config = config, configPath = configPath }

                            Err err ->
                                GrenTask.fail ("Invalid config JSON: " ++ Decode.errorToString err)
            )
        |> GrenTask.map Ok
        |> GrenTask.onError (\err -> GrenTask.succeed (Err err))


{-| Save a workspace config to a filesystem path.
-}
saveWorkspaceConfig : FileSystem.Permission -> String -> WorkspaceConfig -> GrenTask.Task Never (Result String {})
saveWorkspaceConfig filesystemPermission configPath wsConfig =
    let
        path =
            Path.fromPosixString configPath

        json =
            Types.encodeWorkspaceConfig wsConfig
                |> Encode.encode 2

        bytes =
            Bytes.fromString json
    in
    FileSystem.writeFile filesystemPermission bytes path
        |> GrenTask.map (\_ -> Ok {})
        |> GrenTask.onError (\err -> GrenTask.succeed (Err (FileSystem.errorToString err)))


{-| Create a new workspace config with defaults relative to the given directory.
-}
createWorkspaceConfig : FileSystem.Permission -> String -> GrenTask.Task Never (Result String { config : WorkspaceConfig, configPath : String })
createWorkspaceConfig filesystemPermission dirPath =
    let
        configPath =
            dirPath ++ "/chorus.json"

        agentsDir =
            dirPath ++ "/agents"

        wsConfig =
            { allowedAgentDirectories = []
            , initialAgentDirectory = ""
            , systemAgentProvider = NotConfigured
            , serverPort = Nothing
            }

        json =
            Types.encodeWorkspaceConfig wsConfig
                |> Encode.encode 2

        bytes =
            Bytes.fromString json

        configFilePath =
            Path.fromPosixString configPath

        -- Ensure directories exist (propagate errors instead of swallowing)
        ensureDir p =
            FileSystem.makeDirectory filesystemPermission { recursive = True } (Path.fromPosixString p)
                |> GrenTask.map (\_ -> {})
                |> GrenTask.mapError (\err -> FileSystem.errorToString err)
    in
    ensureDir dirPath
        |> GrenTask.andThen (\_ -> ensureDir agentsDir)
        |> GrenTask.andThen
            (\_ ->
                FileSystem.writeFile filesystemPermission bytes configFilePath
                    |> GrenTask.mapError (\err -> FileSystem.errorToString err)
                    |> GrenTask.map (\_ -> Ok { config = wsConfig, configPath = configPath })
            )
        |> GrenTask.onError (\err -> GrenTask.succeed (Err err))



-- CONFIG API HANDLERS


{-| Handle GET /api/config.
-}
handleGetConfig : Model -> Response -> Cmd Msg
handleGetConfig model response =
    when model.workspaceConfig is
        Nothing ->
            response
                |> Response.setStatus 404
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"No workspace config loaded\"}}"
                |> Response.send

        Just config ->
            let
                body =
                    Encode.object
                        [ { key = "data", value = Types.encodeWorkspaceConfig config }
                        , { key = "configPath", value = Encode.string (Maybe.withDefault "" model.workspaceConfigPath) }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus 200
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody body
                |> Response.send


{-| Handle PUT /api/config.

Validates that initialAgentDirectory is one of the allowedAgentDirectories
before saving, as required by the acceptance criteria.
-}
handleUpdateConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleUpdateConfig model request response =
    when { workspaceConfig = model.workspaceConfig, configPath = model.workspaceConfigPath } is
        { workspaceConfig = Just _, configPath = Just currentConfigPath } ->
            when HttpServer.bodyFromJson Types.workspaceConfigDecoder request is
                Err _ ->
                    sendBadRequest response "Invalid JSON body for config update"

                Ok newConfig ->
                    if not (String.isEmpty newConfig.initialAgentDirectory || Array.any (\dir -> dir == newConfig.initialAgentDirectory) newConfig.allowedAgentDirectories) then
                        sendBadRequest response "initialAgentDirectory must be one of the allowedAgentDirectories"
                    else
                        saveWorkspaceConfig model.filesystemPermission currentConfigPath newConfig
                            |> GrenTask.perform
                                (\result ->
                                    when result is
                                        Ok _ ->
                                            GotConfigLoaded
                                                { response = Just response
                                                , deferResponse = False
                                                , result = Ok { config = newConfig, configPath = currentConfigPath }
                                                }

                                        Err errMsg ->
                                            GotApiResult
                                                { response = response
                                                , result = Api.ApiError { statusCode = 500, code = "WRITE_ERROR", message = errMsg }
                                                }
                                )

        _ ->
            sendBadRequest response "No workspace config loaded"


{-| Handle POST /api/config/select.
-}
handleSelectConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleSelectConfig model request response =
    when HttpServer.bodyFromJson (Decode.field "path" Decode.string) request is
        Err _ ->
            sendBadRequest response "Invalid JSON body: requires 'path' field"

        Ok configPath ->
            loadWorkspaceConfig model.filesystemPermission configPath
                |> GrenTask.perform
                    (\result ->
                        GotConfigLoaded { response = Just response, deferResponse = True, result = result }
                    )


{-| Handle POST /api/config/create.
-}
handleCreateConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleCreateConfig model request response =
    when HttpServer.bodyFromJson (Decode.field "path" Decode.string) request is
        Err _ ->
            sendBadRequest response "Invalid JSON body: requires 'path' field (directory)"

        Ok dirPath ->
            createWorkspaceConfig model.filesystemPermission dirPath
                |> GrenTask.perform
                    (\result ->
                        GotConfigLoaded { response = Just response, deferResponse = True, result = result }
                    )


{-| Handle GET /api/config/defaults.

Returns the OS-appropriate default workspace base path using FileSystem.homeDirectory.
-}
handleGetConfigDefaults : Model -> Response -> Cmd Msg
handleGetConfigDefaults model response =
    FileSystem.homeDirectory model.filesystemPermission
        |> GrenTask.perform
            (\homePath ->
                let
                    defaultWorkspacePath =
                        homePath
                            |> Path.toPosixString
                            |> (\home -> home ++ "/Documents/ChorusWorkspaces")

                    body =
                        Encode.object
                            [ { key = "data"
                              , value =
                                    Encode.object
                                        [ { key = "defaultWorkspacePath"
                                          , value = Encode.string defaultWorkspacePath
                                          }
                                        ]
                              }
                            ]
                            |> Encode.encode 0
                in
                GotApiResult
                    { response = response
                    , result =
                        Api.ApiSuccess
                            { statusCode = 200
                            , body = body
                            }
                    }
            )


-- WORKSPACE HISTORY


{-| Handle GET /api/workspaces.
-}
handleListWorkspaces : Model -> Response -> Cmd Msg
handleListWorkspaces model response =
    loadWorkspaceEntries model.filesystemPermission model.workspacesPath
        |> GrenTask.perform
            (\result ->
                when result is
                    Ok entries ->
                        let
                            sortedEntries =
                                entries
                                    |> Array.sortBy .lastOpenedAt
                                    |> Array.reverse

                            body =
                                Encode.object
                                    [ { key = "data", value = Encode.array Types.encodeWorkspaceEntry sortedEntries }
                                    ]
                                    |> Encode.encode 0
                        in
                        GotApiResult
                            { response = response
                            , result =
                                Api.ApiSuccess
                                    { statusCode = 200
                                    , body = body
                                    }
                            }

                    Err errMsg ->
                        GotApiResult
                            { response = response
                            , result =
                                Api.ApiError
                                    { statusCode = 500
                                    , code = "READ_ERROR"
                                    , message = errMsg
                                    }
                            }
            )


{-| Handle DELETE /api/workspaces?path=...
-}
handleRemoveWorkspace : Model -> String -> Response -> Cmd Msg
handleRemoveWorkspace model path response =
    removeWorkspaceEntry model.filesystemPermission model.workspacesPath path
        |> GrenTask.perform
            (\result ->
                when result is
                    Ok _ ->
                        GotApiResult
                            { response = response
                            , result =
                                Api.ApiSuccess
                                    { statusCode = 200
                                    , body = Encode.encode 0 (Encode.object [ { key = "data", value = Encode.object [] } ])
                                    }
                            }

                    Err errMsg ->
                        GotApiResult
                            { response = response
                            , result =
                                Api.ApiError
                                    { statusCode = 500
                                    , code = "WRITE_ERROR"
                                    , message = errMsg
                                    }
                            }
            )


{-| Load workspace entries from the workspaces.json file.

If the file does not exist, returns an empty array.
If the file exists but cannot be parsed, returns an error.
-}
loadWorkspaceEntries : FileSystem.Permission -> String -> GrenTask.Task Never (Result String (Array Types.WorkspaceEntry))
loadWorkspaceEntries filesystemPermission workspacesPath =
    let
        path =
            Path.fromPosixString workspacesPath
    in
    FileSystem.readFile filesystemPermission path
        |> GrenTask.mapError (\e -> FileSystem.errorToString e)
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail "Could not decode workspaces file as UTF-8"

                    Just content ->
                        when Decode.decodeString (Decode.field "workspaces" (Decode.array Types.workspaceEntryDecoder)) content is
                            Ok entries ->
                                GrenTask.succeed entries

                            Err err ->
                                GrenTask.fail ("Invalid workspaces JSON: " ++ Decode.errorToString err)
            )
        |> GrenTask.map Ok
        |> GrenTask.onError
            (\err ->
                -- If the file doesn't exist, treat as empty list
                if String.contains "ENOENT" err then
                    GrenTask.succeed (Ok [])
                else
                    GrenTask.succeed (Err err)
            )


{-| Save workspace entries to the workspaces.json file.
-}
saveWorkspaceEntries : FileSystem.Permission -> String -> Array Types.WorkspaceEntry -> GrenTask.Task Never (Result String {})
saveWorkspaceEntries filesystemPermission workspacesPath entries =
    let
        path =
            Path.fromPosixString workspacesPath

        json =
            Encode.object
                [ { key = "workspaces", value = Encode.array Types.encodeWorkspaceEntry entries }
                ]
                |> Encode.encode 2

        bytes =
            Bytes.fromString json
    in
    FileSystem.writeFile filesystemPermission bytes path
        |> GrenTask.map (\_ -> Ok {})
        |> GrenTask.onError (\err -> GrenTask.succeed (Err (FileSystem.errorToString err)))


{-| Record a workspace entry in workspaces.json.

Reads the existing list, updates or adds the entry with the current timestamp,
and writes back. If the file does not exist, it is created.
-}
recordWorkspaceEntry : FileSystem.Permission -> String -> String -> GrenTask.Task Never (Result String {})
recordWorkspaceEntry filesystemPermission workspacesPath configPath =
    loadWorkspaceEntries filesystemPermission workspacesPath
        |> GrenTask.andThen
            (\loadResult ->
                when loadResult is
                    Err errMsg ->
                        GrenTask.succeed (Err errMsg)

                    Ok entries ->
                        Time.now
                            |> GrenTask.map
                                (\timestamp ->
                                    let
                                        nowMillis =
                                            Time.posixToMillis timestamp

                                        filtered =
                                            entries
                                                |> Array.keepIf (\e -> e.configPath /= configPath)

                                        newEntry =
                                            { configPath = configPath
                                            , lastOpenedAt = nowMillis
                                            }
                                    in
                                    Array.pushLast newEntry filtered
                                )
                            |> GrenTask.andThen
                                (\updatedEntries ->
                                    saveWorkspaceEntries filesystemPermission workspacesPath updatedEntries
                                )
            )


{-| Remove a workspace entry from workspaces.json by config path.
-}
removeWorkspaceEntry : FileSystem.Permission -> String -> String -> GrenTask.Task Never (Result String {})
removeWorkspaceEntry filesystemPermission workspacesPath configPath =
    loadWorkspaceEntries filesystemPermission workspacesPath
        |> GrenTask.andThen
            (\loadResult ->
                when loadResult is
                    Err errMsg ->
                        GrenTask.succeed (Err errMsg)

                    Ok entries ->
                        let
                            filtered =
                                entries
                                    |> Array.keepIf (\e -> e.configPath /= configPath)
                        in
                        saveWorkspaceEntries filesystemPermission workspacesPath filtered
            )



-- HELPERS


{-| Send a config response to the client.
-}
sendConfigResponse : Response -> WorkspaceConfig -> String -> Cmd Msg
sendConfigResponse resp config configPath =
    let
        body =
            Encode.object
                [ { key = "data", value = Types.encodeWorkspaceConfig config }
                , { key = "configPath", value = Encode.string configPath }
                ]
                |> Encode.encode 0
    in
    resp
        |> Response.setStatus 200
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| If all three registries are initialized and there is a pending config
response, send it and clear the pending state.
-}
flushPendingConfigResponse : Model -> { model : Model, command : Cmd Msg }
flushPendingConfigResponse model =
    when { pending = model.pendingConfigResponse, reg = model.registry, agent = model.agentRegistry, provider = model.providerRegistry } is
        { pending = Just { response, config, configPath }, reg = Just _, agent = Just _, provider = Just _ } ->
            { model = { model | pendingConfigResponse = Nothing }
            , command = sendConfigResponse response config configPath
            }

        _ ->
            { model = model
            , command = Cmd.none
            }


{-| If a registry fails to initialize and there is a pending config response,
send a 500 error and clear the pending state.
-}
failPendingConfigResponse : Model -> String -> { model : Model, command : Cmd Msg }
failPendingConfigResponse model errMsg =
    when model.pendingConfigResponse is
        Just { response } ->
            { model = { model | pendingConfigResponse = Nothing }
            , command =
                response
                    |> Response.setStatus 500
                    |> Response.setHeader "Content-Type" "application/json"
                    |> Response.setBody (Encode.encode 0 (Encode.object [ { key = "error", value = Encode.string errMsg } ]))
                    |> Response.send
            }

        Nothing ->
            { model = model
            , command = Cmd.none
            }


{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")


{-| Route a tool call HTTP request to an active executor.

Parses the tool call from the request body, stores the HTTP response handle
in the provider, and forwards the tool call to the Executor. Used by both
`AgentActive` and `ActiveHandoff` branches in `GotToolAgentLookup`.
-}
routeToolCallToExecutor :
    Model
    -> TaskId
    -> String
    -> ActiveExecutor
    -> String
    -> Response
    -> { model : Model, command : Cmd Msg }
routeToolCallToExecutor model taskId taskIdStr executor requestBody response =
    let
        -- Parse the tool call from the request body
        toolName =
            Decode.decodeString (Decode.field "tool" Decode.string) requestBody
                |> Result.withDefault "unknown"

        -- Exactly-once check for completion-report
        alreadySubmitted =
            if toolName == "completion-report" then
                extractCompletionReport executor.executorModel
                    |> isJust
            else
                False
    in
    if alreadySubmitted then
        { model = model
        , command = Api.sendApiResponse response (Api.ApiError { statusCode = 409, code = "CONFLICT", message = "Completion report already submitted for this task" })
        }
    else
        let
            -- Parse the tool input from the request body
            toolInput =
                Decode.decodeString Decode.value requestBody
                    |> Result.withDefault Encode.null

            -- Generate a unique tool call ID from the tool name and task ID.
            -- Uses the count of pending HTTP responses to avoid collisions.
            pendingCount =
                when executor.providerState is
                    Provider.CliProviderState cliState ->
                        Array.length (Dict.keys cliState.pendingHttpResponses)

                    Provider.ApiProviderState _ ->
                        0

            toolCallId =
                taskIdStr ++ "-" ++ toolName ++ "-" ++ String.fromInt pendingCount

            toolCall =
                { id = toolCallId
                , name = toolName
                , input = toolInput
                }

            -- Store the HTTP response handle via the provider
            handleResult =
                executor.provider.handleHttpToolCall
                    executor.providerState
                    { toolCall = toolCall
                    , httpResponse = response
                    }

            updatedExecutor =
                { executor | providerState = handleResult.state }

            -- Preserve the executor variant (AgentActive or ActiveHandoff) by looking up
            -- the current state and updating the ActiveExecutor record inside it.
            updatedExecutorState =
                when Dict.get taskIdStr model.activeExecutors is
                    Just (ActiveHandoff { deferredResponse }) ->
                        ActiveHandoff { executor = updatedExecutor, deferredResponse = deferredResponse }

                    _ ->
                        AgentActive updatedExecutor

            updatedModel =
                { model | activeExecutors = Dict.set taskIdStr updatedExecutorState model.activeExecutors }

            -- Forward the tool call to the Executor
            executorCmd =
                GrenTask.succeed {}
                    |> GrenTask.perform
                        (\_ ->
                            GotExecutorMsg
                                { taskId = taskId
                                , msg =
                                    Executor.ToolCallReceived
                                        { id = toolCallId
                                        , name = toolName
                                        , input = toolInput
                                        }
                                }
                        )
        in
        { model = updatedModel
        , command =
            Cmd.batch
                [ handleResult.cmd
                , executorCmd
                ]
        }


{-| Extract the ActiveExecutor record from any executor state variant.

Returns Nothing for Spawning since there is no active executor.
-}
activeExecutorFromState : ExecutorState -> Maybe ActiveExecutor
activeExecutorFromState state =
    when state is
        Spawning _ ->
            Nothing

        AgentActive executor ->
            Just executor

        ActiveHandoff { executor } ->
            Just executor


{-| Update the ActiveExecutor inside an ExecutorState, preserving the variant.
-}
updateActiveExecutor : (ActiveExecutor -> ActiveExecutor) -> ExecutorState -> ExecutorState
updateActiveExecutor fn state =
    when state is
        Spawning s ->
            Spawning s

        AgentActive executor ->
            AgentActive (fn executor)

        ActiveHandoff record ->
            ActiveHandoff { record | executor = fn record.executor }


{-| Check whether a Maybe value is Just (contains a value).
-}
isJust : Maybe a -> Bool
isJust maybe =
    when maybe is
        Just _ ->
            True

        Nothing ->
            False
