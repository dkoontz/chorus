module Main exposing (main)

{-| Chorus - Secure multi-agent orchestration system.

This is the main entry point for the Chorus application. It runs an HTTP
server that provides a web interface for managing tasks.

The server exposes:
- REST API at /api/* for task operations
- Static files at /* for the web UI

-}

import Agent.Registry as AgentRegistry
import Bytes
import ChildProcess
import Config exposing (Config)
import Crypto exposing (SecureContext)
import Debug
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import HttpServer
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Init
import Json.Decode as Decode
import Json.Encode as Encode
import Logging exposing (LogLevel(..))
import Node
import Provider exposing (ProviderKind(..))
import Provider.ClaudeCode as ClaudeCode
import Provider.OpenAiCompatible as OpenAiCompatible
import Provider.OpenCode as OpenCode
import Provider.Registry as ProviderRegistry
import Stream
import Task as GrenTask
import Task.Registry as Registry
import Types exposing (AgentConfig(..), AgentProvider(..), ProviderType(..), TaskStatus(..), SourceInfo, WorkspaceConfig)
import Web.Api as Api exposing (indexedArrayToDict)
import Web.Router as Router
import Web.Server as Server
import Web.Static as Static
import Web.ToolExecution as ToolExecution


-- MAIN


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { env : Node.Environment
    , server : Maybe HttpServer.Server
    , registry : Maybe Registry.Registry
    , agentRegistry : Maybe AgentRegistry.AgentRegistry
    , providerRegistry : Maybe ProviderRegistry.ProviderRegistry
    , activeExecutors : Dict String ExecutorState
    , filesystemPermission : FileSystem.Permission
    , childProcessPermission : ChildProcess.Permission
    , httpClientPermission : HttpClient.Permission
    , secureContext : SecureContext
    , config : Config
    , workspaceConfig : Maybe WorkspaceConfig
    , workspaceConfigPath : Maybe String
    , status : Status
    , pendingConfigResponse : Maybe PendingConfigResponse
    , logger : Logging.Logger
    , cliPort : Maybe Int
    }


{-| State of an active agent executor, keyed by task ID.
-}
type alias ExecutorState =
    { taskId : TaskId
    , agentName : String
    , agentConfig : Types.AgentConfig
    , status : ExecutorStatus
    , completionReportReceived : Bool
    }


{-| Status of an agent executor.
-}
type ExecutorStatus
    = ExecStarting
    | ExecRunning
    | ExecCompleted String
    | ExecFailed String


type alias PendingConfigResponse =
    { response : Response
    , config : WorkspaceConfig
    , configPath : String
    }


type Status
    = Initializing
    | Running
    | Error String


-- MSG


type Msg
    = GotServer (Result Server.Error HttpServer.Server)
    | GotRegistry (Result Registry.Error Registry.Registry)
    | GotAgentRegistry (Result AgentRegistry.Error AgentRegistry.AgentRegistry)
    | GotProviderRegistry (Result ProviderRegistry.Error ProviderRegistry.ProviderRegistry)
    | GotRequest { request : HttpServer.Request, response : Response }
    | GotStaticFile { id : Int, response : Response, result : Static.StaticFileResult }
    | GotApiResult { response : Response, result : Api.ApiResult }
    | GotBinaryResult { response : Response, result : Api.BinaryResult }
    | GotToolAgentLookup { taskId : TaskId, requestBody : String, response : Response, result : Result String { agentConfig : Types.AgentConfig } }
    | GotAgentLookup { taskId : TaskId, prompt : String, response : Response, result : Result AgentRegistry.Error Types.AgentConfig }
    | GotHandoffRecorded { taskId : TaskId, prompt : String, response : Response, agentConfig : Types.AgentConfig, apiResult : Api.ApiResult }
    | GotAgentComplete { taskId : TaskId, result : Result String String }
    | GotToolResult { taskId : TaskId, toolName : String, response : Response, result : Api.ApiResult }
    | GotInternalApiResult Api.ApiResult
    | GotTaskCreated { response : Response, taskId : TaskId, description : String, result : Api.ApiResult }
    | GotPlanTaskResult { response : Response, taskId : TaskId, description : String, result : Api.ApiResult }
    | GotPlannerComplete { taskId : TaskId, result : Result String String }
    | GotAnswersSubmitted { response : Response, taskId : TaskId, enrichedPrompt : String, result : Api.ApiResult }
    | GotToolGrant { taskId : TaskId, addTools : Array String, removeTools : Array String, response : Response }
    | GotConfigLoaded { response : Maybe Response, deferResponse : Bool, result : Result String { config : WorkspaceConfig, configPath : String } }
    | NoOp



-- INIT


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \filesystemPermission ->
        Init.await ChildProcess.initialize <| \childProcessPermission ->
            Init.await HttpClient.initialize <| \httpClientPermission ->
                Init.awaitTask getSecureContext <| \secureContext ->
                    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
                        Init.await HttpServer.initialize <| \httpPermission ->
                            let
                                baseDir =
                                    env.applicationPath
                                        |> Path.parentPath
                                        |> Maybe.map Path.toPosixString
                                        |> Maybe.withDefault "."

                                -- Parse --port from CLI args
                                portResult =
                                    Config.parsePortFromArgs env.args

                                cliPort =
                                    when portResult is
                                        Ok maybePort ->
                                            maybePort

                                        Err _ ->
                                            Nothing

                                -- Build config: default -> env vars -> CLI args
                                baseConfig =
                                    Config.defaultConfig
                                        |> Config.configFromEnv baseDir envVars
                                        |> Config.applyCliPort cliPort
                            in
                            -- If CHORUS_CONFIG is set, load it before creating the server
                            -- so the workspace port is applied before the server binds.
                            let
                                loadConfigTask =
                                    when baseConfig.chorusConfigPath is
                                        Just configPath ->
                                            loadWorkspaceConfig filesystemPermission configPath

                                        Nothing ->
                                            GrenTask.succeed (Err "no-config")
                            in
                            Init.awaitTask loadConfigTask <| \preloadedConfigResult ->
                                let
                                    -- Apply workspace config port (if loaded) before server creation
                                    workspacePort =
                                        when preloadedConfigResult is
                                            Ok loaded ->
                                                loaded.config.serverPort

                                            Err _ ->
                                                Nothing

                                    config =
                                        baseConfig
                                            |> Config.applyWorkspacePort cliPort workspacePort

                                    logger =
                                        Logging.makeLogger env.stdout config.logLevel

                                    model =
                                        { env = env
                                        , server = Nothing
                                        , registry = Nothing
                                        , agentRegistry = Nothing
                                        , providerRegistry = Nothing
                                        , activeExecutors = Dict.empty
                                        , filesystemPermission = filesystemPermission
                                        , childProcessPermission = childProcessPermission
                                        , httpClientPermission = httpClientPermission
                                        , secureContext = secureContext
                                        , config = config
                                        , workspaceConfig = Nothing
                                        , workspaceConfigPath = Nothing
                                        , status = Initializing
                                        , pendingConfigResponse = Nothing
                                        , logger = logger
                                        , cliPort = cliPort
                                        }

                                    -- Deliver pre-loaded config to GotConfigLoaded for registry init
                                    configCmd =
                                        when preloadedConfigResult is
                                            Ok _ ->
                                                GrenTask.succeed preloadedConfigResult
                                                    |> GrenTask.perform
                                                        (\result ->
                                                            GotConfigLoaded { response = Nothing, deferResponse = False, result = result }
                                                        )

                                            Err _ ->
                                                Cmd.none

                                    -- Handle invalid port: log error and exit
                                    portErrorCmd =
                                        when portResult is
                                            Err errMsg ->
                                                Cmd.batch
                                                    [ Logging.logError logger ("Invalid --port argument: " ++ errMsg) NoOp
                                                    , Stream.writeLineAsBytes ("Error: " ++ errMsg ++ "\n") env.stderr
                                                        |> GrenTask.onError (\_ -> GrenTask.succeed env.stderr)
                                                        |> GrenTask.andThen (\_ -> Node.setExitCode 1)
                                                        |> GrenTask.perform (\_ -> NoOp)
                                                    ]

                                            Ok _ ->
                                                Cmd.none
                                in
                                Node.startProgram
                                    { model = model
                                    , command =
                                        when portResult is
                                            Err _ ->
                                                portErrorCmd

                                            Ok _ ->
                                                Cmd.batch
                                                    [ -- Initialize the HTTP server
                                                      Server.createServer httpPermission
                                                        { host = config.host
                                                        , port_ = config.serverPort
                                                        }
                                                        |> GrenTask.attempt GotServer

                                                    , -- Deliver pre-loaded config for registry initialization
                                                      configCmd

                                                    , -- Log startup
                                                      Logging.logInfo logger ("Starting Chorus server on " ++ config.host ++ ":" ++ String.fromInt config.serverPort) NoOp
                                                    ]
                                    }



-- PROVIDER FACTORY


{-| Create a provider for the given agent configuration.

Dispatches based on the agent's `provider` field. Supports:
- "claude-code": CLI-based provider that spawns the claude CLI
- "opencode": CLI-based provider that spawns the opencode CLI
- "openai-compat": OpenAI-compatible API provider (OpenRouter, Ollama, etc.)

Returns Nothing if the provider name is not recognized or the agent is internal.
-}
makeProvider : Model -> Types.AgentConfig -> Maybe Types.ProviderConfig -> Maybe (Provider.Provider Msg)
makeProvider model agentConfig maybeProviderConfig =
    when agentConfig is
        InternalAgent _ ->
            Nothing

        UserDefinedAgent r ->
            when r.provider is
                NotConfigured ->
                    Nothing

                ProviderRef _ ->
                    when maybeProviderConfig is
                        Nothing ->
                            Nothing

                        Just providerConfig ->
                            let
                                baseUrl =
                                    "http://" ++ model.config.host ++ ":" ++ String.fromInt model.config.serverPort
                            in
                            when providerConfig.providerType is
                                Types.ClaudeCode ->
                                    Just
                                        (ClaudeCode.provider
                                            { childProcessPermission = model.childProcessPermission
                                            , chorusToolsPath = model.config.chorusToolsPath
                                            , baseUrl = baseUrl
                                            }
                                        )

                                Types.OpenCode ->
                                    Just
                                        (OpenCode.provider
                                            { childProcessPermission = model.childProcessPermission
                                            , filesystemPermission = model.filesystemPermission
                                            , chorusToolsPath = model.config.chorusToolsPath
                                            , baseUrl = baseUrl
                                            }
                                        )

                                Types.OpenAiCompatible config ->
                                    let
                                        conversationsDir =
                                            when model.workspaceConfigPath is
                                                Just configPath ->
                                                    parentDirectory configPath ++ "/conversations"

                                                Nothing ->
                                                    Debug.todo "conversationsDir called without a loaded workspace config"
                                    in
                                    Just
                                        (OpenAiCompatible.provider
                                            { httpClientPermission = model.httpClientPermission
                                            , filesystemPermission = model.filesystemPermission
                                            , secureContext = model.secureContext
                                            , apiBaseUrl = config.apiBaseUrl
                                            , apiKey = config.apiKey
                                            , model = Maybe.withDefault config.defaultModel r.model
                                            , conversationsDir = conversationsDir
                                            }
                                        )



{-| Build a shell command for the given provider type.

Dispatches to the correct CLI command builder based on the provider type.
Returns Err for API providers since they require a different execution path.
-}
buildShellCommandForProvider :
    Model
    -> Types.ProviderConfig
    -> Types.AgentConfig
    -> { systemPrompt : Maybe String, initialDirectory : String, message : String, taskId : Maybe String }
    -> Result String String
buildShellCommandForProvider model providerConfig agentConfig args =
    let
        baseUrl =
            "http://" ++ model.config.host ++ ":" ++ String.fromInt model.config.serverPort

        allowedTools =
            when agentConfig is
                UserDefinedAgent r ->
                    when r.allowedTools is
                        [] ->
                            Nothing

                        tools ->
                            Just (String.join " " tools)

                InternalAgent _ ->
                    Nothing
    in
    when providerConfig.providerType is
        Types.ClaudeCode ->
            Ok
                (ClaudeCode.buildShellCommand
                    { systemPrompt = args.systemPrompt
                    , resumeSessionId = Nothing
                    , workspaceRoot = args.initialDirectory
                    , chorusToolsPath = model.config.chorusToolsPath
                    , message = args.message
                    , allowedTools = allowedTools
                    , taskId = args.taskId
                    , baseUrl = Just baseUrl
                    }
                )

        Types.OpenCode ->
            Ok
                (OpenCode.buildShellCommand
                    { sessionId = Nothing
                    , workspaceRoot = args.initialDirectory
                    , message = args.message
                    , chorusToolsPath = model.config.chorusToolsPath
                    , taskId = args.taskId
                    , baseUrl = Just baseUrl
                    }
                )

        Types.OpenAiCompatible _ ->
            Err ("Provider '" ++ providerConfig.name ++ "' is an OpenAI-compatible API provider. API-based agent execution through handoff is not yet implemented. Use a CLI provider (Claude Code or OpenCode) instead.")



{-| Resolve a provider config for a given agent, returning an async Task.

Looks up the agent's provider reference in the provider registry.
Returns an error if the agent has no provider configured or the provider is not found.
-}
resolveProviderConfig : Model -> Types.AgentConfig -> GrenTask.Task String Types.ProviderConfig
resolveProviderConfig model agentConfig =
    when agentConfig is
        InternalAgent r ->
            GrenTask.fail ("Cannot resolve provider for internal agent: " ++ r.name)

        UserDefinedAgent r ->
            when r.provider is
                NotConfigured ->
                    GrenTask.fail ("Agent '" ++ r.name ++ "' has no provider configured")

                ProviderRef providerName ->
                    when model.providerRegistry is
                        Nothing ->
                            GrenTask.fail "Provider registry not available"

                        Just providerReg ->
                            ProviderRegistry.getProvider providerReg providerName
                                |> GrenTask.mapError
                                    (\err ->
                                        "Agent '" ++ r.name ++ "' references provider '" ++ providerName ++ "' which does not exist"
                                    )


-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = Logging.logInfo model.logger "HTTP server started" NoOp
                    }

                Err err ->
                    let
                        serverConfig =
                            { host = model.config.host
                            , port_ = model.config.serverPort
                            }

                        errMsg =
                            Server.errorToString serverConfig err
                    in
                    { model = { model | status = Error errMsg }
                    , command = Logging.logError model.logger ("Server error: " ++ errMsg) NoOp
                    }

        GotRegistry result ->
            when result is
                Ok registry ->
                    let
                        newModel =
                            { model
                                | registry = Just registry
                                , status = Running
                            }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Task registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            Registry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Registry error: " ++ errMsg)
                    in
                    { model = { errorFlush.model | status = Error errMsg }
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotAgentRegistry result ->
            when result is
                Ok agentReg ->
                    let
                        newModel =
                            { model | agentRegistry = Just agentReg }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Agent registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            AgentRegistry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Agent registry error: " ++ errMsg)
                    in
                    { model = errorFlush.model
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Agent registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotProviderRegistry result ->
            when result is
                Ok providerReg ->
                    let
                        newModel =
                            { model | providerRegistry = Just providerReg }

                        flush =
                            flushPendingConfigResponse newModel
                    in
                    { model = flush.model
                    , command =
                        Cmd.batch
                            [ Logging.logInfo model.logger "Provider registry initialized" NoOp
                            , flush.command
                            ]
                    }

                Err err ->
                    let
                        errMsg =
                            ProviderRegistry.errorToString err

                        errorFlush =
                            failPendingConfigResponse model ("Provider registry error: " ++ errMsg)
                    in
                    { model = errorFlush.model
                    , command =
                        Cmd.batch
                            [ Logging.logError model.logger ("Provider registry error: " ++ errMsg) NoOp
                            , errorFlush.command
                            ]
                    }

        GotToolAgentLookup { taskId, requestBody, response, result } ->
            when result is
                Err errMsg ->
                    { model = model
                    , command = sendBadRequest response errMsg
                    }

                Ok { agentConfig } ->
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = Cmd.none
                            }

                        Just reg ->
                            let
                                allowedTools =
                                    when agentConfig is
                                        UserDefinedAgent r ->
                                            r.allowedTools

                                        InternalAgent _ ->
                                            []

                                allowedDirs =
                                    when model.workspaceConfig is
                                        Just wc ->
                                            wc.allowedAgentDirectories

                                        Nothing ->
                                            []

                                registryRoot =
                                    when model.workspaceConfigPath is
                                        Just configPath ->
                                            parentDirectory configPath ++ "/registry"

                                        Nothing ->
                                            Debug.todo "registryRoot called without a loaded workspace config"

                                toolCtx =
                                    { filesystemPermission = model.filesystemPermission
                                    , childProcessPermission = model.childProcessPermission
                                    , allowedDirectories = allowedDirs
                                    , allowedTools = allowedTools
                                    , apiContext =
                                        { registry = reg
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = Path.fromPosixString registryRoot
                                        }
                                    , taskId = taskId
                                    }

                                toolName =
                                    Decode.decodeString (Decode.field "tool" Decode.string) requestBody
                                        |> Result.withDefault "unknown"

                                toMsg =
                                    \apiResult -> GotToolResult { taskId = taskId, toolName = toolName, response = response, result = apiResult }
                            in
                            { model = model
                            , command = ToolExecution.requestExecuteTool toolCtx requestBody toMsg
                            }

        GotAgentLookup { taskId, prompt, response, result } ->
            when result is
                Err err ->
                    { model = model
                    , command = sendBadRequest response ("Agent registry error: " ++ AgentRegistry.errorToString err)
                    }

                Ok agentConfig ->
                    if Types.isInternalAgent agentConfig then
                        { model = model
                        , command = sendBadRequest response ("Cannot hand off to internal agent: " ++ Types.agentConfigName agentConfig)
                        }
                    else
                    -- Agent found and provider validated (validation done in StartHandoff handler).
                    -- Update the task first, then spawn the agent.
                    -- The HTTP response is sent via GotApiResult from requestStartHandoff.
                    -- The agent spawn happens via GotHandoffRecorded when the task update succeeds.
                    when model.registry is
                        Nothing ->
                            { model = model
                            , command = sendBadRequest response "Registry not available"
                            }

                        Just registry ->
                            let
                                ctx =
                                    { registry = registry
                                    , filesystemPermission = model.filesystemPermission
                                    , secureContext = model.secureContext
                                    , registryRoot = registryRootPath model
                                    }

                                toMsg =
                                    \apiResult ->
                                        GotHandoffRecorded
                                            { taskId = taskId
                                            , prompt = prompt
                                            , response = response
                                            , agentConfig = agentConfig
                                            , apiResult = apiResult
                                            }
                            in
                            { model = model
                            , command =
                                Api.requestStartHandoff ctx taskId { agentName = Types.agentConfigName agentConfig, prompt = prompt } toMsg
                            }

        GotHandoffRecorded { taskId, prompt, response, agentConfig, apiResult } ->
            -- The task update completed. Send the HTTP response first, then spawn the agent.
            let
                sendResponseCmd =
                    Api.sendApiResponse response apiResult
            in
            when apiResult is
                Api.ApiError _ ->
                    -- Task update failed (e.g., 409 conflict), just send the error response
                    { model = model
                    , command = sendResponseCmd
                    }

                Api.ApiSuccess _ ->
                    -- Task updated successfully. Resolve the provider and spawn the agent.
                    let
                        agentName =
                            Types.agentConfigName agentConfig

                        agentInstructions =
                            when agentConfig is
                                InternalAgent r ->
                                    r.instructions

                                UserDefinedAgent r ->
                                    r.instructions

                        completionReportInstruction =
                            "\n\nIMPORTANT: Before finishing your work, you MUST call the completion-report tool to submit your results. Use: {\"tool\": \"completion-report\", \"status\": \"complete\", \"summary\": \"Brief summary of what was done\", \"output\": \"Detailed output\"}\nFor blocked work, use status \"blocked\" with a \"blockedReason\". For failures, use status \"failed\"."

                        systemPrompt =
                            if String.isEmpty agentInstructions then
                                Just completionReportInstruction
                            else
                                Just (agentInstructions ++ completionReportInstruction)

                        initialDirectory =
                            initialAgentDir model

                        executorState =
                            { taskId = taskId
                            , agentName = agentName
                            , agentConfig = agentConfig
                            , status = ExecRunning
                            , completionReportReceived = False
                            }

                        options =
                            { shell = ChildProcess.NoShell
                            , workingDirectory = ChildProcess.InheritWorkingDirectory
                            , environmentVariables = ChildProcess.InheritEnvironmentVariables
                            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
                            , runDuration = ChildProcess.Milliseconds 600000
                            }

                        spawnCmd =
                            resolveProviderConfig model agentConfig
                                |> GrenTask.andThen
                                    (\providerConfig ->
                                        let
                                            shellCommand =
                                                buildShellCommandForProvider model providerConfig agentConfig
                                                    { systemPrompt = systemPrompt
                                                    , initialDirectory = initialDirectory
                                                    , message = prompt
                                                    , taskId = Just (Id.taskIdToString taskId)
                                                    }
                                        in
                                        when shellCommand is
                                            Err errMsg ->
                                                GrenTask.fail errMsg

                                            Ok cmd ->
                                                ChildProcess.run model.childProcessPermission "bash" [ "-c", cmd ] options
                                                    |> GrenTask.map
                                                        (\cliResult ->
                                                            let
                                                                output =
                                                                    cliResult.stdout
                                                                        |> Bytes.toString
                                                                        |> Maybe.withDefault ""

                                                                -- Extract the result text from CLI JSON output
                                                                resultText =
                                                                    when Decode.decodeString (Decode.field "result" Decode.string) output is
                                                                        Ok text ->
                                                                            text

                                                                        Err _ ->
                                                                            output
                                                            in
                                                            Ok resultText
                                                        )
                                                    |> GrenTask.onError
                                                        (\runError ->
                                                            let
                                                                errMsg =
                                                                    when runError is
                                                                        ChildProcess.InitError { errorCode } ->
                                                                            "Failed to start agent CLI: " ++ errorCode

                                                                        ChildProcess.ProgramError { exitCode, stderr } ->
                                                                            let
                                                                                stderrStr =
                                                                                    stderr
                                                                                        |> Bytes.toString
                                                                                        |> Maybe.withDefault ""
                                                                            in
                                                                            "Agent CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                                                            in
                                                            GrenTask.succeed (Err errMsg)
                                                        )
                                    )
                                |> GrenTask.onError
                                    (\errMsg ->
                                        GrenTask.succeed (Err errMsg)
                                    )
                                |> GrenTask.perform (\r -> GotAgentComplete { taskId = taskId, result = r })
                    in
                    { model = { model | activeExecutors = Dict.set (Id.taskIdToString taskId) executorState model.activeExecutors }
                    , command =
                        Cmd.batch
                            [ sendResponseCmd
                            , spawnCmd
                            , Logging.logInfo model.logger ("Spawned agent " ++ agentName ++ " for task " ++ Id.taskIdToString taskId) NoOp
                            ]
                    }

        GotAgentComplete { taskId, result } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId

                -- Check if completion report was already received
                hadCompletionReport =
                    Dict.get taskIdStr model.activeExecutors
                        |> Maybe.map .completionReportReceived
                        |> Maybe.withDefault False

                -- Remove executor from active
                updatedExecutors =
                    Dict.remove taskIdStr model.activeExecutors

                updatedModel =
                    { model | activeExecutors = updatedExecutors }
            in
            if hadCompletionReport then
                -- Completion report already handled status/output; just complete the handoff record timestamps
                when model.registry is
                    Nothing ->
                        { model = updatedModel
                        , command = Cmd.none
                        }

                    Just registry ->
                        let
                            ctx =
                                { registry = registry
                                , filesystemPermission = model.filesystemPermission
                                , secureContext = model.secureContext
                                , registryRoot = registryRootPath model
                                }

                            rawOutput =
                                when result is
                                    Ok text ->
                                        text

                                    Err errMsg ->
                                        "Agent exited with error: " ++ errMsg
                        in
                        { model = updatedModel
                        , command =
                            Cmd.batch
                                [ Api.requestCompleteHandoff ctx taskId { output = rawOutput }
                                    (\apiResult -> GotInternalApiResult apiResult)
                                , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " (completion report received)") NoOp
                                ]
                        }
            else
                -- No completion report - fall back to raw output
                when result is
                    Ok outputText ->
                        when model.registry is
                            Nothing ->
                                { model = updatedModel
                                , command = Logging.logError model.logger "Agent completed but registry not available" NoOp
                                }

                            Just registry ->
                                let
                                    ctx =
                                        { registry = registry
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = registryRootPath model
                                        }
                                in
                                { model = updatedModel
                                , command =
                                    Cmd.batch
                                        [ Api.requestCompleteHandoff ctx taskId { output = outputText }
                                            (\apiResult -> GotInternalApiResult apiResult)
                                        , Logging.logInfo model.logger ("Agent completed for task " ++ taskIdStr ++ " without completion report (output length: " ++ String.fromInt (String.unitLength outputText) ++ ")") NoOp
                                        ]
                                }

                    Err errMsg ->
                        when model.registry is
                            Nothing ->
                                { model = updatedModel
                                , command = Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                }

                            Just registry ->
                                let
                                    ctx =
                                        { registry = registry
                                        , filesystemPermission = model.filesystemPermission
                                        , secureContext = model.secureContext
                                        , registryRoot = registryRootPath model
                                        }
                                in
                                { model = updatedModel
                                , command =
                                    Cmd.batch
                                        [ Api.requestCompleteHandoff ctx taskId { output = "Agent failed: " ++ errMsg }
                                            (\apiResult -> GotInternalApiResult apiResult)
                                        , Logging.logError model.logger ("Agent failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                        ]
                                }

        GotRequest { request, response } ->
            let
                method =
                    request.method

                -- Build path with query string for routing
                path =
                    when request.url.query is
                        Just q ->
                            request.url.path ++ "?" ++ q

                        Nothing ->
                            request.url.path

                route =
                    Router.parseRoute method path

                -- Debug: log request body for API routes
                debugCmd =
                    when route is
                        Router.StaticFile _ ->
                            Cmd.none

                        Router.NotFound ->
                            Cmd.none

                        _ ->
                            let
                                bodyStr =
                                    Bytes.toString request.body
                                        |> Maybe.withDefault "<binary data>"
                            in
                            Logging.logDebug model.logger ("Request body: " ++ bodyStr) NoOp
            in
            { model = model
            , command =
                Cmd.batch
                    [ Logging.logInfo model.logger
                        (HttpServer.methodToString method ++ " " ++ path ++ " -> " ++ Router.routeToString route)
                        NoOp
                    , debugCmd
                    , handleRoute model route request response
                    ]
            }

        GotStaticFile { response, result } ->
            { model = model
            , command = Static.sendFileResponse response result
            }

        GotApiResult { response, result } ->
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotToolResult { taskId, toolName, response, result } ->
            let
                status =
                    when result is
                        Api.ApiSuccess _ ->
                            "success"

                        Api.ApiError _ ->
                            "error"

                logCmd =
                    when model.registry is
                        Nothing ->
                            Cmd.none

                        Just reg ->
                            Registry.recordEvent reg taskId
                                { eventType = "tool_executed"
                                , data =
                                    Dict.empty
                                        |> Dict.set "tool" toolName
                                        |> Dict.set "status" status
                                }
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                |> GrenTask.perform (\_ -> NoOp)

                -- Track successful completion-report submissions
                updatedModel =
                    if toolName == "completion-report" && status == "success" then
                        let
                            taskIdStr =
                                Id.taskIdToString taskId

                            updatedExecutors =
                                when Dict.get taskIdStr model.activeExecutors is
                                    Just executor ->
                                        Dict.set taskIdStr { executor | completionReportReceived = True } model.activeExecutors

                                    Nothing ->
                                        model.activeExecutors
                        in
                        { model | activeExecutors = updatedExecutors }
                    else
                        model
            in
            { model = updatedModel
            , command =
                Cmd.batch
                    [ Api.sendApiResponse response result
                    , logCmd
                    ]
            }

        GotBinaryResult { response, result } ->
            { model = model
            , command = Api.sendBinaryResponse response result
            }

        GotInternalApiResult _ ->
            -- Internal API result from agent completion; no HTTP response to send
            { model = model
            , command = Cmd.none
            }

        GotTaskCreated { response, taskId, description, result } ->
            -- Task created. Remains in Pending status; user must trigger planning.
            { model = model
            , command = Api.sendApiResponse response result
            }

        GotPlanTaskResult { response, taskId, description, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess _ ->
                    -- Plan endpoint succeeded. Dispatch the task-validator agent.
                    when model.agentRegistry is
                        Just agentReg ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , dispatchPlanner model agentReg taskId description
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

        GotPlannerComplete { taskId, result } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId
            in
            when model.registry is
                Nothing ->
                    { model = model, command = Cmd.none }

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , filesystemPermission = model.filesystemPermission
                            , secureContext = model.secureContext
                            , registryRoot = registryRootPath model
                            }
                    in
                    when result is
                        Ok output ->
                            when parsePlannerOutput output is
                                PlanResult fields ->
                                    let
                                        mergeInto =
                                            \source target -> Dict.foldl Dict.set target source

                                        baseDict =
                                            Dict.empty
                                                |> Dict.set "summary" fields.summary
                                                |> mergeInto (indexedArrayToDict "requirement_" fields.requirements)
                                                |> mergeInto (indexedArrayToDict "acceptance_criteria_" fields.acceptanceCriteria)
                                                |> mergeInto (indexedArrayToDict "plan_step_" fields.plan)

                                        planningCompletedData =
                                            when fields.assignedAgent is
                                                Just agent ->
                                                    baseDict
                                                        |> Dict.set "assigned_agent" agent

                                                Nothing ->
                                                    baseDict
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestApplyPlan ctx taskId fields planningCompletedData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logInfo model.logger ("Planner produced plan for task " ++ taskIdStr) NoOp
                                            ]
                                    }

                                QuestionsResult questions ->
                                    let
                                        questionsEventData =
                                            indexedArrayToDict "question_" questions
                                                |> Dict.set "questionCount" (String.fromInt (Array.length questions))
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestSetQuestions ctx taskId questions questionsEventData (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logInfo model.logger ("Planner asked " ++ String.fromInt (Array.length questions) ++ " questions for task " ++ taskIdStr) NoOp
                                            ]
                                    }

                                PlannerParseError errMsg ->
                                    let
                                        planningFailedEvent =
                                            Just
                                                { eventType = "planning_failed"
                                                , data =
                                                    Dict.empty
                                                        |> Dict.set "error" ("Planner output parse error: " ++ errMsg)
                                                }
                                    in
                                    { model = model
                                    , command =
                                        Cmd.batch
                                            [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner output parse error: " ++ errMsg)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                            , Logging.logError model.logger ("Planner parse error for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                            ]
                                    }

                        Err errMsg ->
                            let
                                planningFailedEvent =
                                    Just
                                        { eventType = "planning_failed"
                                        , data =
                                            Dict.empty
                                                |> Dict.set "error" ("Planner failed: " ++ errMsg)
                                        }
                            in
                            { model = model
                            , command =
                                Cmd.batch
                                    [ Api.requestUpdateStatus ctx taskId (Types.Failed ("Planner failed: " ++ errMsg)) planningFailedEvent (\_ -> GotInternalApiResult (Api.ApiSuccess { statusCode = 200, body = "" }))
                                    , Logging.logError model.logger ("Planner failed for task " ++ taskIdStr ++ ": " ++ errMsg) NoOp
                                    ]
                            }

        GotAnswersSubmitted { response, taskId, enrichedPrompt, result } ->
            let
                sendResponseCmd =
                    Api.sendApiResponse response result
            in
            when result is
                Api.ApiSuccess _ ->
                    when model.agentRegistry is
                        Just agentReg ->
                            { model = model
                            , command =
                                Cmd.batch
                                    [ sendResponseCmd
                                    , dispatchPlanner model agentReg taskId enrichedPrompt
                                    ]
                            }

                        Nothing ->
                            { model = model, command = sendResponseCmd }

                Api.ApiError _ ->
                    { model = model, command = sendResponseCmd }

        GotToolGrant { taskId, addTools, removeTools, response } ->
            let
                taskIdStr =
                    Id.taskIdToString taskId
            in
            when Dict.get taskIdStr model.activeExecutors is
                Nothing ->
                    { model = model
                    , command = sendBadRequest response ("No active executor for task: " ++ taskIdStr)
                    }

                Just executor ->
                    let
                        agentConfig =
                            executor.agentConfig

                        currentTools =
                            when agentConfig is
                                UserDefinedAgent r ->
                                    r.allowedTools

                                InternalAgent _ ->
                                    []

                        withAdded =
                            Array.foldl
                                (\tool tools ->
                                    if Array.any (\t -> t == tool) tools then
                                        tools
                                    else
                                        Array.pushLast tool tools
                                )
                                currentTools
                                addTools

                        withRemoved =
                            Array.keepIf
                                (\tool ->
                                    not (Array.any (\r -> r == tool) removeTools)
                                )
                                withAdded

                        updatedConfig =
                            when agentConfig is
                                UserDefinedAgent r ->
                                    UserDefinedAgent { r | allowedTools = withRemoved }

                                InternalAgent _ ->
                                    agentConfig

                        updatedExecutor =
                            { executor | agentConfig = updatedConfig }

                        updatedExecutors =
                            Dict.set taskIdStr updatedExecutor model.activeExecutors

                        responseBody =
                            Encode.object
                                [ { key = "allowedTools", value = Encode.array Encode.string withRemoved }
                                ]
                                |> Encode.encode 0
                    in
                    { model = { model | activeExecutors = updatedExecutors }
                    , command =
                        Cmd.batch
                            [ response
                                |> Response.setStatus 200
                                |> Response.setHeader "Content-Type" "application/json"
                                |> Response.setBody responseBody
                                |> Response.send
                            , Logging.logInfo model.logger ("Updated tools for task " ++ taskIdStr ++ ": " ++ String.join ", " withRemoved) NoOp
                            ]
                    }

        GotConfigLoaded { response, deferResponse, result } ->
            when result is
                Err errMsg ->
                    let
                        responseCmd =
                            when response is
                                Just resp ->
                                    sendBadRequest resp errMsg

                                Nothing ->
                                    Cmd.none
                    in
                    { model = model
                    , command =
                        Cmd.batch
                            [ responseCmd
                            , Logging.logError model.logger ("Config load failed: " ++ errMsg) NoOp
                            ]
                    }

                Ok { config, configPath } ->
                    let
                        -- Derive paths from workspace root (parent of chorus.json)
                        configRoot =
                            parentDirectory configPath

                        registryRoot =
                            configRoot ++ "/registry"

                        providersRoot =
                            configRoot ++ "/providers"

                        uploadDirPath =
                            configRoot ++ "/uploads"

                        -- Initialize all registries
                        initRegistryCmd =
                            Registry.init model.filesystemPermission model.secureContext
                                { registryRoot = registryRoot }
                                |> GrenTask.attempt GotRegistry

                        agentsRoot =
                            configRoot ++ "/agents"

                        initAgentRegistryCmd =
                            AgentRegistry.init model.filesystemPermission
                                { agentsRoot = agentsRoot }
                                |> GrenTask.attempt GotAgentRegistry

                        initProviderRegistryCmd =
                            ProviderRegistry.init model.filesystemPermission
                                { providersRoot = providersRoot }
                                |> GrenTask.attempt GotProviderRegistry

                        -- Ensure upload directory exists
                        ensureUploadDirCmd =
                            FileSystem.makeDirectory model.filesystemPermission { recursive = True } (Path.fromPosixString uploadDirPath)
                                |> GrenTask.map (\_ -> {})
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                |> GrenTask.perform (\_ -> NoOp)

                        -- Either defer the response (select/create) or send immediately (update/startup)
                        shouldDefer =
                            deferResponse && response /= Nothing

                        responseCmd =
                            if shouldDefer then
                                Cmd.none
                            else
                                when response is
                                    Just resp ->
                                        sendConfigResponse resp config configPath

                                    Nothing ->
                                        Cmd.none

                        pendingConfig =
                            if shouldDefer then
                                when response is
                                    Just resp ->
                                        Just { response = resp, config = config, configPath = configPath }

                                    Nothing ->
                                        Nothing
                            else
                                Nothing
                    in
                    let
                        -- Apply workspace config port with CLI port precedence
                        updatedConfig =
                            Config.applyWorkspacePort model.cliPort config.serverPort model.config

                        -- Warn if the workspace config port differs from the running server port
                        portWarningCmd =
                            when config.serverPort is
                                Just wsPort ->
                                    if wsPort /= model.config.serverPort then
                                        Logging.logWarn model.logger ("Workspace config specifies port " ++ String.fromInt wsPort ++ " but server is running on " ++ String.fromInt model.config.serverPort ++ ". Restart required for port change to take effect.") NoOp
                                    else
                                        Cmd.none

                                Nothing ->
                                    Cmd.none
                    in
                    { model =
                        { model
                            | workspaceConfig = Just config
                            , workspaceConfigPath = Just configPath
                            , config = updatedConfig
                            , pendingConfigResponse = pendingConfig
                            , registry =
                                if shouldDefer then Nothing else model.registry
                            , agentRegistry =
                                if shouldDefer then Nothing else model.agentRegistry
                            , providerRegistry =
                                if shouldDefer then Nothing else model.providerRegistry
                        }
                    , command =
                        Cmd.batch
                            [ initRegistryCmd
                            , initAgentRegistryCmd
                            , initProviderRegistryCmd
                            , ensureUploadDirCmd
                            , responseCmd
                            , portWarningCmd
                            , Logging.logInfo model.logger ("Workspace config loaded from: " ++ configPath) NoOp
                            ]
                    }

        NoOp ->
            { model = model
            , command = Cmd.none
            }


{-| Route the request to the appropriate handler.
-}
handleRoute : Model -> Router.Route -> HttpServer.Request -> Response -> Cmd Msg
handleRoute model route request response =
    when route is
        Router.StaticFile filePath ->
            Static.readStaticFile
                { filesystemPermission = model.filesystemPermission
                , staticRoot = Path.fromPosixString model.config.staticRoot
                }
                filePath
                (\staticResult -> GotStaticFile { id = 0, response = response, result = staticResult })

        -- Config routes work without registry (they set up the workspace)
        Router.GetConfig ->
            handleGetConfig model response

        Router.UpdateConfig ->
            handleUpdateConfig model request response

        Router.SelectConfig ->
            handleSelectConfig model request response

        Router.CreateConfig ->
            handleCreateConfig model request response

        _ ->
            -- All other API routes need registry
            when model.registry is
                Nothing ->
                    sendServiceUnavailable response

                Just registry ->
                    let
                        ctx =
                            { registry = registry
                            , filesystemPermission = model.filesystemPermission
                            , secureContext = model.secureContext
                            , registryRoot = registryRootPath model
                            }

                        toMsg =
                            \apiResult -> GotApiResult { response = response, result = apiResult }
                    in
                    when route is
                        Router.ListTasks maybeStatus ->
                            Api.requestTasks ctx maybeStatus toMsg

                        Router.GetTask taskId ->
                            Api.requestTask ctx taskId toMsg

                        Router.CreateTask ->
                            when parseCreateTaskBody request is
                                Ok params ->
                                    Api.requestCreateTask ctx params
                                        (\apiResult ->
                                            let
                                                taskIdResult =
                                                    when apiResult is
                                                        Api.ApiSuccess { body } ->
                                                            Decode.decodeString (Decode.at [ "data", "id" ] Decode.string) body
                                                                |> Result.mapError Decode.errorToString
                                                                |> Result.andThen (\idStr ->
                                                                    when Id.taskIdFromString idStr is
                                                                        Just taskId -> Ok taskId
                                                                        Nothing -> Err "Invalid task ID"
                                                                )

                                                        _ ->
                                                            Err "Create failed"
                                            in
                                            when taskIdResult is
                                                Ok taskId ->
                                                    GotTaskCreated { response = response, taskId = taskId, description = params.description, result = apiResult }

                                                Err _ ->
                                                    GotApiResult { response = response, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskStatus taskId ->
                            when parseStatusBody request is
                                Ok status ->
                                    Api.requestUpdateStatus ctx taskId status Nothing toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UpdateTaskPlanning taskId ->
                            when parseUpdatePlanningBody request is
                                Ok params ->
                                    Api.requestUpdatePlanning ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.GetTaskHistory taskId ->
                            Api.requestHistory ctx taskId toMsg

                        Router.GetTaskQueue taskId ->
                            Api.requestQueue ctx taskId toMsg

                        Router.EnqueueMessage taskId ->
                            when parseEnqueueBody request is
                                Ok content ->
                                    Api.requestEnqueue ctx taskId content toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.UploadAttachment { taskId, filename } ->
                            Api.requestUploadAttachment ctx taskId filename request.body (uploadDir model) toMsg

                        Router.DownloadAttachment { taskId, filename } ->
                            let
                                toBinaryMsg =
                                    \binaryResult -> GotBinaryResult { response = response, result = binaryResult }
                            in
                            Api.requestDownloadAttachment ctx taskId filename (uploadDir model) toBinaryMsg

                        Router.DeleteAttachment { taskId, filename } ->
                            Api.requestDeleteAttachment ctx taskId filename (uploadDir model) toMsg

                        Router.ExecuteTool taskId ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendBadRequest response "Agent registry not initialized"

                                Just agentReg ->
                                    let
                                        bodyStr =
                                            Bytes.toString request.body
                                                |> Maybe.withDefault ""

                                        -- Look up task to find current agent, then look up agent config
                                        lookupTask =
                                            Registry.getTask registry taskId
                                                |> GrenTask.mapError (\err -> Registry.errorToString err)
                                                |> GrenTask.andThen
                                                    (\maybeTask ->
                                                        when maybeTask is
                                                            Nothing ->
                                                                GrenTask.fail ("Task not found: " ++ Id.taskIdToString taskId)

                                                            Just task ->
                                                                when Types.taskCurrentAgent task is
                                                                    Nothing ->
                                                                        GrenTask.fail "No agent currently active on this task"

                                                                    Just agentName ->
                                                                        AgentRegistry.getAgent agentReg agentName
                                                                            |> GrenTask.mapError (\err -> "Agent not found: " ++ AgentRegistry.errorToString err)
                                                                            |> GrenTask.map (\config -> { agentConfig = config })
                                                    )
                                    in
                                    lookupTask
                                        |> GrenTask.attempt
                                            (\result ->
                                                GotToolAgentLookup
                                                    { taskId = taskId
                                                    , requestBody = bodyStr
                                                    , response = response
                                                    , result = result
                                                    }
                                            )

                        Router.UpdateAgentTools taskId ->
                            when parseToolGrantBody request is
                                Ok params ->
                                    GrenTask.succeed {}
                                        |> GrenTask.perform
                                            (\_ ->
                                                GotToolGrant
                                                    { taskId = taskId
                                                    , addTools = params.addTools
                                                    , removeTools = params.removeTools
                                                    , response = response
                                                    }
                                            )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.SubmitAnswers taskId ->
                            when parseSubmitAnswersBody request is
                                Ok answers ->
                                    Api.requestSubmitAnswers ctx taskId answers
                                        (\{ apiResult, enrichedPrompt } ->
                                            GotAnswersSubmitted { response = response, taskId = taskId, enrichedPrompt = enrichedPrompt, result = apiResult }
                                        )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.PlanTask taskId ->
                            Api.requestPlanTask ctx taskId
                                (\{ apiResult, description } ->
                                    GotPlanTaskResult { response = response, taskId = taskId, description = description, result = apiResult }
                                )

                        Router.StartHandoff taskId ->
                            when parseStartHandoffBody request is
                                Ok params ->
                                    when model.agentRegistry is
                                        Nothing ->
                                            sendBadRequest response "Agent registry not initialized"

                                        Just agentReg ->
                                            -- Look up the agent, then validate its provider exists
                                            AgentRegistry.getAgent agentReg params.agentName
                                                |> GrenTask.andThen
                                                    (\agentConfig ->
                                                        -- Validate provider exists for user-defined agents
                                                        when agentConfig is
                                                            UserDefinedAgent r ->
                                                                when r.provider is
                                                                    NotConfigured ->
                                                                        GrenTask.fail (AgentRegistry.FileSystemError ("Agent '" ++ params.agentName ++ "' has no provider configured"))

                                                                    ProviderRef providerName ->
                                                                        when model.providerRegistry is
                                                                            Nothing ->
                                                                                GrenTask.fail (AgentRegistry.FileSystemError "Provider registry not available")

                                                                            Just providerReg ->
                                                                                ProviderRegistry.getProvider providerReg providerName
                                                                                    |> GrenTask.map (\_ -> agentConfig)
                                                                                    |> GrenTask.onError
                                                                                        (\_ ->
                                                                                            GrenTask.fail (AgentRegistry.FileSystemError ("Agent '" ++ params.agentName ++ "' references provider '" ++ providerName ++ "' which does not exist"))
                                                                                        )

                                                            InternalAgent _ ->
                                                                GrenTask.succeed agentConfig
                                                    )
                                                |> GrenTask.attempt
                                                    (\result ->
                                                        GotAgentLookup
                                                            { taskId = taskId
                                                            , prompt = params.prompt
                                                            , response = response
                                                            , result = result
                                                            }
                                                    )

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.CompleteHandoff taskId ->
                            when parseCompleteHandoffBody request is
                                Ok params ->
                                    Api.requestCompleteHandoff ctx taskId params toMsg

                                Err errMsg ->
                                    sendBadRequest response errMsg

                        Router.ListAgents ->
                            when { agentReg = model.agentRegistry, providerReg = model.providerRegistry } is
                                { agentReg = Just ar, providerReg = Just pr } ->
                                    Api.requestAgents ar pr toMsg

                                _ ->
                                    sendServiceUnavailable response

                        Router.GetAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestAgent agentReg agentName toMsg

                        Router.CreateAgent ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestCreateAgent agentReg agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    when parseAgentBody request is
                                        Ok agentConfig ->
                                            Api.requestUpdateAgent agentReg agentName agentConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteAgent agentName ->
                            when model.agentRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just agentReg ->
                                    Api.requestDeleteAgent agentReg agentName toMsg

                        Router.ListProviders ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    Api.requestProviders providerReg toMsg

                        Router.GetProvider providerName ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    Api.requestProvider providerReg providerName toMsg

                        Router.CreateProvider ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    when parseProviderBody request is
                                        Ok providerConfig ->
                                            Api.requestCreateProvider providerReg providerConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.UpdateProvider providerName ->
                            when model.providerRegistry is
                                Nothing ->
                                    sendServiceUnavailable response

                                Just providerReg ->
                                    when parseProviderBody request is
                                        Ok providerConfig ->
                                            Api.requestUpdateProvider providerReg providerName providerConfig toMsg

                                        Err errMsg ->
                                            sendBadRequest response errMsg

                        Router.DeleteProvider providerName ->
                            when { providerReg = model.providerRegistry, agentReg = model.agentRegistry } is
                                { providerReg = Just pr, agentReg = Just ar } ->
                                    Api.requestDeleteProvider pr ar providerName toMsg

                                _ ->
                                    sendServiceUnavailable response

                        Router.NotFound ->
                            sendNotFound response

                        Router.StaticFile _ ->
                            -- Already handled above, but needed for exhaustive match
                            sendNotFound response

                        -- Config routes are handled in the outer when branch
                        Router.GetConfig ->
                            sendNotFound response

                        Router.UpdateConfig ->
                            sendNotFound response

                        Router.SelectConfig ->
                            sendNotFound response

                        Router.CreateConfig ->
                            sendNotFound response


{-| Send a 503 Service Unavailable response when registry isn't ready.
-}
sendServiceUnavailable : Response -> Cmd Msg
sendServiceUnavailable response =
    response
        |> Response.setStatus 503
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"SERVICE_UNAVAILABLE\",\"message\":\"Server initializing\"}}"
        |> Response.send


{-| Send a 400 Bad Request response.
-}
sendBadRequest : Response -> String -> Cmd Msg
sendBadRequest response message =
    let
        body =
            Encode.object
                [ { key = "error"
                  , value =
                        Encode.object
                            [ { key = "code", value = Encode.string "BAD_REQUEST" }
                            , { key = "message", value = Encode.string message }
                            ]
                  }
                ]
                |> Encode.encode 0
    in
    response
        |> Response.setStatus 400
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| Send a 404 Not Found response.
-}
sendNotFound : Response -> Cmd Msg
sendNotFound response =
    response
        |> Response.setStatus 404
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"Endpoint not found\"}}"
        |> Response.send



-- REQUEST BODY PARSING


{-| Parse the body for POST /api/tasks.
-}
parseCreateTaskBody : HttpServer.Request -> Result String Api.CreateTaskParams
parseCreateTaskBody request =
    let
        decoder =
            Decode.map2
                (\description source ->
                    { description = description
                    , source = source
                    }
                )
                (Decode.field "description" Decode.string)
                (Decode.field "source" Types.sourceInfoDecoder)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for task creation"


{-| Parse the body for PUT /api/tasks/:id/status.

    The frontend sends status as a nested object matching the encoding format:
    {"status": {"type": "active"}} or {"status": {"type": "failed", "message": "..."}}
    We also accept the flat format {"status": "active"} for backward compatibility
    with direct API callers.
-}
parseStatusBody : HttpServer.Request -> Result String TaskStatus
parseStatusBody request =
    let
        -- Nested object format: {"status": {"type": "active"}}
        nestedDecoder =
            Decode.field "status"
                (Decode.field "type" Decode.string
                    |> Decode.andThen
                        (\statusType ->
                            when statusType is
                                "pending" ->
                                    Decode.succeed Pending

                                "planning" ->
                                    Decode.succeed Planning

                                "awaiting_input" ->
                                    Decode.succeed AwaitingInput

                                "planned" ->
                                    Decode.succeed ReadyToStart

                                "active" ->
                                    Decode.succeed Active

                                "waiting" ->
                                    Decode.succeed Waiting

                                "completed" ->
                                    Decode.succeed Completed

                                "failed" ->
                                    Decode.oneOf
                                        [ Decode.field "message" Decode.string
                                            |> Decode.map Failed
                                        , Decode.succeed (Failed "")
                                        ]

                                _ ->
                                    Decode.fail ("Unknown status type: " ++ statusType)
                        )
                )

        -- Flat string format: {"status": "active"} (backward compatibility)
        flatDecoder =
            Decode.field "status" Decode.string
                |> Decode.andThen
                    (\statusStr ->
                        when statusStr is
                            "pending" ->
                                Decode.succeed Pending

                            "planning" ->
                                Decode.succeed Planning

                            "awaiting_input" ->
                                Decode.succeed AwaitingInput

                            "planned" ->
                                Decode.succeed ReadyToStart

                            "active" ->
                                Decode.succeed Active

                            "waiting" ->
                                Decode.succeed Waiting

                            "completed" ->
                                Decode.succeed Completed

                            "failed" ->
                                Decode.succeed (Failed "")

                            _ ->
                                Decode.fail ("Unknown status: " ++ statusStr)
                    )

        decoder =
            Decode.oneOf [ nestedDecoder, flatDecoder ]
    in
    when HttpServer.bodyFromJson decoder request is
        Ok status ->
            Ok status

        Err _ ->
            Err "Invalid JSON body for status update"


{-| Parse the body for POST /api/tasks/:id/queue.
-}
parseEnqueueBody : HttpServer.Request -> Result String String
parseEnqueueBody request =
    let
        decoder =
            Decode.field "content" Decode.string
    in
    when HttpServer.bodyFromJson decoder request is
        Ok content ->
            Ok content

        Err _ ->
            Err "Invalid JSON body for enqueue"


{-| Parse the body for PUT /api/tasks/:id/planning.
-}
parseUpdatePlanningBody : HttpServer.Request -> Result String Api.UpdatePlanningParams
parseUpdatePlanningBody request =
    let
        decoder =
            Decode.map4
                (\summary requirements acceptanceCriteria plan ->
                    { summary = summary
                    , requirements = requirements
                    , acceptanceCriteria = acceptanceCriteria
                    , plan = plan
                    }
                )
                (Decode.maybe (Decode.field "summary" Decode.string))
                (Decode.maybe (Decode.field "requirements" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "acceptanceCriteria" (Decode.array Decode.string)))
                (Decode.maybe (Decode.field "plan" (Decode.array Decode.string)))
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for planning update"



{-| Parse the body for POST /api/tasks/:id/handoff.
-}
parseStartHandoffBody : HttpServer.Request -> Result String Api.StartHandoffParams
parseStartHandoffBody request =
    let
        decoder =
            Decode.map2
                (\agentName prompt ->
                    { agentName = agentName
                    , prompt = prompt
                    }
                )
                (Decode.field "agentName" Decode.string)
                (Decode.field "prompt" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff"


{-| Parse the body for PUT /api/tasks/:id/handoff/complete.
-}
parseCompleteHandoffBody : HttpServer.Request -> Result String Api.CompleteHandoffParams
parseCompleteHandoffBody request =
    let
        decoder =
            Decode.map (\output -> { output = output })
                (Decode.field "output" Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for handoff completion"


{-| Parse the body for POST /api/tasks/:id/answers.
-}
parseSubmitAnswersBody : HttpServer.Request -> Result String (Array String)
parseSubmitAnswersBody request =
    let
        decoder =
            Decode.field "answers" (Decode.array Decode.string)
    in
    when HttpServer.bodyFromJson decoder request is
        Ok answers ->
            Ok answers

        Err _ ->
            Err "Invalid JSON body for answer submission"


{-| Parse the body for PUT /api/tasks/:id/agent-tools.
-}
parseToolGrantBody : HttpServer.Request -> Result String { addTools : Array String, removeTools : Array String }
parseToolGrantBody request =
    let
        decoder =
            Decode.map2
                (\addTools removeTools ->
                    { addTools = addTools
                    , removeTools = removeTools
                    }
                )
                (Decode.maybe (Decode.field "addTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
                (Decode.maybe (Decode.field "removeTools" (Decode.array Decode.string))
                    |> Decode.map (Maybe.withDefault [])
                )
    in
    when HttpServer.bodyFromJson decoder request is
        Ok params ->
            Ok params

        Err _ ->
            Err "Invalid JSON body for tool grant"


{-| Parse the body for POST /api/agents or PUT /api/agents/:name.
-}
parseAgentBody : HttpServer.Request -> Result String Types.AgentConfig
parseAgentBody request =
    when HttpServer.bodyFromJson Types.agentConfigDecoder request is
        Ok agentConfig ->
            Ok agentConfig

        Err _ ->
            Err "Invalid JSON body for agent config"


{-| Parse the body for POST /api/providers or PUT /api/providers/:name.
-}
parseProviderBody : HttpServer.Request -> Result String Types.ProviderConfig
parseProviderBody request =
    when HttpServer.bodyFromJson Types.providerConfigDecoder request is
        Ok providerConfig ->
            Ok providerConfig

        Err _ ->
            Err "Invalid JSON body for provider config"


-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server (\req resp -> GotRequest { request = req, response = resp })

        Nothing ->
            Sub.none



-- PLANNER


{-| Parsed output from the system planner agent.
-}
type PlannerOutput
    = PlanResult Types.PlanningFields
    | QuestionsResult (Array String)
    | PlannerParseError String


{-| Spawn the task-validator agent for a newly created task.

Uses the system agent provider from workspace config instead of
hardcoded ClaudeCode.
-}
dispatchPlanner : Model -> AgentRegistry.AgentRegistry -> TaskId -> String -> Cmd Msg
dispatchPlanner model agentReg taskId description =
    -- First check if system agent provider is configured
    when model.workspaceConfig is
        Nothing ->
            GrenTask.succeed (Err "No workspace config loaded - cannot run system agent")
                |> GrenTask.perform (\r -> GotPlannerComplete { taskId = taskId, result = r })

        Just wc ->
            when wc.systemAgentProvider is
                NotConfigured ->
                    GrenTask.succeed (Err "System agent provider is not configured. Please configure it in System Settings.")
                        |> GrenTask.perform (\r -> GotPlannerComplete { taskId = taskId, result = r })

                ProviderRef providerName ->
                    AgentRegistry.getAgent agentReg "task-validator"
                        |> GrenTask.mapError AgentRegistry.errorToString
                        |> GrenTask.andThen
                            (\agentConfig ->
                                -- Set task status to Planning and record planning_started event
                                when model.registry is
                                    Nothing ->
                                        GrenTask.succeed agentConfig

                                    Just registry ->
                                        Registry.updateStatus registry taskId Types.Planning
                                            |> GrenTask.andThen
                                                (\_ ->
                                                    Registry.recordEvent registry taskId
                                                        { eventType = "planning_started"
                                                        , data =
                                                            Dict.empty
                                                                |> Dict.set "description" description
                                                        }
                                                        |> GrenTask.map (\_ -> agentConfig)
                                                )
                                            |> GrenTask.onError (\_ -> GrenTask.succeed agentConfig)
                            )
                        |> GrenTask.andThen
                            (\agentConfig ->
                                -- Resolve the system agent provider
                                when model.providerRegistry is
                                    Nothing ->
                                        GrenTask.fail "Provider registry not available"

                                    Just providerReg ->
                                        ProviderRegistry.getProvider providerReg providerName
                                            |> GrenTask.mapError (\_ -> "System agent provider '" ++ providerName ++ "' not found in provider registry")
                                            |> GrenTask.andThen
                                                (\providerConfig ->
                                                    let
                                                        agentInstructions =
                                                            when agentConfig is
                                                                InternalAgent r ->
                                                                    r.instructions

                                                                UserDefinedAgent r ->
                                                                    r.instructions

                                                        systemPrompt =
                                                            if String.isEmpty agentInstructions then
                                                                Nothing
                                                            else
                                                                Just agentInstructions

                                                        shellCommandResult =
                                                            buildShellCommandForProvider model providerConfig agentConfig
                                                                { systemPrompt = systemPrompt
                                                                , initialDirectory = initialAgentDir model
                                                                , message = description
                                                                , taskId = Just (Id.taskIdToString taskId)
                                                                }

                                                        options =
                                                            { shell = ChildProcess.NoShell
                                                            , workingDirectory = ChildProcess.InheritWorkingDirectory
                                                            , environmentVariables = ChildProcess.InheritEnvironmentVariables
                                                            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
                                                            , runDuration = ChildProcess.Milliseconds 300000
                                                            }
                                                    in
                                                    when shellCommandResult is
                                                        Err errMsg ->
                                                            GrenTask.fail errMsg

                                                        Ok shellCommand ->
                                                            ChildProcess.run model.childProcessPermission "bash" [ "-c", shellCommand ] options
                                                                |> GrenTask.map
                                                                    (\cliResult ->
                                                                        let
                                                                            output =
                                                                                cliResult.stdout
                                                                                    |> Bytes.toString
                                                                                    |> Maybe.withDefault ""

                                                                            resultText =
                                                                                when Decode.decodeString (Decode.field "result" Decode.string) output is
                                                                                    Ok text ->
                                                                                        text

                                                                                    Err _ ->
                                                                                        output
                                                                        in
                                                                        Ok resultText
                                                                    )
                                                                |> GrenTask.onError
                                                                    (\runError ->
                                                                        let
                                                                            errMsg =
                                                                                when runError is
                                                                                    ChildProcess.InitError { errorCode } ->
                                                                                        "Failed to start planner CLI: " ++ errorCode

                                                                                    ChildProcess.ProgramError { exitCode, stderr } ->
                                                                                        let
                                                                                            stderrStr =
                                                                                                stderr
                                                                                                    |> Bytes.toString
                                                                                                    |> Maybe.withDefault ""
                                                                                        in
                                                                                        "Planner CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                                                                        in
                                                                        GrenTask.succeed (Err errMsg)
                                                                    )
                                                )
                            )
                        |> GrenTask.onError
                            (\errMsg ->
                                GrenTask.succeed (Err errMsg)
                            )
                        |> GrenTask.perform (\r -> GotPlannerComplete { taskId = taskId, result = r })


{-| Parse planner output. Extracts JSON from a code fence in the output.
-}
parsePlannerOutput : String -> PlannerOutput
parsePlannerOutput output =
    let
        -- Extract JSON from ```json ... ``` code fence
        jsonStr =
            extractJsonCodeFence output
    in
    when jsonStr is
        Nothing ->
            PlannerParseError "No JSON code fence found in planner output"

        Just json ->
            when Decode.decodeString (Decode.field "type" Decode.string) json is
                Err _ ->
                    PlannerParseError "Missing 'type' field in planner JSON"

                Ok planType ->
                    when planType is
                        "plan" ->
                            when Decode.decodeString planResultDecoder json is
                                Ok fields ->
                                    PlanResult fields

                                Err err ->
                                    PlannerParseError ("Invalid plan JSON: " ++ Decode.errorToString err)

                        "questions" ->
                            when Decode.decodeString questionsResultDecoder json is
                                Ok questions ->
                                    QuestionsResult questions

                                Err err ->
                                    PlannerParseError ("Invalid questions JSON: " ++ Decode.errorToString err)

                        _ ->
                            PlannerParseError ("Unknown planner output type: " ++ planType)


{-| Extract the first JSON code fence from text.
-}
extractJsonCodeFence : String -> Maybe String
extractJsonCodeFence text =
    let
        lines =
            String.split "\n" text

        findStart remainingLines =
            when Array.first remainingLines is
                Nothing ->
                    Nothing

                Just line ->
                    let
                        trimmed =
                            String.trim line
                    in
                    if trimmed == "```json" || trimmed == "```" then
                        findEnd (Array.dropFirst 1 remainingLines) []
                    else
                        findStart (Array.dropFirst 1 remainingLines)

        findEnd remainingLines acc =
            when Array.first remainingLines is
                Nothing ->
                    Nothing

                Just line ->
                    if String.trim line == "```" then
                        Just (String.join "\n" acc)
                    else
                        findEnd (Array.dropFirst 1 remainingLines) (Array.pushLast line acc)
    in
    findStart lines


planResultDecoder : Decode.Decoder Types.PlanningFields
planResultDecoder =
    Decode.map5
        (\summary requirements acceptanceCriteria plan assignedAgent ->
            { summary = summary
            , requirements = requirements
            , acceptanceCriteria = acceptanceCriteria
            , plan = plan
            , questions = []
            , assignedAgent = assignedAgent
            }
        )
        (Decode.field "summary" Decode.string)
        (Decode.field "requirements" (Decode.array Decode.string))
        (Decode.field "acceptanceCriteria" (Decode.array Decode.string))
        (Decode.field "plan" (Decode.array Decode.string))
        (Decode.maybe (Decode.field "assignedAgent" Decode.string))


questionsResultDecoder : Decode.Decoder (Array String)
questionsResultDecoder =
    Decode.field "questions" (Decode.array Decode.string)



-- WORKSPACE CONFIG


{-| Return the parent directory of a file path by stripping the last segment.

For example, `parentDirectory "/home/user/chorus.json"` returns `"/home/user"`.
-}
parentDirectory : String -> String
parentDirectory path =
    path
        |> String.split "/"
        |> Array.dropLast 1
        |> String.join "/"


{-| Derive the workspace root directory from the config file path.

Strips the filename (chorus.json) from the config path to get the directory.
This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
workspaceRoot : Model -> String
workspaceRoot model =
    when model.workspaceConfigPath is
        Just configPath ->
            parentDirectory configPath

        Nothing ->
            Debug.todo "workspaceRoot called without a loaded workspace config"


{-| Derive the registry root path from workspace root.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
registryRootPath : Model -> Path
registryRootPath model =
    Path.fromPosixString (workspaceRoot model ++ "/registry")


{-| Derive the upload directory from workspace root.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
uploadDir : Model -> String
uploadDir model =
    workspaceRoot model ++ "/uploads"


{-| Get the initial agent directory from workspace config.

This function is only called in code paths where a workspace config is loaded
(guarded by model.registry being Just), so the Nothing branch is unreachable.
-}
initialAgentDir : Model -> String
initialAgentDir model =
    when model.workspaceConfig is
        Just workspaceConfig ->
            workspaceConfig.initialAgentDirectory

        Nothing ->
            Debug.todo "initialAgentDir called without a loaded workspace config"


{-| Load a workspace config from a filesystem path.

Reads and decodes the `chorus.json` file at the given path.
Returns the decoded config and the path it was loaded from.
-}
loadWorkspaceConfig : FileSystem.Permission -> String -> GrenTask.Task Never (Result String { config : WorkspaceConfig, configPath : String })
loadWorkspaceConfig filesystemPermission configPath =
    let
        path =
            Path.fromPosixString configPath
    in
    FileSystem.readFile filesystemPermission path
        |> GrenTask.mapError (\e -> FileSystem.errorToString e)
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail "Could not decode config file as UTF-8"

                    Just content ->
                        when Decode.decodeString Types.workspaceConfigDecoder content is
                            Ok config ->
                                GrenTask.succeed { config = config, configPath = configPath }

                            Err err ->
                                GrenTask.fail ("Invalid config JSON: " ++ Decode.errorToString err)
            )
        |> GrenTask.map Ok
        |> GrenTask.onError (\err -> GrenTask.succeed (Err err))


{-| Save a workspace config to a filesystem path.
-}
saveWorkspaceConfig : FileSystem.Permission -> String -> WorkspaceConfig -> GrenTask.Task Never (Result String {})
saveWorkspaceConfig filesystemPermission configPath wsConfig =
    let
        path =
            Path.fromPosixString configPath

        json =
            Types.encodeWorkspaceConfig wsConfig
                |> Encode.encode 2

        bytes =
            Bytes.fromString json
    in
    FileSystem.writeFile filesystemPermission bytes path
        |> GrenTask.map (\_ -> Ok {})
        |> GrenTask.onError (\err -> GrenTask.succeed (Err (FileSystem.errorToString err)))


{-| Create a new workspace config with defaults relative to the given directory.
-}
createWorkspaceConfig : FileSystem.Permission -> String -> GrenTask.Task Never (Result String { config : WorkspaceConfig, configPath : String })
createWorkspaceConfig filesystemPermission dirPath =
    let
        configPath =
            dirPath ++ "/chorus.json"

        agentsDir =
            dirPath ++ "/agents"

        wsConfig =
            { allowedAgentDirectories = []
            , initialAgentDirectory = ""
            , systemAgentProvider = NotConfigured
            , serverPort = Nothing
            }

        json =
            Types.encodeWorkspaceConfig wsConfig
                |> Encode.encode 2

        bytes =
            Bytes.fromString json

        configFilePath =
            Path.fromPosixString configPath

        -- Ensure directories exist (propagate errors instead of swallowing)
        ensureDir p =
            FileSystem.makeDirectory filesystemPermission { recursive = True } (Path.fromPosixString p)
                |> GrenTask.map (\_ -> {})
                |> GrenTask.mapError (\err -> FileSystem.errorToString err)
    in
    ensureDir dirPath
        |> GrenTask.andThen (\_ -> ensureDir agentsDir)
        |> GrenTask.andThen
            (\_ ->
                FileSystem.writeFile filesystemPermission bytes configFilePath
                    |> GrenTask.mapError (\err -> FileSystem.errorToString err)
                    |> GrenTask.map (\_ -> Ok { config = wsConfig, configPath = configPath })
            )
        |> GrenTask.onError (\err -> GrenTask.succeed (Err err))



-- CONFIG API HANDLERS


{-| Handle GET /api/config.
-}
handleGetConfig : Model -> Response -> Cmd Msg
handleGetConfig model response =
    when model.workspaceConfig is
        Nothing ->
            response
                |> Response.setStatus 404
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody "{\"error\":{\"code\":\"NOT_FOUND\",\"message\":\"No workspace config loaded\"}}"
                |> Response.send

        Just config ->
            let
                body =
                    Encode.object
                        [ { key = "data", value = Types.encodeWorkspaceConfig config }
                        , { key = "configPath", value = Encode.string (Maybe.withDefault "" model.workspaceConfigPath) }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus 200
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody body
                |> Response.send


{-| Handle PUT /api/config.

Validates that initialAgentDirectory is one of the allowedAgentDirectories
before saving, as required by the acceptance criteria.
-}
handleUpdateConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleUpdateConfig model request response =
    when { workspaceConfig = model.workspaceConfig, configPath = model.workspaceConfigPath } is
        { workspaceConfig = Just _, configPath = Just currentConfigPath } ->
            when HttpServer.bodyFromJson Types.workspaceConfigDecoder request is
                Err _ ->
                    sendBadRequest response "Invalid JSON body for config update"

                Ok newConfig ->
                    if not (String.isEmpty newConfig.initialAgentDirectory || Array.any (\dir -> dir == newConfig.initialAgentDirectory) newConfig.allowedAgentDirectories) then
                        sendBadRequest response "initialAgentDirectory must be one of the allowedAgentDirectories"
                    else
                        saveWorkspaceConfig model.filesystemPermission currentConfigPath newConfig
                            |> GrenTask.perform
                                (\result ->
                                    when result is
                                        Ok _ ->
                                            GotConfigLoaded
                                                { response = Just response
                                                , deferResponse = False
                                                , result = Ok { config = newConfig, configPath = currentConfigPath }
                                                }

                                        Err errMsg ->
                                            GotApiResult
                                                { response = response
                                                , result = Api.ApiError { statusCode = 500, code = "WRITE_ERROR", message = errMsg }
                                                }
                                )

        _ ->
            sendBadRequest response "No workspace config loaded"


{-| Handle POST /api/config/select.
-}
handleSelectConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleSelectConfig model request response =
    when HttpServer.bodyFromJson (Decode.field "path" Decode.string) request is
        Err _ ->
            sendBadRequest response "Invalid JSON body: requires 'path' field"

        Ok configPath ->
            loadWorkspaceConfig model.filesystemPermission configPath
                |> GrenTask.perform
                    (\result ->
                        GotConfigLoaded { response = Just response, deferResponse = True, result = result }
                    )


{-| Handle POST /api/config/create.
-}
handleCreateConfig : Model -> HttpServer.Request -> Response -> Cmd Msg
handleCreateConfig model request response =
    when HttpServer.bodyFromJson (Decode.field "path" Decode.string) request is
        Err _ ->
            sendBadRequest response "Invalid JSON body: requires 'path' field (directory)"

        Ok dirPath ->
            createWorkspaceConfig model.filesystemPermission dirPath
                |> GrenTask.perform
                    (\result ->
                        GotConfigLoaded { response = Just response, deferResponse = True, result = result }
                    )



-- HELPERS


{-| Send a config response to the client.
-}
sendConfigResponse : Response -> WorkspaceConfig -> String -> Cmd Msg
sendConfigResponse resp config configPath =
    let
        body =
            Encode.object
                [ { key = "data", value = Types.encodeWorkspaceConfig config }
                , { key = "configPath", value = Encode.string configPath }
                ]
                |> Encode.encode 0
    in
    resp
        |> Response.setStatus 200
        |> Response.setHeader "Content-Type" "application/json"
        |> Response.setBody body
        |> Response.send


{-| If all three registries are initialized and there is a pending config
response, send it and clear the pending state.
-}
flushPendingConfigResponse : Model -> { model : Model, command : Cmd Msg }
flushPendingConfigResponse model =
    when { pending = model.pendingConfigResponse, reg = model.registry, agent = model.agentRegistry, provider = model.providerRegistry } is
        { pending = Just { response, config, configPath }, reg = Just _, agent = Just _, provider = Just _ } ->
            { model = { model | pendingConfigResponse = Nothing }
            , command = sendConfigResponse response config configPath
            }

        _ ->
            { model = model
            , command = Cmd.none
            }


{-| If a registry fails to initialize and there is a pending config response,
send a 500 error and clear the pending state.
-}
failPendingConfigResponse : Model -> String -> { model : Model, command : Cmd Msg }
failPendingConfigResponse model errMsg =
    when model.pendingConfigResponse is
        Just { response } ->
            { model = { model | pendingConfigResponse = Nothing }
            , command =
                response
                    |> Response.setStatus 500
                    |> Response.setHeader "Content-Type" "application/json"
                    |> Response.setBody (Encode.encode 0 (Encode.object [ { key = "error", value = Encode.string errMsg } ]))
                    |> Response.send
            }

        Nothing ->
            { model = model
            , command = Cmd.none
            }


{-| Get a SecureContext for cryptographic operations.
    The error type {} cannot actually be constructed, so this
    effectively never fails.
-}
getSecureContext : GrenTask.Task Never SecureContext
getSecureContext =
    Crypto.getSecureContext
        |> GrenTask.mapError (\{} -> Debug.todo "SecureContext failed")
