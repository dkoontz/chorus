module Config exposing
    ( Config
    , defaultConfig
    , configFromEnv
    , parsePortFromArgs
    , applyCliPort
    , applyWorkspacePort
    )

{-| Application configuration.

Provides config types and constructors. The Config type holds server-level
settings (host, port, static files, tools path, log level). Workspace-level
settings (data directory, agents directory, etc.) are stored in a separate
`chorus.json` file and loaded at runtime via the workspace config system.

The `CHORUS_CONFIG` environment variable can point to a `chorus.json` file
to auto-load a workspace at startup (useful for headless/testing).

-}

import Dict exposing (Dict)
import Logging exposing (LogLevel(..))


type alias Config =
    { host : String
    , serverPort : Int
    , staticRoot : String
    , chorusToolsPath : String
    , logLevel : LogLevel
    , chorusConfigPath : Maybe String
    }


defaultConfig : Config
defaultConfig =
    { host = "0.0.0.0"
    , serverPort = 8080
    , staticRoot = "./static"
    , chorusToolsPath = "./chorus-tools"
    , logLevel = LogInfo
    , chorusConfigPath = Nothing
    }


{-| Create configuration from environment variables.

    The `baseDir` parameter is the parent directory of the running binary,
    used to resolve default paths for static files and tools relative
    to the binary location rather than the current working directory.

    Supported environment variables:
    - CHORUS_HOST: Server host (default: 0.0.0.0)
    - CHORUS_PORT: Server port (default: 8080)
    - CHORUS_STATIC_DIR: Static files directory (default: <baseDir>/static)
    - CHORUS_TOOLS_PATH: Path to chorus-tools binary (default: <baseDir>/chorus-tools)
    - CHORUS_LOG_LEVEL: Log level - error, warn, info, debug (default: info)
    - CHORUS_CONFIG: Path to a chorus.json file to auto-load at startup

-}
configFromEnv : String -> Dict String String -> Config -> Config
configFromEnv baseDir envVars config =
    let
        host =
            Dict.get "CHORUS_HOST" envVars
                |> Maybe.withDefault config.host

        serverPort =
            Dict.get "CHORUS_PORT" envVars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault config.serverPort

        staticRoot =
            Dict.get "CHORUS_STATIC_DIR" envVars
                |> Maybe.withDefault (baseDir ++ "/static")

        logLevel =
            Dict.get "CHORUS_LOG_LEVEL" envVars
                |> Maybe.andThen Logging.parseLogLevel
                |> Maybe.withDefault config.logLevel

        chorusConfigPath =
            Dict.get "CHORUS_CONFIG" envVars
    in
    { host = host
    , serverPort = serverPort
    , staticRoot = staticRoot
    , chorusToolsPath = Dict.get "CHORUS_TOOLS_PATH" envVars |> Maybe.withDefault (baseDir ++ "/chorus-tools")
    , logLevel = logLevel
    , chorusConfigPath = chorusConfigPath
    }


{-| Parse the --port argument from CLI args.

Returns Ok (Just port) if --port is present with a valid value,
Ok Nothing if --port is not present,
Err message if --port is present but has an invalid value.

Valid port range is 1-65535.

-}
parsePortFromArgs : Array String -> Result String (Maybe Int)
parsePortFromArgs args =
    let
        findPort : Array String -> Result String (Maybe Int)
        findPort remaining =
            when Array.first remaining is
                Nothing ->
                    Ok Nothing

                Just arg ->
                    if arg == "--port" then
                        when Array.get 1 remaining is
                            Nothing ->
                                Err "--port requires a value"

                            Just value ->
                                when String.toInt value is
                                    Nothing ->
                                        Err ("Invalid port value: " ++ value ++ " (must be an integer)")

                                    Just portNum ->
                                        if portNum >= 1 && portNum <= 65535 then
                                            Ok (Just portNum)
                                        else
                                            Err ("Port out of range: " ++ String.fromInt portNum ++ " (must be 1-65535)")
                    else
                        findPort (Array.dropFirst 1 remaining)
    in
    findPort args


{-| Apply the CLI --port override to a config.

CLI port takes highest precedence, overriding both env var and default.

-}
applyCliPort : Maybe Int -> Config -> Config
applyCliPort maybePort config =
    when maybePort is
        Just portNum ->
            { config | serverPort = portNum }

        Nothing ->
            config


{-| Apply the workspace config port to a config, but only if no CLI port was specified.

The cliPort parameter indicates whether a CLI port was given (Just = yes, Nothing = no).
If CLI port was given, the workspace config port is ignored (CLI takes precedence).
If no CLI port was given, the workspace config port overrides the current value.

-}
applyWorkspacePort : Maybe Int -> Maybe Int -> Config -> Config
applyWorkspacePort cliPort workspacePort config =
    when cliPort is
        Just _ ->
            -- CLI port takes precedence, ignore workspace config port
            config

        Nothing ->
            when workspacePort is
                Just portNum ->
                    { config | serverPort = portNum }

                Nothing ->
                    config
