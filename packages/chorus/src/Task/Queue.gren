module Task.Queue exposing
    ( Error(..)
    , enqueue
    , dequeue
    , peek
    , isEmpty
    , length
    )

{-| Message queue for tasks.

Each task has a queue of pending messages that arrived while the task's
session was busy processing. Messages are processed in FIFO order.

Queue is stored in `{taskDir}/queue.json`:

    {
      "messages": [
        {
          "id": "msg-uuid",
          "content": "User message text",
          "receivedAt": 1707048600000
        }
      ]
    }

-}

import Bytes
import Crypto exposing (SecureContext)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Id exposing (TaskId)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Task as GrenTask
import Time
import Types exposing (QueuedMessage, Queue)


-- TYPES


{-| Queue operation errors.
-}
type Error
    = FileSystemError String
    | JsonDecodeError String
    | TaskNotFound TaskId



-- OPERATIONS


{-| Add a message to a task's queue.
-}
enqueue :
    FileSystem.Permission
    -> SecureContext
    -> Path
    -> TaskId
    -> String
    -> GrenTask.Task Error QueuedMessage
enqueue filesystemPermission secureContext taskDir taskId content =
    let
        queuePath =
            Path.append (Path.fromPosixString "queue.json") taskDir
    in
    Crypto.randomUuidV4 secureContext
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to generate UUID")
        |> GrenTask.andThen
            (\msgIdStr ->
                when Id.messageIdFromString msgIdStr is
                    Nothing ->
                        GrenTask.fail (FileSystemError "Generated UUID was empty")

                    Just msgId ->
                        GrenTask.map2
                            (\queue now ->
                                { queue = queue
                                , message =
                                    { id = msgId
                                    , content = content
                                    , receivedAt = now
                                    }
                                }
                            )
                            (readQueue filesystemPermission queuePath)
                            Time.now
            )
        |> GrenTask.andThen
            (\{ queue, message } ->
                let
                    updatedQueue =
                        { queue | messages = Array.pushLast message queue.messages }
                in
                writeQueue filesystemPermission queuePath updatedQueue
                    |> GrenTask.map (\_ -> message)
            )


{-| Remove and return the next message from a task's queue.
-}
dequeue :
    FileSystem.Permission
    -> Path
    -> GrenTask.Task Error (Maybe QueuedMessage)
dequeue filesystemPermission taskDir =
    let
        queuePath =
            Path.append (Path.fromPosixString "queue.json") taskDir
    in
    readQueue filesystemPermission queuePath
        |> GrenTask.andThen
            (\queue ->
                when Array.first queue.messages is
                    Nothing ->
                        GrenTask.succeed Nothing

                    Just message ->
                        let
                            updatedQueue =
                                { queue | messages = Array.dropFirst 1 queue.messages }
                        in
                        writeQueue filesystemPermission queuePath updatedQueue
                            |> GrenTask.map (\_ -> Just message)
            )


{-| Look at the next message without removing it.
-}
peek :
    FileSystem.Permission
    -> Path
    -> GrenTask.Task Error (Maybe QueuedMessage)
peek filesystemPermission taskDir =
    let
        queuePath =
            Path.append (Path.fromPosixString "queue.json") taskDir
    in
    readQueue filesystemPermission queuePath
        |> GrenTask.map (\queue -> Array.first queue.messages)


{-| Check if a task's queue is empty.
-}
isEmpty :
    FileSystem.Permission
    -> Path
    -> GrenTask.Task Error Bool
isEmpty filesystemPermission taskDir =
    let
        queuePath =
            Path.append (Path.fromPosixString "queue.json") taskDir
    in
    readQueue filesystemPermission queuePath
        |> GrenTask.map (\queue -> Array.isEmpty queue.messages)


{-| Count messages in a task's queue.
-}
length :
    FileSystem.Permission
    -> Path
    -> GrenTask.Task Error Int
length filesystemPermission taskDir =
    let
        queuePath =
            Path.append (Path.fromPosixString "queue.json") taskDir
    in
    readQueue filesystemPermission queuePath
        |> GrenTask.map (\queue -> Array.length queue.messages)



-- FILE OPERATIONS


{-| Read queue from disk.
-}
readQueue : FileSystem.Permission -> Path -> GrenTask.Task Error Queue
readQueue filesystemPermission path =
    FileSystem.readFile filesystemPermission path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString Types.queueDecoder content is
                            Ok queue ->
                                GrenTask.succeed queue

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


{-| Write queue to disk atomically.
-}
writeQueue : FileSystem.Permission -> Path -> Queue -> GrenTask.Task Error {}
writeQueue filesystemPermission path queue =
    let
        content =
            Types.encodeQueue queue
                |> Encode.encode 2

        tempPath =
            Path.fromPosixString (Path.toPosixString path ++ ".tmp")

        bytes =
            Bytes.fromString content
    in
    FileSystem.writeFile filesystemPermission bytes tempPath
        |> GrenTask.andThen (\_ -> FileSystem.move filesystemPermission path tempPath)
        |> GrenTask.map (\_ -> {})
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
