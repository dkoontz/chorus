module Task.Registry exposing
    ( Registry
    , Error(..)
    , errorToString
    , init
    , createTask
    , getTask
    , updateTask
    , updateStatus
    , listTasks
    , getActiveTasks
    , getRecentTasks
    , recordEvent
    , contentTypeFromExtension
    )

{-| Task Registry - manages task lifecycle and persistence.

Tasks are the central unit of work in Chorus. Each user request becomes a task
that can be tracked, queued, and displayed in a UI.

The registry stores tasks in a file-based structure:

    {registryRoot}/
    ├── registry.json           -- index of all tasks
    └── {task-id}/              -- per-task directory
        ├── task.json           -- task state
        ├── queue.json          -- pending messages
        └── history.json        -- event log

-}

import Bytes
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Id exposing (TaskId, SessionId)
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Task as GrenTask
import Time
import Types exposing (Task(..), TaskStatus(..), EventType(..), SourceInfo, Attachment, Event, History, PlanningFields)


-- TYPES


{-| The registry handle. Contains configuration and secure context for operations.
-}
type Registry
    = Registry
        { filesystemPermission : FileSystem.Permission
        , secureContext : SecureContext
        , registryRoot : Path
        }


{-| Registry operation errors.
-}
type Error
    = FileSystemError String
    | JsonDecodeError String
    | TaskNotFound TaskId
    | RegistryCorrupt String


{-| Convert a registry error to a human-readable string.
-}
errorToString : Error -> String
errorToString err =
    when err is
        FileSystemError msg ->
            "File system error: " ++ msg

        JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        TaskNotFound taskId ->
            "Task not found: " ++ Id.taskIdToString taskId

        RegistryCorrupt msg ->
            "Registry corrupt: " ++ msg



-- INTERNAL SETTERS


{-| Set the updatedAt time on a task. Internal use only.
-}
setUpdatedAt : Time.Posix -> Task -> Task
setUpdatedAt time task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | updatedAt = time }

        Planned t ->
            Planned { t | updatedAt = time }


{-| Set the session ID on a task. Internal use only.
-}
setSessionId : Maybe SessionId -> Task -> Task
setSessionId sid task =
    when task is
        DescriptionOnly t ->
            DescriptionOnly { t | sessionId = sid }

        Planned t ->
            Planned { t | sessionId = sid }



-- INITIALIZATION


{-| Initialize a registry, creating directories if needed.
-}
init :
    FileSystem.Permission
    -> SecureContext
    -> { registryRoot : String }
    -> GrenTask.Task Error Registry
init filesystemPermission secureContext config =
    let
        registryPath =
            Path.fromPosixString config.registryRoot

        registry =
            Registry
                { filesystemPermission = filesystemPermission
                , secureContext = secureContext
                , registryRoot = registryPath
                }
    in
    ensureDirectoryExists filesystemPermission registryPath
        |> GrenTask.andThen (\_ -> ensureRegistryIndex filesystemPermission registryPath)
        |> GrenTask.map (\_ -> registry)


{-| Ensure a directory exists, creating it if necessary.
-}
ensureDirectoryExists : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureDirectoryExists filesystemPermission path =
    FileSystem.makeDirectory filesystemPermission { recursive = True } path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.map (\_ -> {})


{-| Ensure registry.json exists with valid structure.
-}
ensureRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error {}
ensureRegistryIndex filesystemPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot

        emptyIndex =
            encodeRegistryIndex { version = 1, tasks = [] }
                |> Encode.encode 2
    in
    -- Try to access the file - if it succeeds, file exists; if it fails with ENOENT, create it
    FileSystem.checkAccess filesystemPermission [] indexPath
        |> GrenTask.andThen (\_ -> GrenTask.succeed {})
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    writeFileAtomic filesystemPermission indexPath emptyIndex
                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                else
                    GrenTask.fail (FileSystemError (FileSystem.errorToString err))
            )



-- TASK OPERATIONS


{-| Create a new task.
-}
createTask :
    Registry
    -> { description : String, source : SourceInfo }
    -> GrenTask.Task Error Task
createTask (Registry config) { description, source } =
    -- 1. Generate UUID and get current time
    Crypto.randomUuidV4 config.secureContext
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to generate UUID")
        |> GrenTask.andThen
            (\newId ->
                Time.now
                    |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                    |> GrenTask.map (\now -> { newId = newId, now = now })
            )
        |> GrenTask.andThen
            (\{ newId, now } ->
                when Id.taskIdFromString newId is
                    Nothing ->
                        GrenTask.fail (FileSystemError "Generated UUID was empty")

                    Just newTaskId ->
                        let
                            taskDir =
                                Path.append (Path.fromPosixString newId) config.registryRoot

                            task =
                                DescriptionOnly
                                    { id = newTaskId
                                    , description = description
                                    , status = Pending
                                    , createdAt = now
                                    , updatedAt = now
                                    , sessionId = Nothing
                                    , source = source
                                    , attachments = []
                                    , currentAgent = Nothing
                                    , agentChain = []
                                    }
                        in
                        -- 2. Create task directory
                        ensureDirectoryExists config.filesystemPermission taskDir
                            -- 3. Write task.json
                            |> GrenTask.andThen
                                (\_ ->
                                    let
                                        taskPath =
                                            Path.append (Path.fromPosixString "task.json") taskDir

                                        taskJson =
                                            Types.encodeTask task
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.filesystemPermission taskPath taskJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                )
                            -- 5. Write queue.json (empty queue)
                            |> GrenTask.andThen
                                (\_ ->
                                    let
                                        queuePath =
                                            Path.append (Path.fromPosixString "queue.json") taskDir

                                        queueJson =
                                            Types.encodeQueue { messages = [] }
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.filesystemPermission queuePath queueJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                )
                            -- 6. Write history.json with task_created event
                            |> GrenTask.andThen
                                (\_ ->
                                    let
                                        historyPath =
                                            Path.append (Path.fromPosixString "history.json") taskDir

                                        initialEvent =
                                            { timestamp = now
                                            , eventType = TaskCreated
                                            , data = Dict.singleton "description" description
                                            }

                                        historyJson =
                                            Types.encodeHistory { events = [ initialEvent ] }
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.filesystemPermission historyPath historyJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                )
                            -- 7. Update registry.json index
                            |> GrenTask.andThen
                                (\_ ->
                                    updateRegistryIndex config.filesystemPermission config.registryRoot
                                        (\index ->
                                            let
                                                summary =
                                                    { id = newTaskId
                                                    , description = description
                                                    , status = Pending
                                                    , createdAt = now
                                                    , updatedAt = now
                                                    , currentAgent = Nothing
                                                    }
                                            in
                                            { index | tasks = Array.pushLast summary index.tasks }
                                        )
                                )
                            |> GrenTask.map (\_ -> task)
            )


{-| Get a task by ID.
-}
getTask : Registry -> TaskId -> GrenTask.Task Error (Maybe Task)
getTask (Registry config) taskId =
    let
        tidStr =
            Id.taskIdToString taskId

        taskDir =
            Path.append (Path.fromPosixString tidStr) config.registryRoot

        taskPath =
            Path.append (Path.fromPosixString "task.json") taskDir
    in
    FileSystem.readFile config.filesystemPermission taskPath
        |> GrenTask.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    -- Convert to a special marker that we'll handle below
                    GrenTask.fail err
                else
                    GrenTask.fail err
            )
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString Types.taskDecoder content is
                            Ok task ->
                                GrenTask.succeed (Just task)

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    FileSystemError msg ->
                        if String.contains "ENOENT" msg || String.contains "no such file" msg then
                            GrenTask.succeed Nothing
                        else
                            GrenTask.fail err

                    _ ->
                        GrenTask.fail err
            )


{-| Update a task.
-}
updateTask :
    Registry
    -> TaskId
    -> (Task -> Task)
    -> GrenTask.Task Error Task
updateTask (Registry config) theTaskId updateFn =
    getTask (Registry config) theTaskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (TaskNotFound theTaskId)

                    Just task ->
                        Time.now
                            |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
                            |> GrenTask.andThen
                                (\now ->
                                    let
                                        theTaskIdStr =
                                            Id.taskIdToString theTaskId

                                        updatedTask =
                                            updateFn task
                                                |> setUpdatedAt now

                                        taskDir =
                                            Path.append (Path.fromPosixString theTaskIdStr) config.registryRoot

                                        taskPath =
                                            Path.append (Path.fromPosixString "task.json") taskDir

                                        taskJson =
                                            Types.encodeTask updatedTask
                                                |> Encode.encode 2
                                    in
                                    writeFileAtomic config.filesystemPermission taskPath taskJson
                                        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                                        |> GrenTask.andThen
                                            (\_ ->
                                                -- Update registry index with new status/updatedAt/currentAgent
                                                updateRegistryIndex config.filesystemPermission config.registryRoot
                                                    (\index ->
                                                        { index
                                                            | tasks =
                                                                Array.map
                                                                    (\summary ->
                                                                        if summary.id == theTaskId then
                                                                            { summary
                                                                                | status = Types.taskStatus updatedTask
                                                                                , updatedAt = now
                                                                                , currentAgent = Types.taskCurrentAgent updatedTask
                                                                            }
                                                                        else
                                                                            summary
                                                                    )
                                                                    index.tasks
                                                        }
                                                    )
                                            )
                                        |> GrenTask.map (\_ -> updatedTask)
                                )
            )


{-| Update just the task status.
-}
updateStatus :
    Registry
    -> TaskId
    -> TaskStatus
    -> GrenTask.Task Error Task
updateStatus registry theTaskId newStatus =
    updateTask registry theTaskId (Types.setTaskStatus newStatus)


{-| List all tasks, optionally filtered by status.
-}
listTasks : Registry -> Maybe TaskStatus -> GrenTask.Task Error (Array Task)
listTasks (Registry config) maybeStatus =
    readRegistryIndex config.filesystemPermission config.registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    filteredSummaries =
                        when maybeStatus is
                            Nothing ->
                                index.tasks

                            Just status ->
                                Array.keepIf (\s -> Types.statusEquals s.status status) index.tasks
                in
                -- Load each task from disk
                filteredSummaries
                    |> Array.foldl
                        (\summary acc ->
                            acc
                                |> GrenTask.andThen
                                    (\tasks ->
                                        getTask (Registry config) summary.id
                                            |> GrenTask.map
                                                (\maybeTask ->
                                                    when maybeTask is
                                                        Just task ->
                                                            Array.pushLast task tasks

                                                        Nothing ->
                                                            -- Task file missing, skip it
                                                            tasks
                                                )
                                    )
                        )
                        (GrenTask.succeed [])
            )


{-| Get currently active tasks.
-}
getActiveTasks : Registry -> GrenTask.Task Error (Array Task)
getActiveTasks registry =
    listTasks registry (Just Active)


{-| Get recent tasks ordered by updatedAt.
-}
getRecentTasks : Registry -> Int -> GrenTask.Task Error (Array Task)
getRecentTasks registry limit =
    listTasks registry Nothing
        |> GrenTask.map
            (\tasks ->
                tasks
                    |> Array.sortBy (\t -> negate (Time.posixToMillis (Types.taskUpdatedAt t)))
                    |> Array.takeFirst limit
            )


{-| Record an event to the task's history.
-}
recordEvent :
    Registry
    -> TaskId
    -> { eventType : EventType, data : Dict String String }
    -> GrenTask.Task Error {}
recordEvent (Registry config) taskId event =
    let
        tidStr =
            Id.taskIdToString taskId

        taskDir =
            Path.append (Path.fromPosixString tidStr) config.registryRoot

        historyPath =
            Path.append (Path.fromPosixString "history.json") taskDir
    in
    Time.now
        |> GrenTask.mapError (\_ -> FileSystemError "Failed to get time")
        |> GrenTask.andThen
            (\now ->
                readHistory config.filesystemPermission historyPath
                    |> GrenTask.andThen
                        (\history ->
                            let
                                newEvent =
                                    { timestamp = now
                                    , eventType = event.eventType
                                    , data = event.data
                                    }

                                updatedHistory =
                                    { events = Array.pushLast newEvent history.events }

                                historyJson =
                                    Types.encodeHistory updatedHistory
                                        |> Encode.encode 2
                            in
                            writeFileAtomic config.filesystemPermission historyPath historyJson
                                |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
                        )
            )




-- REGISTRY INDEX TYPES AND OPERATIONS


{-| Summary of a task stored in the registry index.
-}
type alias TaskSummary =
    { id : TaskId
    , description : String
    , status : TaskStatus
    , createdAt : Time.Posix
    , updatedAt : Time.Posix
    , currentAgent : Maybe String
    }


{-| Registry index stored in registry.json.
-}
type alias RegistryIndex =
    { version : Int
    , tasks : Array TaskSummary
    }


{-| Read the registry index from disk.
-}
readRegistryIndex : FileSystem.Permission -> Path -> GrenTask.Task Error RegistryIndex
readRegistryIndex filesystemPermission registryRoot =
    let
        indexPath =
            Path.append (Path.fromPosixString "registry.json") registryRoot
    in
    FileSystem.readFile filesystemPermission indexPath
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString registryIndexDecoder content is
                            Ok index ->
                                GrenTask.succeed index

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )


{-| Update the registry index atomically.
-}
updateRegistryIndex :
    FileSystem.Permission
    -> Path
    -> (RegistryIndex -> RegistryIndex)
    -> GrenTask.Task Error {}
updateRegistryIndex filesystemPermission registryRoot updateFn =
    readRegistryIndex filesystemPermission registryRoot
        |> GrenTask.andThen
            (\index ->
                let
                    updatedIndex =
                        updateFn index

                    indexPath =
                        Path.append (Path.fromPosixString "registry.json") registryRoot

                    indexJson =
                        encodeRegistryIndex updatedIndex
                            |> Encode.encode 2
                in
                writeFileAtomic filesystemPermission indexPath indexJson
                    |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
            )


encodeRegistryIndex : RegistryIndex -> Encode.Value
encodeRegistryIndex index =
    Encode.object
        [ { key = "version", value = Encode.int index.version }
        , { key = "tasks", value = Encode.array encodeTaskSummary index.tasks }
        ]


encodeTaskSummary : TaskSummary -> Encode.Value
encodeTaskSummary summary =
    Encode.object
        [ { key = "id", value = Id.encodeTaskId summary.id }
        , { key = "description", value = Encode.string summary.description }
        , { key = "status", value = Types.encodeStatus summary.status }
        , { key = "createdAt", value = Encode.int (Time.posixToMillis summary.createdAt) }
        , { key = "updatedAt", value = Encode.int (Time.posixToMillis summary.updatedAt) }
        , { key = "currentAgent", value = Types.encodeMaybe Encode.string summary.currentAgent }
        ]


registryIndexDecoder : Decoder RegistryIndex
registryIndexDecoder =
    Decode.map2
        (\version tasks -> { version = version, tasks = tasks })
        (Decode.field "version" Decode.int)
        (Decode.field "tasks" (Decode.array taskSummaryDecoder))


taskSummaryDecoder : Decoder TaskSummary
taskSummaryDecoder =
    Decode.map5
        (\id description status createdAt updatedAt ->
            { id = id
            , description = description
            , status = status
            , createdAt = createdAt
            , updatedAt = updatedAt
            , currentAgent = Nothing
            }
        )
        (Decode.field "id" Id.taskIdDecoder)
        (Decode.field "description" Decode.string)
        (Decode.field "status" Types.statusDecoder)
        (Decode.field "createdAt" (Decode.map Time.millisToPosix Decode.int))
        (Decode.field "updatedAt" (Decode.map Time.millisToPosix Decode.int))
        |> Decode.andThen
            (\summary ->
                Decode.oneOf
                    [ Decode.field "currentAgent" (Decode.maybe Decode.string)
                    , Decode.succeed Nothing
                    ]
                    |> Decode.map (\currentAgent -> { summary | currentAgent = currentAgent })
            )



-- HISTORY OPERATIONS


{-| Read history from disk.
-}
readHistory : FileSystem.Permission -> Path -> GrenTask.Task Error History
readHistory filesystemPermission path =
    FileSystem.readFile filesystemPermission path
        |> GrenTask.mapError (\e -> FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.fail (JsonDecodeError "Could not decode file as UTF-8")

                    Just content ->
                        when Decode.decodeString Types.historyDecoder content is
                            Ok history ->
                                GrenTask.succeed history

                            Err err ->
                                GrenTask.fail (JsonDecodeError (Decode.errorToString err))
            )




-- CONTENT TYPE HELPERS


{-| Infer a MIME content type from a file extension.
-}
contentTypeFromExtension : String -> String
contentTypeFromExtension filename =
    let
        extension =
            filename
                |> String.split "."
                |> Array.last
                |> Maybe.withDefault ""
                |> String.toLower
    in
    when extension is
        "png" ->
            "image/png"

        "jpg" ->
            "image/jpeg"

        "jpeg" ->
            "image/jpeg"

        "gif" ->
            "image/gif"

        "pdf" ->
            "application/pdf"

        "txt" ->
            "text/plain"

        "md" ->
            "text/markdown"

        "json" ->
            "application/json"

        "csv" ->
            "text/csv"

        "html" ->
            "text/html"

        _ ->
            "application/octet-stream"



-- FILE HELPERS


{-| Write a file atomically (write to temp, then rename).
-}
writeFileAtomic : FileSystem.Permission -> Path -> String -> GrenTask.Task FileSystem.Error {}
writeFileAtomic filesystemPermission path content =
    let
        tempPath =
            Path.fromPosixString (Path.toPosixString path ++ ".tmp")

        bytes =
            Bytes.fromString content
    in
    FileSystem.writeFile filesystemPermission bytes tempPath
        |> GrenTask.andThen (\_ -> FileSystem.move filesystemPermission path tempPath)
        |> GrenTask.map (\_ -> {})
