module Web.Api exposing
    ( ApiContext
    , ApiResult(..)
    , BinaryResult(..)
    , requestTasks
    , requestTask
    , requestCreateTask
    , requestUpdateStatus
    , requestUpdatePlanning
    , requestHistory
    , requestQueue
    , requestEnqueue
    , requestUploadAttachment
    , requestDownloadAttachment
    , requestDeleteAttachment
    , requestStartAgent
    , requestStartHandoff
    , requestCompleteAgent
    , requestCompleteHandoff
    , requestAgents
    , requestAgent
    , requestCreateAgent
    , requestUpdateAgent
    , requestDeleteAgent
    , requestProviders
    , requestProvider
    , requestCreateProvider
    , requestUpdateProvider
    , requestDeleteProvider
    , requestApplyPlan
    , requestSetQuestions
    , requestSubmitAnswers
    , requestPlanTask
    , sendApiResponse
    , sendBinaryResponse
    , CreateTaskParams
    , UpdatePlanningParams
    , StartAgentParams
    , CompleteAgentParams
    , indexedArrayToDict
    )

{-| API request handlers for the Chorus web interface.

Each endpoint produces an ApiResult that should be sent back via the Response.

-}

import Agent.Registry as AgentRegistry
import Bytes exposing (Bytes)
import Provider.Registry as ProviderRegistry
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer exposing (Request)
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Json.Decode as Decode
import Json.Encode as Encode
import Task as GrenTask exposing (Task)
import Task.Queue as Queue
import Task.Registry as Registry
import Time
import Types exposing (Task(..), TaskStatus(..), EventType(..), SourceInfo, PlanningFields, PlanningQuestion, HandoffRecord, AgentConfig(..), encodeAgentConfig, setAgentChain)
import Web.Router exposing (Route(..))


-- TYPES


{-| Context needed for API operations.
-}
type alias ApiContext =
    { registry : Registry.Registry
    , filesystemPermission : FileSystem.Permission
    , secureContext : SecureContext
    , registryRoot : Path
    }


{-| Result of an API operation.
-}
type ApiResult
    = ApiSuccess { statusCode : Int, body : String }
    | ApiError { statusCode : Int, code : String, message : String }
    | DeferredHandoff { agentName : String, prompt : String }


{-| Parameters for creating a task.
-}
type alias CreateTaskParams =
    { description : String
    , source : SourceInfo
    }


{-| Parameters for updating task planning fields.
    Each field is optional; only present fields are updated.
-}
type alias UpdatePlanningParams =
    { summary : Maybe String
    , requirements : Maybe (Array String)
    , acceptanceCriteria : Maybe (Array String)
    , plan : Maybe (Array String)
    }


{-| Parameters for starting an agent on a task.
-}
type alias StartAgentParams =
    { agentName : String
    , prompt : String
    }


{-| Parameters for completing an agent run on a task.
-}
type alias CompleteAgentParams =
    { output : String
    }


{-| Result of a binary file operation (for attachment downloads).
-}
type BinaryResult
    = BinarySuccess { bytes : Bytes.Bytes, contentType : String }
    | BinaryError { statusCode : Int, code : String, message : String }



-- API HANDLERS - Return Tasks that produce ApiResult


{-| GET /api/tasks - List all tasks.
-}
requestTasks : ApiContext -> Maybe String -> (ApiResult -> msg) -> Cmd msg
requestTasks ctx maybeStatus toMsg =
    let
        statusFilter =
            maybeStatus
                |> Maybe.andThen parseStatus
    in
    Registry.listTasks ctx.registry statusFilter
        |> GrenTask.andThen
            (\tasks ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                tasksJson =
                                    Encode.array Types.encodeTask tasks

                                body =
                                    wrapResponse tasksJson now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id - Get a single task.
-}
requestTask : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestTask ctx taskId toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        body =
                                            wrapResponse (Types.encodeTask task) now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks - Create a new task.
-}
requestCreateTask : ApiContext -> CreateTaskParams -> (ApiResult -> msg) -> Cmd msg
requestCreateTask ctx params toMsg =
    Registry.createTask ctx.registry
        { description = params.description
        , source = params.source
        }
        |> GrenTask.andThen
            (\task ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Types.encodeTask task) now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/status - Update task status.
    Validates that the transition is allowed before updating.
    Accepts an optional extra event to record in the same sequential chain
    (before the status_changed event) to avoid race conditions.
-}
requestUpdateStatus : ApiContext -> TaskId -> TaskStatus -> Maybe { eventType : EventType, data : Dict String String } -> (ApiResult -> msg) -> Cmd msg
requestUpdateStatus ctx taskId status maybeExtraEvent toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        let
                            currentStatus =
                                Types.taskStatus task
                        in
                        if isValidTransition currentStatus status then
                            Registry.updateStatus ctx.registry taskId status
                                |> GrenTask.andThen
                                    (\updatedTask ->
                                        let
                                            recordExtraEvent =
                                                when maybeExtraEvent is
                                                    Just extraEvent ->
                                                        Registry.recordEvent ctx.registry taskId extraEvent
                                                            |> GrenTask.onError (\_ -> GrenTask.succeed {})

                                                    Nothing ->
                                                        GrenTask.succeed {}
                                        in
                                        recordExtraEvent
                                            |> GrenTask.andThen
                                                (\_ ->
                                                    Registry.recordEvent ctx.registry taskId
                                                        { eventType = StatusChanged
                                                        , data =
                                                            Dict.empty
                                                                |> Dict.set "from" (Types.statusToString currentStatus)
                                                                |> Dict.set "to" (Types.statusToString status)
                                                        }
                                                        |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                                )
                                            |> GrenTask.andThen
                                                (\_ ->
                                                    Time.now
                                                        |> GrenTask.map
                                                            (\now ->
                                                                ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeTask updatedTask) now }
                                                            )
                                                )
                                    )
                        else
                            GrenTask.succeed
                                (ApiError
                                    { statusCode = 409
                                    , code = "INVALID_TRANSITION"
                                    , message = "Cannot transition from " ++ Types.statusToString currentStatus ++ " to " ++ Types.statusToString status
                                    }
                                )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ Id.taskIdToString taskId }

                            _ ->
                                { statusCode = 500, message = Registry.errorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/planning - Update task planning fields.
    Converts a DescriptionOnly task to Planned when planning fields are set.
-}
requestUpdatePlanning : ApiContext -> TaskId -> UpdatePlanningParams -> (ApiResult -> msg) -> Cmd msg
requestUpdatePlanning ctx taskId params toMsg =
    Registry.updateTask ctx.registry taskId
        (\task ->
            let
                -- Get current planning fields (empty defaults for DescriptionOnly)
                currentFields =
                    when task is
                        DescriptionOnly _ ->
                            { summary = ""
                            , requirements = []
                            , acceptanceCriteria = []
                            , plan = []
                            , questions = []
                            , assignedAgent = Nothing
                            }

                        Planned t ->
                            { summary = t.summary
                            , requirements = t.requirements
                            , acceptanceCriteria = t.acceptanceCriteria
                            , plan = t.plan
                            , questions = t.questions
                            , assignedAgent = t.assignedAgent
                            }

                newFields =
                    { summary = Maybe.withDefault currentFields.summary params.summary
                    , requirements = Maybe.withDefault currentFields.requirements params.requirements
                    , acceptanceCriteria = Maybe.withDefault currentFields.acceptanceCriteria params.acceptanceCriteria
                    , plan = Maybe.withDefault currentFields.plan params.plan
                    , questions = currentFields.questions
                    , assignedAgent = currentFields.assignedAgent
                    }
            in
            Types.planTask task newFields
        )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Types.encodeTask updatedTask) now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ Id.taskIdToString taskId }

                            _ ->
                                { statusCode = 500, message = Registry.errorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| Apply a planner's plan result to a task.
    Converts the task to Planned, sets status to ReadyToStart.
    Also records the planning_completed event in the same sequential chain
    to avoid race conditions with concurrent history.json writes.
-}
requestApplyPlan : ApiContext -> TaskId -> Types.PlanningFields -> Dict String String -> (ApiResult -> msg) -> Cmd msg
requestApplyPlan ctx taskId fields planningCompletedData toMsg =
    Registry.updateTask ctx.registry taskId
        (\task ->
            Types.planTask task fields
                |> Types.setTaskStatus Types.ReadyToStart
        )
        |> GrenTask.andThen
            (\updatedTask ->
                Registry.recordEvent ctx.registry taskId
                    { eventType = PlanningCompleted
                    , data = planningCompletedData
                    }
                    |> GrenTask.onError (\_ -> GrenTask.succeed {})
                    |> GrenTask.andThen
                        (\_ ->
                            Registry.recordEvent ctx.registry taskId
                                { eventType = StatusChanged
                                , data =
                                    Dict.empty
                                        |> Dict.set "from" (Types.statusToString Types.Planning)
                                        |> Dict.set "to" (Types.statusToString Types.ReadyToStart)
                                }
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            Time.now
                                |> GrenTask.map
                                    (\now ->
                                        ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeTask updatedTask) now }
                                    )
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| Set planning questions on a task (from planner).
    Converts the task to Planned with empty plan fields, sets status to AwaitingInput.
    Also records the planning_questions_returned event in the same sequential chain
    to avoid race conditions with concurrent history.json writes.
-}
requestSetQuestions : ApiContext -> TaskId -> Array String -> Dict String String -> (ApiResult -> msg) -> Cmd msg
requestSetQuestions ctx taskId questionStrings questionsEventData toMsg =
    let
        questions =
            Array.map (\q -> { question = q, answer = Nothing }) questionStrings

        emptyFields =
            { summary = ""
            , requirements = []
            , acceptanceCriteria = []
            , plan = []
            , questions = questions
            , assignedAgent = Nothing
            }
    in
    Registry.updateTask ctx.registry taskId
        (\task ->
            Types.planTask task emptyFields
                |> Types.setTaskStatus Types.AwaitingInput
        )
        |> GrenTask.andThen
            (\updatedTask ->
                Registry.recordEvent ctx.registry taskId
                    { eventType = PlanningQuestionsReturned
                    , data = questionsEventData
                    }
                    |> GrenTask.onError (\_ -> GrenTask.succeed {})
                    |> GrenTask.andThen
                        (\_ ->
                            Registry.recordEvent ctx.registry taskId
                                { eventType = StatusChanged
                                , data =
                                    Dict.empty
                                        |> Dict.set "from" (Types.statusToString Types.Planning)
                                        |> Dict.set "to" (Types.statusToString Types.AwaitingInput)
                                }
                                |> GrenTask.onError (\_ -> GrenTask.succeed {})
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            Time.now
                                |> GrenTask.map
                                    (\now ->
                                        ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeTask updatedTask) now }
                                    )
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks/:id/plan - Trigger planning for a pending task.
    Validates the task is in Pending status, then returns the task with
    its description so the caller can dispatch the planner.
-}
requestPlanTask : ApiContext -> TaskId -> ({ apiResult : ApiResult, description : String } -> msg) -> Cmd msg
requestPlanTask ctx taskId toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed
                            { apiResult = ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId }
                            , description = ""
                            }

                    Just task ->
                        let
                            currentStatus =
                                Types.taskStatus task
                        in
                        if currentStatus == Pending then
                            Time.now
                                |> GrenTask.map
                                    (\now ->
                                        { apiResult = ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeTask task) now }
                                        , description = Types.taskDescription task
                                        }
                                    )
                        else
                            GrenTask.succeed
                                { apiResult = ApiError
                                    { statusCode = 409
                                    , code = "INVALID_STATUS"
                                    , message = "Task must be in Pending status to plan, but is " ++ Types.statusToString currentStatus
                                    }
                                , description = ""
                                }
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    { apiResult = ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err }
                    , description = ""
                    }
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks/:id/answers - Submit answers to planning questions.
    Updates the task's questions with answers, sets status to Planning,
    and returns the enriched prompt for re-dispatching the planner.
    Also records the answers_submitted event in the same sequential chain
    to avoid race conditions with concurrent history.json writes.
-}
requestSubmitAnswers : ApiContext -> TaskId -> Array String -> ({ apiResult : ApiResult, enrichedPrompt : String } -> msg) -> Cmd msg
requestSubmitAnswers ctx taskId answers toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed
                            { apiResult = ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId }
                            , enrichedPrompt = ""
                            }

                    Just task ->
                        let
                            description =
                                Types.taskDescription task

                            currentQuestions =
                                Types.taskQuestions task

                            questionStrings =
                                currentQuestions
                                    |> Array.map .question

                            updatedQuestions =
                                Array.indexedMap
                                    (\i q ->
                                        when Array.get i answers is
                                            Just a ->
                                                { q | answer = Just a }

                                            Nothing ->
                                                q
                                    )
                                    currentQuestions

                            qaSection =
                                updatedQuestions
                                    |> Array.map
                                        (\q ->
                                            "Q: " ++ q.question ++ "\nA: " ++ Maybe.withDefault "(no answer)" q.answer
                                        )
                                    |> String.join "\n\n"

                            enrichedPrompt =
                                description ++ "\n\n## Clarifying Q&A\n\n" ++ qaSection

                            currentFields =
                                when task is
                                    Planned t ->
                                        { summary = t.summary
                                        , requirements = t.requirements
                                        , acceptanceCriteria = t.acceptanceCriteria
                                        , plan = t.plan
                                        , questions = updatedQuestions
                                        , assignedAgent = t.assignedAgent
                                        }

                                    DescriptionOnly _ ->
                                        { summary = ""
                                        , requirements = []
                                        , acceptanceCriteria = []
                                        , plan = []
                                        , questions = updatedQuestions
                                        , assignedAgent = Nothing
                                        }

                            answersEventData =
                                Dict.foldl Dict.set (indexedArrayToDict "question_" questionStrings) (indexedArrayToDict "answer_" answers)
                                    |> Dict.set "answerCount" (String.fromInt (Array.length answers))
                        in
                        Registry.updateTask ctx.registry taskId
                            (\t ->
                                Types.planTask t currentFields
                                    |> Types.setTaskStatus Types.Planning
                            )
                            |> GrenTask.andThen
                                (\updatedTask ->
                                    Registry.recordEvent ctx.registry taskId
                                        { eventType = AnswersSubmitted
                                        , data = answersEventData
                                        }
                                        |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                        |> GrenTask.andThen
                                            (\_ ->
                                                Registry.recordEvent ctx.registry taskId
                                                    { eventType = StatusChanged
                                                    , data =
                                                        Dict.empty
                                                            |> Dict.set "from" (Types.statusToString Types.AwaitingInput)
                                                            |> Dict.set "to" (Types.statusToString Types.Planning)
                                                    }
                                                    |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                            )
                                        |> GrenTask.andThen
                                            (\_ ->
                                                Time.now
                                                    |> GrenTask.map
                                                        (\now ->
                                                            { apiResult = ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeTask updatedTask) now }
                                                            , enrichedPrompt = enrichedPrompt
                                                            }
                                                        )
                                            )
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    { apiResult = ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err }
                    , enrichedPrompt = ""
                    }
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/history - Get task event history.
-}
requestHistory : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestHistory ctx taskId toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        historyPath =
            Path.append
                (Path.fromPosixString (taskIdStr ++ "/history.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.filesystemPermission historyPath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode history file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        historyValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse historyValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "History not found for task: " ++ taskIdStr })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/queue - Get task message queue.
-}
requestQueue : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestQueue ctx taskId toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        queuePath =
            Path.append
                (Path.fromPosixString (taskIdStr ++ "/queue.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.filesystemPermission queuePath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode queue file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        queueValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse queueValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Queue not found for task: " ++ taskIdStr })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks/:id/queue - Add message to task queue.
-}
requestEnqueue : ApiContext -> TaskId -> String -> (ApiResult -> msg) -> Cmd msg
requestEnqueue ctx taskId content toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskDir =
            Path.append (Path.fromPosixString taskIdStr) ctx.registryRoot
    in
    Queue.enqueue ctx.filesystemPermission ctx.secureContext taskDir taskId content
        |> GrenTask.andThen
            (\message ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                msgJson =
                                    Encode.object
                                        [ { key = "id", value = Id.encodeMessageId message.id }
                                        , { key = "content", value = Encode.string message.content }
                                        , { key = "receivedAt", value = Encode.int (Time.posixToMillis message.receivedAt) }
                                        ]

                                body =
                                    wrapResponse msgJson now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "QUEUE_ERROR", message = queueErrorToString err })
            )
        |> GrenTask.perform toMsg



{-| POST /api/tasks/:id/attachments?filename=... - Upload a file attachment.
-}
requestUploadAttachment :
    ApiContext
    -> TaskId
    -> String
    -> Bytes.Bytes
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestUploadAttachment ctx taskId filename fileBytes uploadDir toMsg =
    let
        maxSize =
            10 * 1024 * 1024  -- 10MB

        fileSize =
            Bytes.length fileBytes
    in
    if fileSize > maxSize then
        GrenTask.succeed (ApiError { statusCode = 413, code = "FILE_TOO_LARGE", message = "Upload exceeds 10MB limit" })
            |> GrenTask.perform toMsg
    else
        let
            taskIdStr =
                Id.taskIdToString taskId

            contentType =
                Registry.contentTypeFromExtension filename

            taskUploadDir =
                Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

            filePath =
                Path.append (Path.fromPosixString filename) taskUploadDir
        in
        -- Create the per-task upload directory
        FileSystem.makeDirectory ctx.filesystemPermission { recursive = True } taskUploadDir
            |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
            |> GrenTask.andThen
                (\_ ->
                    -- Write the file
                    FileSystem.writeFile ctx.filesystemPermission fileBytes filePath
                        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                )
            |> GrenTask.andThen
                (\_ ->
                    -- Get current time for the attachment metadata
                    Time.now
                        |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                )
            |> GrenTask.andThen
                (\now ->
                    let
                        attachment =
                            { filename = filename
                            , size = fileSize
                            , contentType = contentType
                            , uploadedAt = now
                            }
                    in
                    -- Update the task to add the attachment metadata
                    Registry.updateTask ctx.registry taskId
                        (\task ->
                            Types.setAttachments
                                (Array.pushLast attachment (Types.taskAttachments task))
                                task
                        )
                        |> GrenTask.map
                            (\updatedTask ->
                                ApiSuccess
                                    { statusCode = 200
                                    , body =
                                        wrapResponse (Types.encodeTask updatedTask) now
                                    }
                            )
                )
            |> GrenTask.onError
                (\err ->
                    GrenTask.succeed (ApiError { statusCode = 500, code = "UPLOAD_ERROR", message = Registry.errorToString err })
                )
            |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/attachments/:filename - Download a file attachment.
-}
requestDownloadAttachment :
    ApiContext
    -> TaskId
    -> String
    -> String
    -> (BinaryResult -> msg)
    -> Cmd msg
requestDownloadAttachment ctx taskId filename uploadDir toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskUploadDir =
            Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- First get the task to find the content type
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (Registry.TaskNotFound taskId)

                    Just task ->
                        let
                            maybeAttachment =
                                Array.findFirst (\a -> a.filename == filename) (Types.taskAttachments task)
                        in
                        when maybeAttachment is
                            Nothing ->
                                GrenTask.fail (Registry.FileSystemError ("Attachment not found: " ++ filename))

                            Just { value } ->
                                FileSystem.readFile ctx.filesystemPermission filePath
                                    |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                                    |> GrenTask.map
                                        (\bytes ->
                                            BinarySuccess
                                                { bytes = bytes
                                                , contentType = value.contentType
                                                }
                                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        Registry.errorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (BinaryError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (BinaryError { statusCode = 500, code = "DOWNLOAD_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg


{-| DELETE /api/tasks/:id/attachments/:filename - Delete a file attachment.
-}
requestDeleteAttachment :
    ApiContext
    -> TaskId
    -> String
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestDeleteAttachment ctx taskId filename uploadDir toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskUploadDir =
            Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- Delete the file from disk
    FileSystem.remove ctx.filesystemPermission { recursive = False } filePath
        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\_ ->
                -- Remove the attachment entry from the task
                Registry.updateTask ctx.registry taskId
                    (\task ->
                        Types.setAttachments
                            (Array.keepIf (\a -> a.filename /= filename) (Types.taskAttachments task))
                            task
                    )
            )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess
                                { statusCode = 200
                                , body =
                                    wrapResponse (Types.encodeTask updatedTask) now
                                }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        Registry.errorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (ApiError { statusCode = 500, code = "DELETE_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg



{-| Start an agent on a task (UI-initiated, not a handoff).

Records an AgentStarted history event.
-}
requestStartAgent : ApiContext -> TaskId -> StartAgentParams -> (ApiResult -> msg) -> Cmd msg
requestStartAgent =
    startAgentOnTask False AgentStarted


{-| Start a hand-off to an agent (initiated by another agent's handoff tool).

Records an AgentHandoffStarted history event. Allows replacing the current
agent since the calling agent IS the current agent in a deferred handoff.
-}
requestStartHandoff : ApiContext -> TaskId -> StartAgentParams -> (ApiResult -> msg) -> Cmd msg
requestStartHandoff =
    startAgentOnTask True AgentHandoffStarted


{-| Shared implementation for starting an agent on a task.

Sets currentAgent, appends a HandoffRecord to agentChain, records a history event,
and transitions the task to Active if it was Pending or Waiting.
The actual agent spawning is handled by the caller (Main.gren).

When allowReplace is True (deferred handoffs), an existing currentAgent is
allowed â€” the new agent replaces it. When False, a 409 CONFLICT is returned.
-}
startAgentOnTask : Bool -> EventType -> ApiContext -> TaskId -> StartAgentParams -> (ApiResult -> msg) -> Cmd msg
startAgentOnTask allowReplace eventType ctx taskId params toMsg =
    -- First check if the task exists and currentAgent is not already set
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        let
                            existingAgent =
                                Types.taskCurrentAgent task

                            blocked =
                                existingAgent /= Nothing && not allowReplace
                        in
                        if blocked then
                            GrenTask.succeed (ApiError { statusCode = 409, code = "CONFLICT", message = "Agent already active on task: " ++ Maybe.withDefault "unknown" existingAgent })
                        else
                            Time.now
                                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                    |> GrenTask.andThen
                                        (\now ->
                                            let
                                                newRecord =
                                                    { agentName = params.agentName
                                                    , startedAt = now
                                                    , completedAt = Nothing
                                                    , input = params.prompt
                                                    , output = ""
                                                    , completionReport = Nothing
                                                    }

                                                updateFn t =
                                                    let
                                                        chain =
                                                            Types.taskAgentChain t

                                                        newChain =
                                                            Array.pushLast newRecord chain

                                                        -- Set status to Active if ReadyToStart or Waiting
                                                        newStatus =
                                                            when Types.taskStatus t is
                                                                ReadyToStart ->
                                                                    Active

                                                                Waiting ->
                                                                    Active

                                                                other ->
                                                                    other

                                                        updated =
                                                            t
                                                                |> Types.setCurrentAgent (Just params.agentName)
                                                                |> Types.setTaskStatus newStatus
                                                    in
                                                    setAgentChain newChain updated
                                            in
                                            Registry.updateTask ctx.registry taskId updateFn
                                                |> GrenTask.andThen
                                                    (\updatedTask ->
                                                        let
                                                            handoffIndex =
                                                                String.fromInt (Array.length (Types.taskAgentChain updatedTask) - 1)
                                                        in
                                                        -- Record history event
                                                        Registry.recordEvent ctx.registry taskId
                                                            { eventType = eventType
                                                            , data =
                                                                Dict.empty
                                                                    |> Dict.set "agentName" params.agentName
                                                                    |> Dict.set "handoffIndex" handoffIndex
                                                            }
                                                            |> GrenTask.map (\_ -> updatedTask)
                                                    )
                                                |> GrenTask.andThen
                                                    (\updatedTask ->
                                                        Time.now
                                                            |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                                            |> GrenTask.map
                                                                (\nowForResponse ->
                                                                    ApiSuccess
                                                                        { statusCode = 200
                                                                        , body = wrapResponse (Types.encodeTask updatedTask) nowForResponse
                                                                        }
                                                                )
                                                    )
                                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| Complete an agent run on a task (UI-initiated agent, not a handoff).

Records an AgentCompleted history event.
-}
requestCompleteAgent : ApiContext -> TaskId -> CompleteAgentParams -> (ApiResult -> msg) -> Cmd msg
requestCompleteAgent =
    completeAgentOnTask AgentCompleted


{-| Complete a hand-off (agent initiated by another agent's handoff tool).

Records an AgentHandoffCompleted history event.
-}
requestCompleteHandoff : ApiContext -> TaskId -> CompleteAgentParams -> (ApiResult -> msg) -> Cmd msg
requestCompleteHandoff =
    completeAgentOnTask AgentHandoffCompleted


{-| Shared implementation for completing an agent on a task.

Sets completedAt on the current agent's chain entry, stores the output,
restores the parent agent as currentAgent (or clears it if no parent),
sets status to Waiting if no completion report, and records a history event.
-}
completeAgentOnTask : EventType -> ApiContext -> TaskId -> CompleteAgentParams -> (ApiResult -> msg) -> Cmd msg
completeAgentOnTask eventType ctx taskId params toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        Time.now
                            |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                            |> GrenTask.andThen
                                (\now ->
                                    let
                                        chain =
                                            Types.taskAgentChain task

                                        agentName =
                                            Types.taskCurrentAgent task
                                                |> Maybe.withDefault "unknown"

                                        -- Update the entry matching the current agent
                                        updatedChain =
                                            Types.updateCurrentAgentEntry agentName
                                                (\entry ->
                                                    { entry
                                                        | completedAt = Just now
                                                        , output = params.output
                                                    }
                                                )
                                                chain

                                        -- Check the current agent's entry for a completion report
                                        hasCompletionReport =
                                            chain
                                                |> Array.keepIf (\entry -> entry.agentName == agentName && entry.completedAt == Nothing)
                                                |> Array.popLast
                                                |> Maybe.map (\{ last } -> last.completionReport /= Nothing)
                                                |> Maybe.withDefault False

                                        -- Restore parent agent if one exists (last uncompleted entry after update)
                                        parentAgent =
                                            Types.findParentAgent updatedChain

                                        updateFn t =
                                            let
                                                updated =
                                                    t
                                                        |> Types.setCurrentAgent parentAgent
                                                        |> setAgentChain updatedChain
                                            in
                                            if hasCompletionReport then
                                                updated
                                            else
                                                updated
                                                    |> Types.setTaskStatus Waiting
                                    in
                                    Registry.updateTask ctx.registry taskId updateFn
                                        |> GrenTask.andThen
                                            (\updatedTask ->
                                                let
                                                    handoffIndex =
                                                        String.fromInt (Array.length (Types.taskAgentChain updatedTask) - 1)
                                                in
                                                -- Record history event
                                                Registry.recordEvent ctx.registry taskId
                                                    { eventType = eventType
                                                    , data =
                                                        Dict.empty
                                                            |> Dict.set "agentName" agentName
                                                            |> Dict.set "outputLength" (String.fromInt (String.unitLength params.output))
                                                            |> Dict.set "handoffIndex" handoffIndex
                                                    }
                                                    |> GrenTask.map (\_ -> updatedTask)
                                            )
                                        |> GrenTask.andThen
                                            (\updatedTask ->
                                                Time.now
                                                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                                    |> GrenTask.map
                                                        (\nowForResponse ->
                                                            ApiSuccess
                                                                { statusCode = 200
                                                                , body = wrapResponse (Types.encodeTask updatedTask) nowForResponse
                                                                }
                                                        )
                                            )
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/agents - List all agent configs.

Includes a computed `isValid` field for each user-defined agent.
An agent is valid if its provider is a ProviderRef and that provider exists.
-}
requestAgents : AgentRegistry.AgentRegistry -> ProviderRegistry.ProviderRegistry -> (ApiResult -> msg) -> Cmd msg
requestAgents agentRegistry providerRegistry toMsg =
    AgentRegistry.listAgents agentRegistry
        |> GrenTask.mapError (\err -> AgentRegistryError err)
        |> GrenTask.andThen
            (\agents ->
                ProviderRegistry.listProviders providerRegistry
                    |> GrenTask.mapError (\err -> ProviderRegistryError err)
                    |> GrenTask.map (\providers -> { agents = agents, providers = providers })
            )
        |> GrenTask.andThen
            (\{ agents, providers } ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistryError (AgentRegistry.FileSystemError "Failed to get time"))
                    |> GrenTask.map
                        (\now ->
                            let
                                providerNames =
                                    Array.map .name providers

                                agentsJson =
                                    Encode.array
                                        (\agent ->
                                            let
                                                base =
                                                    encodeAgentConfig agent

                                                isValid =
                                                    when agent is
                                                        UserDefinedAgent r ->
                                                            when r.provider is
                                                                Types.ProviderRef name ->
                                                                    Array.any (\p -> p == name) providerNames

                                                                Types.NotConfigured ->
                                                                    False

                                                        InternalAgent _ ->
                                                            True
                                            in
                                            addJsonField "isValid" (Encode.bool isValid) base
                                        )
                                        agents
                            in
                            ApiSuccess { statusCode = 200, body = wrapResponse agentsJson now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    message =
                        when err is
                            AgentRegistryError e ->
                                AgentRegistry.errorToString e

                            ProviderRegistryError e ->
                                ProviderRegistry.errorToString e
                in
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| GET /api/agents/:name - Get a single agent config.
-}
requestAgent : AgentRegistry.AgentRegistry -> String -> (ApiResult -> msg) -> Cmd msg
requestAgent agentRegistry name toMsg =
    AgentRegistry.getAgent agentRegistry name
        |> GrenTask.andThen
            (\agentConfig ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (encodeAgentConfig agentConfig) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    AgentRegistry.AgentNotFound _ ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = AgentRegistry.errorToString err })

                    _ ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/agents - Create a new agent config.

Fails with 409 Conflict if an agent with the same name already exists.
-}
requestCreateAgent : AgentRegistry.AgentRegistry -> AgentConfig -> (ApiResult -> msg) -> Cmd msg
requestCreateAgent agentRegistry agentConfig toMsg =
    let
        name =
            Types.agentConfigName agentConfig
    in
    -- First check if an agent with this name already exists
    AgentRegistry.getAgent agentRegistry name
        |> GrenTask.andThen
            (\_ ->
                -- Agent exists - return conflict
                GrenTask.succeed (ApiError { statusCode = 409, code = "CONFLICT", message = "Agent already exists: " ++ name })
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    AgentRegistry.AgentNotFound _ ->
                        -- Agent does not exist - proceed with creation
                        AgentRegistry.updateAgent agentRegistry agentConfig
                            |> GrenTask.andThen
                                (\created ->
                                    Time.now
                                        |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                                        |> GrenTask.map
                                            (\now ->
                                                ApiSuccess { statusCode = 201, body = wrapResponse (encodeAgentConfig created) now }
                                            )
                                )
                            |> GrenTask.onError
                                (\createErr ->
                                    GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString createErr })
                                )

                    _ ->
                        -- Some other error (filesystem, etc.) - report it
                        GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/agents/:name - Update an existing agent config.
-}
requestUpdateAgent : AgentRegistry.AgentRegistry -> String -> AgentConfig -> (ApiResult -> msg) -> Cmd msg
requestUpdateAgent agentRegistry name agentConfig toMsg =
    let
        configWithName =
            when agentConfig is
                InternalAgent r ->
                    InternalAgent { r | name = name }

                UserDefinedAgent r ->
                    UserDefinedAgent { r | name = name }
    in
    AgentRegistry.updateAgent agentRegistry configWithName
        |> GrenTask.andThen
            (\updated ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (encodeAgentConfig updated) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| DELETE /api/agents/:name - Delete an agent config.
-}
requestDeleteAgent : AgentRegistry.AgentRegistry -> String -> (ApiResult -> msg) -> Cmd msg
requestDeleteAgent agentRegistry name toMsg =
    AgentRegistry.deleteAgent agentRegistry name
        |> GrenTask.andThen
            (\_ ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (Encode.object [ { key = "deleted", value = Encode.string name } ]) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    AgentRegistry.AgentNotFound _ ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = AgentRegistry.errorToString err })

                    _ ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


-- PROVIDER CRUD


{-| GET /api/providers - List all provider configs.
-}
requestProviders : ProviderRegistry.ProviderRegistry -> (ApiResult -> msg) -> Cmd msg
requestProviders providerRegistry toMsg =
    ProviderRegistry.listProviders providerRegistry
        |> GrenTask.andThen
            (\providers ->
                Time.now
                    |> GrenTask.mapError (\_ -> ProviderRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            let
                                providersJson =
                                    Encode.array Types.encodeProviderConfig providers
                            in
                            ApiSuccess { statusCode = 200, body = wrapResponse providersJson now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "PROVIDER_REGISTRY_ERROR", message = ProviderRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/providers/:name - Get a single provider config.
-}
requestProvider : ProviderRegistry.ProviderRegistry -> String -> (ApiResult -> msg) -> Cmd msg
requestProvider providerRegistry name toMsg =
    ProviderRegistry.getProvider providerRegistry name
        |> GrenTask.andThen
            (\providerConfig ->
                Time.now
                    |> GrenTask.mapError (\_ -> ProviderRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeProviderConfig providerConfig) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    ProviderRegistry.ProviderNotFound _ ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = ProviderRegistry.errorToString err })

                    _ ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "PROVIDER_REGISTRY_ERROR", message = ProviderRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/providers - Create a new provider config.

Fails with 409 Conflict if a provider with the same name already exists.
-}
requestCreateProvider : ProviderRegistry.ProviderRegistry -> Types.ProviderConfig -> (ApiResult -> msg) -> Cmd msg
requestCreateProvider providerRegistry providerConfig toMsg =
    let
        name =
            providerConfig.name
    in
    ProviderRegistry.getProvider providerRegistry name
        |> GrenTask.andThen
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 409, code = "CONFLICT", message = "Provider already exists: " ++ name })
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    ProviderRegistry.ProviderNotFound _ ->
                        ProviderRegistry.updateProvider providerRegistry providerConfig
                            |> GrenTask.andThen
                                (\created ->
                                    Time.now
                                        |> GrenTask.mapError (\_ -> ProviderRegistry.FileSystemError "Failed to get time")
                                        |> GrenTask.map
                                            (\now ->
                                                ApiSuccess { statusCode = 201, body = wrapResponse (Types.encodeProviderConfig created) now }
                                            )
                                )
                            |> GrenTask.onError
                                (\createErr ->
                                    GrenTask.succeed (ApiError { statusCode = 500, code = "PROVIDER_REGISTRY_ERROR", message = ProviderRegistry.errorToString createErr })
                                )

                    _ ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "PROVIDER_REGISTRY_ERROR", message = ProviderRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/providers/:name - Update an existing provider config.
-}
requestUpdateProvider : ProviderRegistry.ProviderRegistry -> String -> Types.ProviderConfig -> (ApiResult -> msg) -> Cmd msg
requestUpdateProvider providerRegistry name providerConfig toMsg =
    let
        configWithName =
            { providerConfig | name = name }
    in
    ProviderRegistry.updateProvider providerRegistry configWithName
        |> GrenTask.andThen
            (\updated ->
                Time.now
                    |> GrenTask.mapError (\_ -> ProviderRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (Types.encodeProviderConfig updated) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "PROVIDER_REGISTRY_ERROR", message = ProviderRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| DELETE /api/providers/:name - Delete a provider config.

Before deleting, scans all agents to find those referencing this provider.
Sets each affected agent's provider to NotConfigured, then deletes the provider.
Returns the list of affected agent names in the response.
-}
requestDeleteProvider : ProviderRegistry.ProviderRegistry -> AgentRegistry.AgentRegistry -> String -> (ApiResult -> msg) -> Cmd msg
requestDeleteProvider providerRegistry agentRegistry name toMsg =
    AgentRegistry.listAgents agentRegistry
        |> GrenTask.mapError (\err -> AgentRegistryError err)
        |> GrenTask.andThen
            (\agents ->
                let
                    affectedAgents =
                        agents
                            |> Array.keepIf
                                (\agent ->
                                    when agent is
                                        UserDefinedAgent r ->
                                            r.provider == Types.ProviderRef name

                                        InternalAgent _ ->
                                            False
                                )
                            |> Array.map Types.agentConfigName

                    updateAffectedAgents =
                        agents
                            |> Array.keepIf
                                (\agent ->
                                    when agent is
                                        UserDefinedAgent r ->
                                            r.provider == Types.ProviderRef name

                                        InternalAgent _ ->
                                            False
                                )
                            |> Array.foldl
                                (\agent acc ->
                                    acc
                                        |> GrenTask.andThen
                                            (\_ ->
                                                let
                                                    updatedAgent =
                                                        when agent is
                                                            UserDefinedAgent r ->
                                                                UserDefinedAgent { r | provider = Types.NotConfigured }

                                                            InternalAgent _ ->
                                                                agent
                                                in
                                                AgentRegistry.updateAgent agentRegistry updatedAgent
                                                    |> GrenTask.mapError AgentRegistryError
                                                    |> GrenTask.map (\_ -> {})
                                            )
                                )
                                (GrenTask.succeed {})
                in
                updateAffectedAgents
                    |> GrenTask.andThen
                        (\_ ->
                            ProviderRegistry.deleteProvider providerRegistry name
                                |> GrenTask.mapError ProviderRegistryError
                        )
                    |> GrenTask.andThen
                        (\_ ->
                            Time.now
                                |> GrenTask.mapError (\_ -> AgentRegistryError (AgentRegistry.FileSystemError "Failed to get time"))
                                |> GrenTask.map
                                    (\now ->
                                        let
                                            responseBody =
                                                Encode.object
                                                    [ { key = "deleted", value = Encode.string name }
                                                    , { key = "affectedAgents", value = Encode.array Encode.string affectedAgents }
                                                    ]
                                        in
                                        ApiSuccess { statusCode = 200, body = wrapResponse responseBody now }
                                    )
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            ProviderRegistryError (ProviderRegistry.ProviderNotFound _) ->
                                { statusCode = 404, message = "Provider not found: " ++ name }

                            ProviderRegistryError e ->
                                { statusCode = 500, message = ProviderRegistry.errorToString e }

                            AgentRegistryError e ->
                                { statusCode = 500, message = AgentRegistry.errorToString e }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg



-- RESPONSE SENDING


{-| Send an API response.
-}
sendApiResponse : Response -> ApiResult -> Cmd msg
sendApiResponse response result =
    when result is
        ApiSuccess { statusCode, body } ->
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody body
                |> Response.send

        ApiError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send

        DeferredHandoff _ ->
            -- DeferredHandoff should never reach sendApiResponse.
            -- It is handled by Main.gren before reaching this point.
            response
                |> Response.setStatus 500
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody "{\"error\":{\"code\":\"INTERNAL_ERROR\",\"message\":\"Unexpected deferred handoff in sendApiResponse\"}}"
                |> Response.send



{-| Send a binary response (for file downloads).
-}
sendBinaryResponse : Response -> BinaryResult -> Cmd msg
sendBinaryResponse response result =
    when result is
        BinarySuccess { bytes, contentType } ->
            response
                |> Response.setStatus 200
                |> Response.setHeader "Content-Type" contentType
                |> Response.setBodyAsBytes bytes
                |> Response.send

        BinaryError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send



{-| Internal error type for combined registry operations.
-}
type CombinedRegistryError
    = AgentRegistryError AgentRegistry.Error
    | ProviderRegistryError ProviderRegistry.Error


{-| Add a field to an existing JSON object Value.

Works by decoding the object into key-value pairs, adding the new field,
and re-encoding.
-}
addJsonField : String -> Encode.Value -> Encode.Value -> Encode.Value
addJsonField key value jsonObject =
    when Decode.decodeValue (Decode.keyValuePairs Decode.value) jsonObject is
        Ok pairs ->
            Encode.object (Array.pushLast { key = key, value = value } pairs)

        Err _ ->
            jsonObject



-- HELPERS


{-| Parse a status string to TaskStatus.
-}
parseStatus : String -> Maybe TaskStatus
parseStatus statusStr =
    Types.statusFromString statusStr


{-| Wrap data in standard response format.
-}
wrapResponse : Encode.Value -> Time.Posix -> String
wrapResponse data timestamp =
    Encode.object
        [ { key = "data", value = data }
        , { key = "meta"
          , value =
                Encode.object
                    [ { key = "timestamp", value = Encode.int (Time.posixToMillis timestamp) }
                    ]
          }
        ]
        |> Encode.encode 0



{-| Check if a status transition is valid.
-}
isValidTransition : TaskStatus -> TaskStatus -> Bool
isValidTransition from to =
    when { from = from, to = to } is
        -- From Pending
        { from = Pending, to = Planning } ->
            True

        { from = Pending, to = Failed _ } ->
            True

        -- From Planning
        { from = Planning, to = AwaitingInput } ->
            True

        { from = Planning, to = ReadyToStart } ->
            True

        { from = Planning, to = Failed _ } ->
            True

        -- From AwaitingInput
        { from = AwaitingInput, to = Planning } ->
            True

        { from = AwaitingInput, to = Failed _ } ->
            True

        -- From ReadyToStart (Planned)
        { from = ReadyToStart, to = Active } ->
            True

        { from = ReadyToStart, to = Failed _ } ->
            True

        -- From Active
        { from = Active, to = Waiting } ->
            True

        { from = Active, to = Completed } ->
            True

        { from = Active, to = Failed _ } ->
            True

        -- From Waiting
        { from = Waiting, to = Active } ->
            True

        { from = Waiting, to = Completed } ->
            True

        { from = Waiting, to = Failed _ } ->
            True

        -- From Failed (allow retry)
        { from = Failed _, to = Pending } ->
            True

        -- All other transitions are invalid
        _ ->
            False


{-| Convert queue error to string.
-}
queueErrorToString : Queue.Error -> String
queueErrorToString err =
    when err is
        Queue.FileSystemError msg ->
            "File system error: " ++ msg

        Queue.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Queue.TaskNotFound taskId ->
            "Task not found: " ++ Id.taskIdToString taskId


{-| Convert an Array of strings into a Dict with numbered keys.
    `indexedArrayToDict "requirement_" ["A", "B"]` produces
    `Dict.fromArray [{ key = "requirement_1", value = "A" }, { key = "requirement_2", value = "B" }]`
-}
indexedArrayToDict : String -> Array String -> Dict String String
indexedArrayToDict prefix items =
    items
        |> Array.indexedMap
            (\i v ->
                { key = prefix ++ String.fromInt (i + 1)
                , value = v
                }
            )
        |> Array.foldl (\entry d -> Dict.set entry.key entry.value d) Dict.empty
