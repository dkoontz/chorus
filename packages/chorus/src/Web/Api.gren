module Web.Api exposing
    ( ApiResult(..)
    , BinaryResult(..)
    , requestTasks
    , requestTask
    , requestCreateTask
    , requestUpdateStatus
    , requestUpdatePlanning
    , requestHistory
    , requestQueue
    , requestEnqueue
    , requestUploadAttachment
    , requestDownloadAttachment
    , requestDeleteAttachment
    , requestStartHandoff
    , requestCompleteHandoff
    , requestAgents
    , requestAgent
    , sendApiResponse
    , sendBinaryResponse
    , CreateTaskParams
    , UpdatePlanningParams
    , StartHandoffParams
    , CompleteHandoffParams
    )

{-| API request handlers for the Chorus web interface.

Each endpoint produces an ApiResult that should be sent back via the Response.

-}

import Agent.Registry as AgentRegistry exposing (encodeAgentConfig)
import Bytes exposing (Bytes)
import Crypto exposing (SecureContext)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer exposing (Request)
import HttpServer.Response as Response exposing (Response)
import Id exposing (TaskId)
import Json.Decode as Decode
import Json.Encode as Encode
import Task as GrenTask exposing (Task)
import Task.Queue as Queue
import Task.Registry as Registry
import Time
import Types exposing (Task(..), TaskStatus(..), SourceInfo, PlanningFields, HandoffRecord, setAgentChain)
import Web.Router exposing (Route(..))


-- TYPES


{-| Context needed for API operations.
-}
type alias ApiContext =
    { registry : Registry.Registry
    , fsPermission : FileSystem.Permission
    , secureContext : SecureContext
    , registryRoot : Path
    }


{-| Result of an API operation.
-}
type ApiResult
    = ApiSuccess { statusCode : Int, body : String }
    | ApiError { statusCode : Int, code : String, message : String }


{-| Parameters for creating a task.
-}
type alias CreateTaskParams =
    { description : String
    , source : SourceInfo
    }


{-| Parameters for updating task planning fields.
    Each field is optional; only present fields are updated.
-}
type alias UpdatePlanningParams =
    { summary : Maybe String
    , requirements : Maybe (Array String)
    , acceptanceCriteria : Maybe (Array String)
    , plan : Maybe (Array String)
    }


{-| Parameters for starting a hand-off.
-}
type alias StartHandoffParams =
    { agentName : String
    , prompt : String
    }


{-| Parameters for completing a hand-off.
-}
type alias CompleteHandoffParams =
    { output : String
    }


{-| Result of a binary file operation (for attachment downloads).
-}
type BinaryResult
    = BinarySuccess { bytes : Bytes.Bytes, contentType : String }
    | BinaryError { statusCode : Int, code : String, message : String }



-- API HANDLERS - Return Tasks that produce ApiResult


{-| GET /api/tasks - List all tasks.
-}
requestTasks : ApiContext -> Maybe String -> (ApiResult -> msg) -> Cmd msg
requestTasks ctx maybeStatus toMsg =
    let
        statusFilter =
            maybeStatus
                |> Maybe.andThen parseStatus
    in
    Registry.listTasks ctx.registry statusFilter
        |> GrenTask.andThen
            (\tasks ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                tasksJson =
                                    Encode.array Types.encodeTask tasks

                                body =
                                    wrapResponse tasksJson now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id - Get a single task.
-}
requestTask : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestTask ctx taskId toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        body =
                                            wrapResponse (Types.encodeTask task) now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks - Create a new task.
-}
requestCreateTask : ApiContext -> CreateTaskParams -> (ApiResult -> msg) -> Cmd msg
requestCreateTask ctx params toMsg =
    Registry.createTask ctx.registry
        { description = params.description
        , source = params.source
        }
        |> GrenTask.andThen
            (\task ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Types.encodeTask task) now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/status - Update task status.
-}
requestUpdateStatus : ApiContext -> TaskId -> TaskStatus -> (ApiResult -> msg) -> Cmd msg
requestUpdateStatus ctx taskId status toMsg =
    Registry.updateStatus ctx.registry taskId status
        |> GrenTask.andThen
            (\task ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Types.encodeTask task) now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ Id.taskIdToString taskId }

                            _ ->
                                { statusCode = 500, message = Registry.errorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/planning - Update task planning fields.
    Converts a DescriptionOnly task to Planned when planning fields are set.
-}
requestUpdatePlanning : ApiContext -> TaskId -> UpdatePlanningParams -> (ApiResult -> msg) -> Cmd msg
requestUpdatePlanning ctx taskId params toMsg =
    Registry.updateTask ctx.registry taskId
        (\task ->
            let
                -- Get current planning fields (empty defaults for DescriptionOnly)
                currentFields =
                    when task is
                        DescriptionOnly _ ->
                            { summary = ""
                            , requirements = []
                            , acceptanceCriteria = []
                            , plan = []
                            }

                        Planned t ->
                            { summary = t.summary
                            , requirements = t.requirements
                            , acceptanceCriteria = t.acceptanceCriteria
                            , plan = t.plan
                            }

                newFields =
                    { summary = Maybe.withDefault currentFields.summary params.summary
                    , requirements = Maybe.withDefault currentFields.requirements params.requirements
                    , acceptanceCriteria = Maybe.withDefault currentFields.acceptanceCriteria params.acceptanceCriteria
                    , plan = Maybe.withDefault currentFields.plan params.plan
                    }
            in
            Types.planTask task newFields
        )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                body =
                                    wrapResponse (Types.encodeTask updatedTask) now
                            in
                            ApiSuccess { statusCode = 200, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    { statusCode, message } =
                        when err is
                            Registry.TaskNotFound _ ->
                                { statusCode = 404, message = "Task not found: " ++ Id.taskIdToString taskId }

                            _ ->
                                { statusCode = 500, message = Registry.errorToString err }
                in
                GrenTask.succeed (ApiError { statusCode = statusCode, code = "REGISTRY_ERROR", message = message })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/history - Get task event history.
-}
requestHistory : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestHistory ctx taskId toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        historyPath =
            Path.append
                (Path.fromPosixString (taskIdStr ++ "/history.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.fsPermission historyPath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode history file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        historyValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse historyValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "History not found for task: " ++ taskIdStr })
            )
        |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/queue - Get task message queue.
-}
requestQueue : ApiContext -> TaskId -> (ApiResult -> msg) -> Cmd msg
requestQueue ctx taskId toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        queuePath =
            Path.append
                (Path.fromPosixString (taskIdStr ++ "/queue.json"))
                ctx.registryRoot
    in
    FileSystem.readFile ctx.fsPermission queuePath
        |> GrenTask.andThen
            (\bytes ->
                when Bytes.toString bytes is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "DECODE_ERROR", message = "Could not decode queue file" })

                    Just content ->
                        Time.now
                            |> GrenTask.map
                                (\now ->
                                    let
                                        queueValue =
                                            when Decode.decodeString Decode.value content is
                                                Ok val ->
                                                    val

                                                Err _ ->
                                                    Encode.null

                                        body =
                                            wrapResponse queueValue now
                                    in
                                    ApiSuccess { statusCode = 200, body = body }
                                )
            )
        |> GrenTask.onError
            (\_ ->
                GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Queue not found for task: " ++ taskIdStr })
            )
        |> GrenTask.perform toMsg


{-| POST /api/tasks/:id/queue - Add message to task queue.
-}
requestEnqueue : ApiContext -> TaskId -> String -> (ApiResult -> msg) -> Cmd msg
requestEnqueue ctx taskId content toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskDir =
            Path.append (Path.fromPosixString taskIdStr) ctx.registryRoot
    in
    Queue.enqueue ctx.fsPermission ctx.secureContext taskDir taskId content
        |> GrenTask.andThen
            (\message ->
                Time.now
                    |> GrenTask.map
                        (\now ->
                            let
                                msgJson =
                                    Encode.object
                                        [ { key = "id", value = Id.encodeMessageId message.id }
                                        , { key = "content", value = Encode.string message.content }
                                        , { key = "receivedAt", value = Encode.int (Time.posixToMillis message.receivedAt) }
                                        ]

                                body =
                                    wrapResponse msgJson now
                            in
                            ApiSuccess { statusCode = 201, body = body }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "QUEUE_ERROR", message = queueErrorToString err })
            )
        |> GrenTask.perform toMsg



{-| POST /api/tasks/:id/attachments?filename=... - Upload a file attachment.
-}
requestUploadAttachment :
    ApiContext
    -> TaskId
    -> String
    -> Bytes.Bytes
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestUploadAttachment ctx taskId filename fileBytes uploadDir toMsg =
    let
        maxSize =
            10 * 1024 * 1024  -- 10MB

        fileSize =
            Bytes.length fileBytes
    in
    if fileSize > maxSize then
        GrenTask.succeed (ApiError { statusCode = 413, code = "FILE_TOO_LARGE", message = "Upload exceeds 10MB limit" })
            |> GrenTask.perform toMsg
    else
        let
            taskIdStr =
                Id.taskIdToString taskId

            contentType =
                Registry.contentTypeFromExtension filename

            taskUploadDir =
                Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

            filePath =
                Path.append (Path.fromPosixString filename) taskUploadDir
        in
        -- Create the per-task upload directory
        FileSystem.makeDirectory ctx.fsPermission { recursive = True } taskUploadDir
            |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
            |> GrenTask.andThen
                (\_ ->
                    -- Write the file
                    FileSystem.writeFile ctx.fsPermission fileBytes filePath
                        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                )
            |> GrenTask.andThen
                (\_ ->
                    -- Get current time for the attachment metadata
                    Time.now
                        |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                )
            |> GrenTask.andThen
                (\now ->
                    let
                        attachment =
                            { filename = filename
                            , size = fileSize
                            , contentType = contentType
                            , uploadedAt = now
                            }
                    in
                    -- Update the task to add the attachment metadata
                    Registry.updateTask ctx.registry taskId
                        (\task ->
                            Types.setAttachments
                                (Array.pushLast attachment (Types.taskAttachments task))
                                task
                        )
                        |> GrenTask.map
                            (\updatedTask ->
                                ApiSuccess
                                    { statusCode = 200
                                    , body =
                                        wrapResponse (Types.encodeTask updatedTask) now
                                    }
                            )
                )
            |> GrenTask.onError
                (\err ->
                    GrenTask.succeed (ApiError { statusCode = 500, code = "UPLOAD_ERROR", message = Registry.errorToString err })
                )
            |> GrenTask.perform toMsg


{-| GET /api/tasks/:id/attachments/:filename - Download a file attachment.
-}
requestDownloadAttachment :
    ApiContext
    -> TaskId
    -> String
    -> String
    -> (BinaryResult -> msg)
    -> Cmd msg
requestDownloadAttachment ctx taskId filename uploadDir toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskUploadDir =
            Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- First get the task to find the content type
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.fail (Registry.TaskNotFound taskId)

                    Just task ->
                        let
                            maybeAttachment =
                                Array.findFirst (\a -> a.filename == filename) (Types.taskAttachments task)
                        in
                        when maybeAttachment is
                            Nothing ->
                                GrenTask.fail (Registry.FileSystemError ("Attachment not found: " ++ filename))

                            Just { value } ->
                                FileSystem.readFile ctx.fsPermission filePath
                                    |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
                                    |> GrenTask.map
                                        (\bytes ->
                                            BinarySuccess
                                                { bytes = bytes
                                                , contentType = value.contentType
                                                }
                                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        Registry.errorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (BinaryError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (BinaryError { statusCode = 500, code = "DOWNLOAD_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg


{-| DELETE /api/tasks/:id/attachments/:filename - Delete a file attachment.
-}
requestDeleteAttachment :
    ApiContext
    -> TaskId
    -> String
    -> String
    -> (ApiResult -> msg)
    -> Cmd msg
requestDeleteAttachment ctx taskId filename uploadDir toMsg =
    let
        taskIdStr =
            Id.taskIdToString taskId

        taskUploadDir =
            Path.append (Path.fromPosixString taskIdStr) (Path.fromPosixString uploadDir)

        filePath =
            Path.append (Path.fromPosixString filename) taskUploadDir
    in
    -- Delete the file from disk
    FileSystem.remove ctx.fsPermission { recursive = False } filePath
        |> GrenTask.mapError (\e -> Registry.FileSystemError (FileSystem.errorToString e))
        |> GrenTask.andThen
            (\_ ->
                -- Remove the attachment entry from the task
                Registry.updateTask ctx.registry taskId
                    (\task ->
                        Types.setAttachments
                            (Array.keepIf (\a -> a.filename /= filename) (Types.taskAttachments task))
                            task
                    )
            )
        |> GrenTask.andThen
            (\updatedTask ->
                Time.now
                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess
                                { statusCode = 200
                                , body =
                                    wrapResponse (Types.encodeTask updatedTask) now
                                }
                        )
            )
        |> GrenTask.onError
            (\err ->
                let
                    errMsg =
                        Registry.errorToString err
                in
                if String.contains "ENOENT" errMsg || String.contains "no such file" errMsg then
                    GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Attachment not found: " ++ filename })
                else
                    GrenTask.succeed (ApiError { statusCode = 500, code = "DELETE_ERROR", message = errMsg })
            )
        |> GrenTask.perform toMsg



{-| POST /api/tasks/:id/handoff - Start a hand-off to an agent.

Sets currentAgent, appends a HandoffRecord to agentChain, records a history event,
and transitions the task to Active if it was Pending or Waiting.
The actual agent spawning is handled by the caller (Main.gren).
-}
requestStartHandoff : ApiContext -> TaskId -> StartHandoffParams -> (ApiResult -> msg) -> Cmd msg
requestStartHandoff ctx taskId params toMsg =
    -- First check if the task exists and currentAgent is not already set
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        when Types.taskCurrentAgent task is
                            Just existingAgent ->
                                GrenTask.succeed (ApiError { statusCode = 409, code = "CONFLICT", message = "Agent already active on task: " ++ existingAgent })

                            Nothing ->
                                Time.now
                                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                    |> GrenTask.andThen
                                        (\now ->
                                            let
                                                newRecord =
                                                    { agentName = params.agentName
                                                    , startedAt = now
                                                    , completedAt = Nothing
                                                    , output = ""
                                                    }

                                                updateFn t =
                                                    let
                                                        chain =
                                                            Types.taskAgentChain t

                                                        newChain =
                                                            Array.pushLast newRecord chain

                                                        -- Set status to Active if Pending or Waiting
                                                        newStatus =
                                                            when Types.taskStatus t is
                                                                Pending ->
                                                                    Active

                                                                Waiting ->
                                                                    Active

                                                                other ->
                                                                    other

                                                        updated =
                                                            t
                                                                |> Types.setCurrentAgent (Just params.agentName)
                                                                |> Types.setTaskStatus newStatus
                                                    in
                                                    setAgentChain newChain updated
                                            in
                                            Registry.updateTask ctx.registry taskId updateFn
                                                |> GrenTask.andThen
                                                    (\updatedTask ->
                                                        -- Record history event
                                                        Registry.recordEvent ctx.registry taskId
                                                            { eventType = "agent_handoff_started"
                                                            , data = Dict.singleton "agentName" params.agentName
                                                            }
                                                            |> GrenTask.map (\_ -> updatedTask)
                                                    )
                                                |> GrenTask.andThen
                                                    (\updatedTask ->
                                                        Time.now
                                                            |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                                            |> GrenTask.map
                                                                (\nowForResponse ->
                                                                    ApiSuccess
                                                                        { statusCode = 200
                                                                        , body = wrapResponse (Types.encodeTask updatedTask) nowForResponse
                                                                        }
                                                                )
                                                    )
                                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| PUT /api/tasks/:id/handoff/complete - Complete a hand-off.

Sets completedAt on the last agentChain entry, stores the output,
clears currentAgent, sets status to Waiting, and records a history event.
-}
requestCompleteHandoff : ApiContext -> TaskId -> CompleteHandoffParams -> (ApiResult -> msg) -> Cmd msg
requestCompleteHandoff ctx taskId params toMsg =
    Registry.getTask ctx.registry taskId
        |> GrenTask.andThen
            (\maybeTask ->
                when maybeTask is
                    Nothing ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = "Task not found: " ++ Id.taskIdToString taskId })

                    Just task ->
                        Time.now
                            |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                            |> GrenTask.andThen
                                (\now ->
                                    let
                                        chain =
                                            Types.taskAgentChain task

                                        agentName =
                                            Types.taskCurrentAgent task
                                                |> Maybe.withDefault "unknown"

                                        -- Update the last entry in agentChain
                                        updatedChain =
                                            when Array.popLast chain is
                                                Nothing ->
                                                    chain

                                                Just { last, initial } ->
                                                    Array.pushLast
                                                        { last
                                                            | completedAt = Just now
                                                            , output = params.output
                                                        }
                                                        initial

                                        updateFn t =
                                            t
                                                |> Types.setCurrentAgent Nothing
                                                |> Types.setTaskStatus Waiting
                                                |> setAgentChain updatedChain
                                    in
                                    Registry.updateTask ctx.registry taskId updateFn
                                        |> GrenTask.andThen
                                            (\updatedTask ->
                                                -- Record history event
                                                Registry.recordEvent ctx.registry taskId
                                                    { eventType = "agent_handoff_completed"
                                                    , data =
                                                        Dict.empty
                                                            |> Dict.set "agentName" agentName
                                                            |> Dict.set "outputLength" (String.fromInt (String.unitLength params.output))
                                                    }
                                                    |> GrenTask.map (\_ -> updatedTask)
                                            )
                                        |> GrenTask.andThen
                                            (\updatedTask ->
                                                Time.now
                                                    |> GrenTask.mapError (\_ -> Registry.FileSystemError "Failed to get time")
                                                    |> GrenTask.map
                                                        (\nowForResponse ->
                                                            ApiSuccess
                                                                { statusCode = 200
                                                                , body = wrapResponse (Types.encodeTask updatedTask) nowForResponse
                                                                }
                                                        )
                                            )
                                )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "REGISTRY_ERROR", message = Registry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/agents - List all agent configs.
-}
requestAgents : AgentRegistry.AgentRegistry -> (ApiResult -> msg) -> Cmd msg
requestAgents agentRegistry toMsg =
    AgentRegistry.listAgents agentRegistry
        |> GrenTask.andThen
            (\agents ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            let
                                agentsJson =
                                    Encode.array encodeAgentConfig agents
                            in
                            ApiSuccess { statusCode = 200, body = wrapResponse agentsJson now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


{-| GET /api/agents/:name - Get a single agent config.
-}
requestAgent : AgentRegistry.AgentRegistry -> String -> (ApiResult -> msg) -> Cmd msg
requestAgent agentRegistry name toMsg =
    AgentRegistry.getAgent agentRegistry name
        |> GrenTask.andThen
            (\agentConfig ->
                Time.now
                    |> GrenTask.mapError (\_ -> AgentRegistry.FileSystemError "Failed to get time")
                    |> GrenTask.map
                        (\now ->
                            ApiSuccess { statusCode = 200, body = wrapResponse (encodeAgentConfig agentConfig) now }
                        )
            )
        |> GrenTask.onError
            (\err ->
                when err is
                    AgentRegistry.AgentNotFound _ ->
                        GrenTask.succeed (ApiError { statusCode = 404, code = "NOT_FOUND", message = AgentRegistry.errorToString err })

                    _ ->
                        GrenTask.succeed (ApiError { statusCode = 500, code = "AGENT_REGISTRY_ERROR", message = AgentRegistry.errorToString err })
            )
        |> GrenTask.perform toMsg


-- RESPONSE SENDING


{-| Send an API response.
-}
sendApiResponse : Response -> ApiResult -> Cmd msg
sendApiResponse response result =
    when result is
        ApiSuccess { statusCode, body } ->
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody body
                |> Response.send

        ApiError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send



{-| Send a binary response (for file downloads).
-}
sendBinaryResponse : Response -> BinaryResult -> Cmd msg
sendBinaryResponse response result =
    when result is
        BinarySuccess { bytes, contentType } ->
            response
                |> Response.setStatus 200
                |> Response.setHeader "Content-Type" contentType
                |> Response.setBodyAsBytes bytes
                |> Response.send

        BinaryError { statusCode, code, message } ->
            let
                errorBody =
                    Encode.object
                        [ { key = "error"
                          , value =
                                Encode.object
                                    [ { key = "code", value = Encode.string code }
                                    , { key = "message", value = Encode.string message }
                                    ]
                          }
                        ]
                        |> Encode.encode 0
            in
            response
                |> Response.setStatus statusCode
                |> Response.setHeader "Content-Type" "application/json"
                |> Response.setBody errorBody
                |> Response.send



-- HELPERS


{-| Parse a status string to TaskStatus.
-}
parseStatus : String -> Maybe TaskStatus
parseStatus statusStr =
    Types.statusFromString statusStr


{-| Wrap data in standard response format.
-}
wrapResponse : Encode.Value -> Time.Posix -> String
wrapResponse data timestamp =
    Encode.object
        [ { key = "data", value = data }
        , { key = "meta"
          , value =
                Encode.object
                    [ { key = "timestamp", value = Encode.int (Time.posixToMillis timestamp) }
                    ]
          }
        ]
        |> Encode.encode 0



{-| Convert queue error to string.
-}
queueErrorToString : Queue.Error -> String
queueErrorToString err =
    when err is
        Queue.FileSystemError msg ->
            "File system error: " ++ msg

        Queue.JsonDecodeError msg ->
            "JSON decode error: " ++ msg

        Queue.TaskNotFound tid ->
            "Task not found: " ++ Id.taskIdToString tid
