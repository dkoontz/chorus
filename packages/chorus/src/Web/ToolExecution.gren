module Web.ToolExecution exposing
    ( ToolCallResult
    , ToolExecutionContext
    , ToolPermission(..)
    , checkPermission
    , completionReportInputDecoder
    , executeToolCall
    , requestExecuteTool
    )

{-| Server-side tool execution.

Handles tool requests by checking permissions against the agent's
allowed tools list, then dispatching to the appropriate tool implementation.

File tools are executed directly. Task tools (task.get, task.list) are
handled via the registry. Handoff returns a DeferredHandoff result that
signals Main.gren to start the agent and hold the response until completion.

-}

import ChildProcess
import Dict
import FileSystem
import Id exposing (TaskId)
import Json.Decode as Decode
import Json.Encode as Encode
import Task as GrenTask
import Task.Registry as Registry
import Time
import Tools.File as File
import Tools.Json as ToolsJson
    exposing
        ( ToolRequest(..)
        , encodeReadOutput
        , encodeWriteOutput
        , encodePatchOutput
        , encodeDeleteOutput
        , encodeListOutput
        , encodeSearchOutput
        , encodeAllToolsHelp
        )
import Tools.Validation as Validation
import Types exposing (EventType(..), PlannerOutput(..))
import Web.Api as Api


{-| Context needed for tool execution.
-}
type alias ToolExecutionContext =
    { filesystemPermission : FileSystem.Permission
    , childProcessPermission : ChildProcess.Permission
    , allowedDirectories : Array String
    , allowedTools : Array String
    , apiContext : Api.ApiContext
    , taskId : TaskId
    }


{-| Result of executing a single tool call.

Contains the tool call ID and name for correlation, the encoded request body
that was sent to the tool dispatcher, and the execution result.

-}
type alias ToolCallResult =
    { toolCallId : String
    , toolName : String
    , requestBody : String
    , result : Api.ApiResult
    }


{-| Result of a permission check.
-}
type ToolPermission
    = Allowed
    | Denied String


{-| Check if a tool is allowed for this agent.
-}
checkPermission : Array String -> String -> ToolPermission
checkPermission allowedTools toolName =
    if Array.any (\t -> t == toolName) allowedTools then
        Allowed
    else
        Denied ("Tool '" ++ toolName ++ "' is not allowed for this agent")


{-| Execute a tool request.

Parses the JSON request body, checks permissions, and dispatches
to the appropriate tool handler. Returns an ApiResult.

-}
requestExecuteTool : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
requestExecuteTool ctx requestBody toMsg =
    let
        toolNameResult =
            Decode.decodeString (Decode.field "tool" Decode.string) requestBody
    in
    when toolNameResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Missing or invalid 'tool' field in request"
                    }
                )
                |> GrenTask.perform toMsg

        Ok toolName ->
            -- completion-report and planner-output are always allowed (auto-granted)
            if toolName == "completion-report" || toolName == "planner-output" then
                dispatchTool ctx toolName requestBody toMsg
            else
                when checkPermission ctx.allowedTools toolName is
                    Denied reason ->
                        GrenTask.succeed
                            (Api.ApiError
                                { statusCode = 403
                                , code = "FORBIDDEN"
                                , message = reason
                                }
                            )
                            |> GrenTask.perform toMsg

                    Allowed ->
                        dispatchTool ctx toolName requestBody toMsg


{-| Execute a single tool call from a provider response.

Takes a structured tool call (with id, name, and JSON input), encodes it into
the request body format expected by the tool dispatcher, checks permissions,
and dispatches. The result is wrapped in a `ToolCallResult` that carries the
tool call ID and name for correlation by the caller.

This function is the entry point for the Executor's tool processing pipeline,
used by both CLI and API providers.

-}
executeToolCall :
    ToolExecutionContext
    -> { id : String, name : String, input : Decode.Value }
    -> (ToolCallResult -> msg)
    -> Cmd msg
executeToolCall ctx toolCall toMsg =
    let
        -- Build the request body by merging {"tool": name} into the input object.
        -- The input value is expected to be a JSON object; its fields become
        -- top-level fields alongside "tool" in the request body, matching the
        -- format expected by dispatchTool and downstream decoders.
        requestBody =
            let
                inputFields =
                    Decode.decodeValue (Decode.keyValuePairs Decode.value) toolCall.input
                        |> Result.withDefault []

                allFields =
                    Array.pushFirst
                        { key = "tool", value = Encode.string toolCall.name }
                        inputFields
            in
            Encode.encode 0 (Encode.object allFields)

        wrapResult apiResult =
            toMsg
                { toolCallId = toolCall.id
                , toolName = toolCall.name
                , requestBody = requestBody
                , result = apiResult
                }
    in
    -- completion-report and planner-output are always allowed (auto-granted)
    if toolCall.name == "completion-report" || toolCall.name == "planner-output" then
        dispatchTool ctx toolCall.name requestBody wrapResult
    else
        when checkPermission ctx.allowedTools toolCall.name is
            Denied reason ->
                GrenTask.succeed
                    (Api.ApiError
                        { statusCode = 403
                        , code = "FORBIDDEN"
                        , message = reason
                        }
                    )
                    |> GrenTask.perform wrapResult

            Allowed ->
                dispatchTool ctx toolCall.name requestBody wrapResult


{-| Dispatch a tool request to the appropriate handler based on tool name.
-}
dispatchTool : ToolExecutionContext -> String -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTool ctx toolName requestBody toMsg =
    when toolName is
        "task.get" ->
            dispatchTaskGet ctx requestBody toMsg

        "task.list" ->
            dispatchTaskList ctx requestBody toMsg

        "completion-report" ->
            dispatchCompletionReport ctx requestBody toMsg

        "planner-output" ->
            dispatchPlannerOutput requestBody toMsg

        "handoff" ->
            dispatchHandoffTool requestBody toMsg

        "help" ->
            GrenTask.succeed
                (Api.ApiSuccess
                    { statusCode = 200
                    , body = Encode.encode 0 encodeAllToolsHelp
                    }
                )
                |> GrenTask.perform toMsg

        _ ->
            dispatchFileTool ctx requestBody toMsg


{-| Dispatch a file tool request using the shared Tools.Json decoder.
-}
dispatchFileTool : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchFileTool ctx requestBody toMsg =
    when ToolsJson.decodeRequest requestBody is
        Err errMsg ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = errMsg
                    }
                )
                |> GrenTask.perform toMsg

        Ok toolRequest ->
            let
                allowedDirs =
                    Validation.makeAllowedDirectories ctx.allowedDirectories
            in
            when toolRequest is
                ReadRequest input ->
                    executeFileTask
                        (File.read ctx.filesystemPermission allowedDirs input)
                        encodeReadOutput
                        toMsg

                CreateRequest input ->
                    executeFileTask
                        (File.create ctx.filesystemPermission allowedDirs input)
                        encodeWriteOutput
                        toMsg

                WriteRequest input ->
                    executeFileTask
                        (File.write ctx.filesystemPermission allowedDirs input)
                        encodeWriteOutput
                        toMsg

                PatchRequest input ->
                    executeFileTask
                        (File.patch ctx.filesystemPermission allowedDirs input)
                        encodePatchOutput
                        toMsg

                DeleteRequest input ->
                    executeFileTask
                        (File.delete ctx.filesystemPermission allowedDirs input)
                        encodeDeleteOutput
                        toMsg

                ListRequest input ->
                    executeFileTask
                        (File.list ctx.filesystemPermission ctx.childProcessPermission allowedDirs input)
                        encodeListOutput
                        toMsg

                SearchRequest input ->
                    executeFileTask
                        (File.search ctx.childProcessPermission allowedDirs input)
                        encodeSearchOutput
                        toMsg

                -- HelpRequest is handled above by tool name
                _ ->
                    GrenTask.succeed
                        (Api.ApiError
                            { statusCode = 400
                            , code = "BAD_REQUEST"
                            , message = "Unexpected tool request"
                            }
                        )
                        |> GrenTask.perform toMsg


{-| Handle task.get by querying the registry directly.
-}
dispatchTaskGet : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTaskGet ctx requestBody toMsg =
    let
        taskIdResult =
            Decode.decodeString (Decode.field "taskId" Decode.string) requestBody
    in
    when taskIdResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Missing 'taskId' field for task.get"
                    }
                )
                |> GrenTask.perform toMsg

        Ok taskIdStr ->
            when Id.taskIdFromString taskIdStr is
                Nothing ->
                    GrenTask.succeed
                        (Api.ApiError
                            { statusCode = 400
                            , code = "BAD_REQUEST"
                            , message = "Invalid task ID: " ++ taskIdStr
                            }
                        )
                        |> GrenTask.perform toMsg

                Just taskId ->
                    Api.requestTask ctx.apiContext taskId toMsg


{-| Handle task.list by querying the registry directly.
-}
dispatchTaskList : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTaskList ctx requestBody toMsg =
    let
        statusFilter =
            Decode.decodeString (Decode.field "status" Decode.string) requestBody
                |> Result.toMaybe
    in
    Api.requestTasks ctx.apiContext statusFilter toMsg


{-| Handle completion-report tool: store structured output on the task's handoff record.
-}
dispatchCompletionReport : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchCompletionReport ctx requestBody toMsg =
    let
        reportResult =
            Decode.decodeString completionReportInputDecoder requestBody
    in
    when reportResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Invalid completion-report: requires 'status' (complete|blocked|failed), 'summary', and 'output' fields"
                    }
                )
                |> GrenTask.perform toMsg

        Ok report ->
            -- Read the task first to get the current status for the status_changed event
            let
                newStatus =
                    when report.status is
                        Types.ReportComplete ->
                            Types.Completed

                        Types.ReportBlocked ->
                            Types.Waiting

                        Types.ReportFailed ->
                            Types.Failed report.summary

                updateFn task =
                    let
                        chain =
                            Types.taskAgentChain task

                        agentName =
                            Types.taskCurrentAgent task
                                |> Maybe.withDefault "unknown"

                        -- Update the entry matching the current agent
                        updatedChain =
                            Types.updateCurrentAgentEntry agentName
                                (\entry -> { entry | completionReport = Just report })
                                chain
                    in
                    task
                        |> Types.setAgentChain updatedChain
                        |> Types.setTaskStatus newStatus
            in
            Registry.getTask ctx.apiContext.registry ctx.taskId
                |> GrenTask.andThen
                    (\maybeTask ->
                        let
                            previousStatus =
                                when maybeTask is
                                    Just task ->
                                        Types.taskStatus task

                                    Nothing ->
                                        Types.Active
                        in
                        Registry.updateTask ctx.apiContext.registry ctx.taskId updateFn
                            |> GrenTask.andThen
                                (\_ ->
                                    -- Record completion_report_submitted event
                                    Registry.recordEvent ctx.apiContext.registry ctx.taskId
                                        { eventType = CompletionReportSubmitted
                                        , data =
                                            Dict.empty
                                                |> Dict.set "status" (Types.completionStatusToString report.status)
                                                |> Dict.set "summary" report.summary
                                        }
                                        |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                        |> GrenTask.andThen
                                            (\_ ->
                                                -- Record status_changed event
                                                Registry.recordEvent ctx.apiContext.registry ctx.taskId
                                                    { eventType = StatusChanged
                                                    , data =
                                                        Dict.empty
                                                            |> Dict.set "from" (Types.statusToString previousStatus)
                                                            |> Dict.set "to" (Types.statusToString newStatus)
                                                    }
                                                    |> GrenTask.onError (\_ -> GrenTask.succeed {})
                                            )
                                        |> GrenTask.map
                                            (\_ ->
                                                Api.ApiSuccess
                                                    { statusCode = 200
                                                    , body =
                                                        Encode.encode 0
                                                            (Encode.object
                                                                [ { key = "success", value = Encode.bool True }
                                                                , { key = "status", value = Encode.string (Types.completionStatusToString report.status) }
                                                                ]
                                                            )
                                                    }
                                            )
                                )
                    )
                |> GrenTask.onError
                    (\err ->
                        GrenTask.succeed
                            (Api.ApiError
                                { statusCode = 500
                                , code = "REGISTRY_ERROR"
                                , message = Registry.errorToString err
                                }
                            )
                    )
                |> GrenTask.perform toMsg


{-| Decode a completion report from tool input JSON.
-}
completionReportInputDecoder : Decode.Decoder Types.CompletionReport
completionReportInputDecoder =
    Decode.map4
        (\status summary output blockedReason ->
            { status = status
            , summary = summary
            , output = output
            , blockedReason = blockedReason
            }
        )
        (Decode.field "status" Types.completionStatusDecoder)
        (Decode.field "summary" Decode.string)
        (Decode.field "output" Decode.string)
        (Decode.maybe (Decode.field "blockedReason" Decode.string))


{-| Execute a file tool task, encoding the result as an ApiResult.
-}
executeFileTask :
    GrenTask.Task File.FileError a
    -> (a -> Encode.Value)
    -> (Api.ApiResult -> msg)
    -> Cmd msg
executeFileTask task encoder toMsg =
    task
        |> GrenTask.map
            (\output ->
                Api.ApiSuccess
                    { statusCode = 200
                    , body = Encode.encode 0 (encoder output)
                    }
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    (Api.ApiError
                        { statusCode = 500
                        , code = "TOOL_ERROR"
                        , message = File.fileErrorToString err
                        }
                    )
            )
        |> GrenTask.perform toMsg


{-| Dispatch a handoff tool request by returning a DeferredHandoff result.

The handoff is not executed here. Instead, a DeferredHandoff result signals
Main.gren to start the handoff, hold the HTTP response, and return the
agent's output when it completes.
-}
dispatchHandoffTool : String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchHandoffTool requestBody toMsg =
    let
        handoffParamsResult =
            Decode.decodeString
                (Decode.map2
                    (\agentName prompt ->
                        { agentName = agentName
                        , prompt = prompt
                        }
                    )
                    (Decode.field "agentName" Decode.string)
                    (Decode.field "prompt" Decode.string)
                )
                requestBody
    in
    when handoffParamsResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Invalid handoff request: requires 'agentName' and 'prompt' fields"
                    }
                )
                |> GrenTask.perform toMsg

        Ok params ->
            GrenTask.succeed
                (Api.DeferredHandoff
                    { agentName = params.agentName
                    , prompt = params.prompt
                    }
                )
                |> GrenTask.perform toMsg


{-| Dispatch a planner-output tool request by returning a DeferredPlannerOutput result.

The planner output is not applied here. Instead, a DeferredPlannerOutput result
signals Main.gren to store the structured data on the executor state and apply
it when the planner process exits.
-}
dispatchPlannerOutput : String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchPlannerOutput requestBody toMsg =
    let
        decodeResult =
            Decode.decodeString Types.plannerOutputDecoder requestBody
    in
    when decodeResult is
        Err err ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Invalid planner-output: requires 'type' field (plan|questions|error) with corresponding data. Decode error: " ++ Decode.errorToString err
                    }
                )
                |> GrenTask.perform toMsg

        Ok plannerOutput ->
            GrenTask.succeed
                (Api.DeferredPlannerOutput plannerOutput)
                |> GrenTask.perform toMsg
