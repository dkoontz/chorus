module Web.ToolExecution exposing
    ( ToolExecutionContext
    , ToolPermission(..)
    , checkPermission
    , requestExecuteTool
    )

{-| Server-side tool execution.

Handles tool requests by checking permissions against the agent's
allowed tools list, then dispatching to the appropriate tool implementation.

File tools are executed directly. Task tools (task.get, task.list) are
handled via the registry. Handoff is rejected here (use the handoff endpoint).

-}

import ChildProcess
import Dict
import FileSystem
import Id exposing (TaskId)
import Json.Decode as Decode
import Json.Encode as Encode
import Task as GrenTask
import Task.Registry as Registry
import Time
import Tools.File as File
import Tools.Json as ToolsJson
    exposing
        ( ToolRequest(..)
        , encodeReadOutput
        , encodeWriteOutput
        , encodePatchOutput
        , encodeDeleteOutput
        , encodeListOutput
        , encodeSearchOutput
        , encodeAllToolsHelp
        )
import Tools.Validation as Validation
import Types
import Web.Api as Api


{-| Context needed for tool execution.
-}
type alias ToolExecutionContext =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , workspaceRoot : String
    , allowedTools : Array String
    , apiContext : Api.ApiContext
    , taskId : TaskId
    }


{-| Result of a permission check.
-}
type ToolPermission
    = Allowed
    | Denied String


{-| Check if a tool is allowed for this agent.
-}
checkPermission : Array String -> String -> ToolPermission
checkPermission allowedTools toolName =
    if Array.any (\t -> t == toolName) allowedTools then
        Allowed
    else
        Denied ("Tool '" ++ toolName ++ "' is not allowed for this agent")


{-| Execute a tool request.

Parses the JSON request body, checks permissions, and dispatches
to the appropriate tool handler. Returns an ApiResult.

-}
requestExecuteTool : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
requestExecuteTool ctx requestBody toMsg =
    let
        toolNameResult =
            Decode.decodeString (Decode.field "tool" Decode.string) requestBody
    in
    when toolNameResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Missing or invalid 'tool' field in request"
                    }
                )
                |> GrenTask.perform toMsg

        Ok toolName ->
            -- completion-report is always allowed (auto-granted)
            if toolName == "completion-report" then
                dispatchTool ctx toolName requestBody toMsg
            else
                when checkPermission ctx.allowedTools toolName is
                    Denied reason ->
                        GrenTask.succeed
                            (Api.ApiError
                                { statusCode = 403
                                , code = "FORBIDDEN"
                                , message = reason
                                }
                            )
                            |> GrenTask.perform toMsg

                    Allowed ->
                        dispatchTool ctx toolName requestBody toMsg


{-| Dispatch a tool request to the appropriate handler based on tool name.
-}
dispatchTool : ToolExecutionContext -> String -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTool ctx toolName requestBody toMsg =
    when toolName is
        "task.get" ->
            dispatchTaskGet ctx requestBody toMsg

        "task.list" ->
            dispatchTaskList ctx requestBody toMsg

        "completion-report" ->
            dispatchCompletionReport ctx requestBody toMsg

        "handoff" ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Use POST /api/tasks/:id/handoff for handoff operations"
                    }
                )
                |> GrenTask.perform toMsg

        "help" ->
            GrenTask.succeed
                (Api.ApiSuccess
                    { statusCode = 200
                    , body = Encode.encode 0 encodeAllToolsHelp
                    }
                )
                |> GrenTask.perform toMsg

        _ ->
            dispatchFileTool ctx requestBody toMsg


{-| Dispatch a file tool request using the shared Tools.Json decoder.
-}
dispatchFileTool : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchFileTool ctx requestBody toMsg =
    when ToolsJson.decodeRequest requestBody is
        Err errMsg ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = errMsg
                    }
                )
                |> GrenTask.perform toMsg

        Ok toolRequest ->
            let
                wsRoot =
                    Validation.makeWorkspaceRoot ctx.workspaceRoot
            in
            when toolRequest is
                ReadRequest input ->
                    executeFileTask
                        (File.read ctx.fsPermission wsRoot input)
                        encodeReadOutput
                        toMsg

                CreateRequest input ->
                    executeFileTask
                        (File.create ctx.fsPermission wsRoot input)
                        encodeWriteOutput
                        toMsg

                WriteRequest input ->
                    executeFileTask
                        (File.write ctx.fsPermission wsRoot input)
                        encodeWriteOutput
                        toMsg

                PatchRequest input ->
                    executeFileTask
                        (File.patch ctx.fsPermission wsRoot input)
                        encodePatchOutput
                        toMsg

                DeleteRequest input ->
                    executeFileTask
                        (File.delete ctx.fsPermission wsRoot input)
                        encodeDeleteOutput
                        toMsg

                ListRequest input ->
                    executeFileTask
                        (File.list ctx.fsPermission ctx.cpPermission wsRoot input)
                        encodeListOutput
                        toMsg

                SearchRequest input ->
                    executeFileTask
                        (File.search ctx.cpPermission wsRoot input)
                        encodeSearchOutput
                        toMsg

                -- HandoffRequest and HelpRequest are handled above by tool name
                _ ->
                    GrenTask.succeed
                        (Api.ApiError
                            { statusCode = 400
                            , code = "BAD_REQUEST"
                            , message = "Unexpected tool request"
                            }
                        )
                        |> GrenTask.perform toMsg


{-| Handle task.get by querying the registry directly.
-}
dispatchTaskGet : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTaskGet ctx requestBody toMsg =
    let
        taskIdResult =
            Decode.decodeString (Decode.field "taskId" Decode.string) requestBody
    in
    when taskIdResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Missing 'taskId' field for task.get"
                    }
                )
                |> GrenTask.perform toMsg

        Ok taskIdStr ->
            when Id.taskIdFromString taskIdStr is
                Nothing ->
                    GrenTask.succeed
                        (Api.ApiError
                            { statusCode = 400
                            , code = "BAD_REQUEST"
                            , message = "Invalid task ID: " ++ taskIdStr
                            }
                        )
                        |> GrenTask.perform toMsg

                Just taskId ->
                    Api.requestTask ctx.apiContext taskId toMsg


{-| Handle task.list by querying the registry directly.
-}
dispatchTaskList : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchTaskList ctx requestBody toMsg =
    let
        statusFilter =
            Decode.decodeString (Decode.field "status" Decode.string) requestBody
                |> Result.toMaybe
    in
    Api.requestTasks ctx.apiContext statusFilter toMsg


{-| Handle completion-report tool: store structured output on the task's handoff record.
-}
dispatchCompletionReport : ToolExecutionContext -> String -> (Api.ApiResult -> msg) -> Cmd msg
dispatchCompletionReport ctx requestBody toMsg =
    let
        reportResult =
            Decode.decodeString completionReportInputDecoder requestBody
    in
    when reportResult is
        Err _ ->
            GrenTask.succeed
                (Api.ApiError
                    { statusCode = 400
                    , code = "BAD_REQUEST"
                    , message = "Invalid completion-report: requires 'status' (complete|blocked|failed), 'summary', and 'output' fields"
                    }
                )
                |> GrenTask.perform toMsg

        Ok report ->
            -- Update the task's last handoff record with the completion report
            let
                updateFn task =
                    let
                        chain =
                            Types.taskAgentChain task

                        updatedChain =
                            when Array.popLast chain is
                                Nothing ->
                                    chain

                                Just { last, initial } ->
                                    Array.pushLast
                                        { last | completionReport = Just report }
                                        initial

                        -- Map completion status to task status
                        newStatus =
                            when report.status is
                                Types.ReportComplete ->
                                    Types.Completed

                                Types.ReportBlocked ->
                                    Types.Waiting

                                Types.ReportFailed ->
                                    Types.Failed report.summary
                    in
                    task
                        |> Types.setAgentChain updatedChain
                        |> Types.setTaskStatus newStatus
            in
            Registry.updateTask ctx.apiContext.registry ctx.taskId updateFn
                |> GrenTask.andThen
                    (\_ ->
                        -- Record history event
                        Registry.recordEvent ctx.apiContext.registry ctx.taskId
                            { eventType = "completion_report_submitted"
                            , data =
                                Dict.empty
                                    |> Dict.set "status" (Types.completionStatusToString report.status)
                                    |> Dict.set "summary" report.summary
                            }
                            |> GrenTask.map
                                (\_ ->
                                    Api.ApiSuccess
                                        { statusCode = 200
                                        , body =
                                            Encode.encode 0
                                                (Encode.object
                                                    [ { key = "success", value = Encode.bool True }
                                                    , { key = "status", value = Encode.string (Types.completionStatusToString report.status) }
                                                    ]
                                                )
                                        }
                                )
                    )
                |> GrenTask.onError
                    (\err ->
                        GrenTask.succeed
                            (Api.ApiError
                                { statusCode = 500
                                , code = "REGISTRY_ERROR"
                                , message = Registry.errorToString err
                                }
                            )
                    )
                |> GrenTask.perform toMsg


{-| Decode a completion report from tool input JSON.
-}
completionReportInputDecoder : Decode.Decoder Types.CompletionReport
completionReportInputDecoder =
    Decode.map4
        (\status summary output blockedReason ->
            { status = status
            , summary = summary
            , output = output
            , blockedReason = blockedReason
            }
        )
        (Decode.field "status" completionStatusStringDecoder)
        (Decode.field "summary" Decode.string)
        (Decode.field "output" Decode.string)
        (Decode.maybe (Decode.field "blockedReason" Decode.string))


completionStatusStringDecoder : Decode.Decoder Types.CompletionStatus
completionStatusStringDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                when str is
                    "complete" ->
                        Decode.succeed Types.ReportComplete

                    "blocked" ->
                        Decode.succeed Types.ReportBlocked

                    "failed" ->
                        Decode.succeed Types.ReportFailed

                    _ ->
                        Decode.fail ("Unknown completion status: " ++ str ++ ". Must be 'complete', 'blocked', or 'failed'.")
            )


{-| Execute a file tool task, encoding the result as an ApiResult.
-}
executeFileTask :
    GrenTask.Task File.FileError a
    -> (a -> Encode.Value)
    -> (Api.ApiResult -> msg)
    -> Cmd msg
executeFileTask task encoder toMsg =
    task
        |> GrenTask.map
            (\output ->
                Api.ApiSuccess
                    { statusCode = 200
                    , body = Encode.encode 0 (encoder output)
                    }
            )
        |> GrenTask.onError
            (\err ->
                GrenTask.succeed
                    (Api.ApiError
                        { statusCode = 500
                        , code = "TOOL_ERROR"
                        , message = File.fileErrorToString err
                        }
                    )
            )
        |> GrenTask.perform toMsg
