module Agent.Executor exposing
    ( Config
    , Msg(..)
    , Model(..)
    , AccumulatedData(..)
    , PendingTool
    , DeferredAction(..)
    , UpdateEffect(..)
    , init
    , update
    )

{-| Agent executor that manages the conversation loop.

The executor uses the Provider interface to communicate with LLMs,
making it independent of any specific LLM service.

The executor (`Model`, `Msg`, `Config`, `init`,
`update`) is a tool-processing state machine that receives events from a
Provider (via Main.gren routing) and processes tool calls identically regardless
of whether they originate from a CLI HTTP callback or an API response.

The executor does not manage Provider communication directly. The Provider
feeds events in, the executor processes them, and returns an `UpdateEffect` that
tells Main.gren what action to take next (deliver results to the Provider, handle
a deferred action, etc.).

-}

import Dict exposing (Dict)
import Json.Decode as Decode
import Provider exposing (ToolResult)
import Types
import Web.Api as Api
import Web.ToolExecution as ToolExecution


{-| Configuration for the executor.

The executor receives tool calls via messages and processes them via
`executeTool`. It does not know about Providers.

-}
type alias Config msg =
    { executeTool :
        { id : String, name : String, input : Decode.Value }
        -> (ToolExecution.ToolCallResult -> msg)
        -> Cmd msg
    , toMsg : Msg -> msg
    }


{-| Messages for the executor.

These are routed from Provider events by Main.gren:

- `ToolCallReceived`: A tool call arrived from the Provider. The executor
  dispatches it via `config.executeTool`.
- `ToolCallCompleted`: Tool execution finished. The executor inspects the
  result and determines the appropriate effect.
- `AgentCompleted`: The Provider signals the conversation is finished.
- `AgentFailed`: The Provider signals the conversation errored.

-}
type Msg
    = ToolCallReceived { id : String, name : String, input : Decode.Value }
    | ToolCallCompleted ToolExecution.ToolCallResult
    | AgentCompleted String
    | AgentFailed String


{-| Per-agent-type accumulated metadata.

Each agent kind carries only its own completion data shape, making
invalid combinations (e.g. a user agent with planner output)
unrepresentable.

-}
type AccumulatedData
    = UserAgentData { completionReport : Maybe Types.CompletionReport }
    | TaskValidatorData { plannerOutput : Maybe Types.PlannerOutput }


{-| Executor state.

- `Idle`: Executor created but no conversation started yet. Carries the
  `AccumulatedData` variant so the correct shape is available when
  the first tool call transitions the executor to `Running`.
- `Running`: Conversation active, processing tool calls.
- `AwaitingDeferredAction`: A tool call produced a deferred result (handoff
  or planner output) that Main.gren must handle before the executor can
  continue.
- `Complete`: Conversation finished successfully.
- `Failed`: Conversation errored.

-}
type Model
    = Idle AccumulatedData
    | Running
        { pendingToolCalls : Dict String PendingTool
        , completedResults : Array ToolResult
        , accumulatedData : AccumulatedData
        }
    | AwaitingDeferredAction DeferredAction
    | Complete
        { output : String
        , accumulatedData : AccumulatedData
        }
    | Failed
        { error : String
        , accumulatedData : AccumulatedData
        }


{-| A tool call that has been dispatched and is awaiting a result.
-}
type alias PendingTool =
    { id : String
    , name : String
    , input : Decode.Value
    }


{-| A deferred action that requires Main.gren to intervene.

- `Handoff`: An agent invoked the handoff tool. Main.gren should start
  the target agent and hold the HTTP response until it completes.
- `PlannerOutputReady`: The planner invoked the planner-output tool.
  Main.gren should store the structured output and apply it when the
  planner process exits.

-}
type DeferredAction
    = Handoff { toolCallId : String, agentName : String, prompt : String }
    | PlannerOutputReady { toolCallId : String, plannerOutput : Types.PlannerOutput }


{-| Effects produced by the executor's update function.

Main.gren inspects the effect to determine what action to take:

- `NoEffect`: No external action needed.
- `DeliverToolResults`: All pending tool calls are complete. Main.gren
  should call `provider.deliverToolResults` with the collected results.
- `DeferredActionRequired`: A tool call produced a deferred result that
  Main.gren must handle (handoff or planner output).

-}
type UpdateEffect
    = NoEffect
    | DeliverToolResults (Array ToolResult)
    | DeferredActionRequired DeferredAction


{-| Initialize the executor with the appropriate accumulated data shape.

The `AccumulatedData` variant determines which completion data the executor
tracks. It must be provided before the first tool call arrives.
-}
init : AccumulatedData -> Model
init accumulatedData =
    Idle accumulatedData


{-| Update the executor state based on messages.

Returns the updated model, any commands to execute, and an effect that
tells Main.gren what external action to take.

-}
update :
    Msg
    -> Model
    -> Config msg
    -> { model : Model, cmd : Cmd msg, effect : UpdateEffect }
update msg model config =
    when msg is
        ToolCallReceived toolCall ->
            let
                pendingTool =
                    { id = toolCall.id
                    , name = toolCall.name
                    , input = toolCall.input
                    }

                runningState =
                    when model is
                        Running state ->
                            { state
                                | pendingToolCalls =
                                    Dict.set toolCall.id pendingTool state.pendingToolCalls
                            }

                        Idle accumulatedData ->
                            -- Normal first-tool-call case: use the AccumulatedData
                            -- variant from init to construct the running state.
                            { pendingToolCalls =
                                Dict.singleton toolCall.id pendingTool
                            , completedResults = []
                            , accumulatedData = accumulatedData
                            }

                        Complete { accumulatedData } ->
                            -- Edge case: tool call arrives after completion.
                            { pendingToolCalls =
                                Dict.singleton toolCall.id pendingTool
                            , completedResults = []
                            , accumulatedData = accumulatedData
                            }

                        Failed { accumulatedData } ->
                            -- Edge case: tool call arrives after failure.
                            { pendingToolCalls =
                                Dict.singleton toolCall.id pendingTool
                            , completedResults = []
                            , accumulatedData = accumulatedData
                            }

                        AwaitingDeferredAction _ ->
                            -- Edge case: tool call arrives while awaiting deferred
                            -- action. Fall back to user agent data since we cannot
                            -- recover the accumulated data from this state.
                            { pendingToolCalls =
                                Dict.singleton toolCall.id pendingTool
                            , completedResults = []
                            , accumulatedData = UserAgentData { completionReport = Nothing }
                            }

                cmd =
                    config.executeTool
                        toolCall
                        (\result -> config.toMsg (ToolCallCompleted result))
            in
            { model = Running runningState
            , cmd = cmd
            , effect = NoEffect
            }

        ToolCallCompleted toolCallResult ->
            when model is
                Running state ->
                    handleToolCallCompleted toolCallResult state

                _ ->
                    -- Tool result arrived but executor is not in Running state.
                    -- This should not happen in normal operation; discard.
                    { model = model
                    , cmd = Cmd.none
                    , effect = NoEffect
                    }

        AgentCompleted output ->
            let
                accumulatedData =
                    when model is
                        Running state ->
                            state.accumulatedData

                        Idle data ->
                            data

                        Complete state ->
                            state.accumulatedData

                        Failed state ->
                            state.accumulatedData

                        AwaitingDeferredAction _ ->
                            UserAgentData { completionReport = Nothing }
            in
            { model =
                Complete
                    { output = output
                    , accumulatedData = accumulatedData
                    }
            , cmd = Cmd.none
            , effect = NoEffect
            }

        AgentFailed error ->
            let
                accumulatedData =
                    when model is
                        Running state ->
                            state.accumulatedData

                        Idle data ->
                            data

                        Complete state ->
                            state.accumulatedData

                        Failed state ->
                            state.accumulatedData

                        AwaitingDeferredAction _ ->
                            UserAgentData { completionReport = Nothing }
            in
            { model =
                Failed
                    { error = error
                    , accumulatedData = accumulatedData
                    }
            , cmd = Cmd.none
            , effect = NoEffect
            }


{-| Handle a completed tool call in the Running state.

Inspects the `ApiResult` to determine if this is a regular result, a deferred
action (handoff or planner output), or a completion report. Updates the
executor state accordingly and produces the appropriate effect.

-}
handleToolCallCompleted :
    ToolExecution.ToolCallResult
    -> { pendingToolCalls : Dict String PendingTool
       , completedResults : Array ToolResult
       , accumulatedData : AccumulatedData
       }
    -> { model : Model, cmd : Cmd msg, effect : UpdateEffect }
handleToolCallCompleted toolCallResult state =
    let
        remainingPending =
            Dict.remove toolCallResult.toolCallId state.pendingToolCalls
    in
    when toolCallResult.result is
        Api.DeferredHandoff params ->
            -- A handoff abandons the current agent entirely. Any
            -- remaining pending tool calls are intentionally discarded
            -- because the target agent takes over the conversation.
            let
                action =
                    Handoff
                        { toolCallId = toolCallResult.toolCallId
                        , agentName = params.agentName
                        , prompt = params.prompt
                        }
            in
            { model = AwaitingDeferredAction action
            , cmd = Cmd.none
            , effect = DeferredActionRequired action
            }

        Api.DeferredPlannerOutput plannerOutput ->
            -- Transition away from Running entirely. The running state
            -- (including any remaining pending tools) is intentionally
            -- discarded â€” Main.gren will handle the deferred planner
            -- output and decide how to proceed.
            let
                action =
                    PlannerOutputReady
                        { toolCallId = toolCallResult.toolCallId
                        , plannerOutput = plannerOutput
                        }
            in
            { model = AwaitingDeferredAction action
            , cmd = Cmd.none
            , effect = DeferredActionRequired action
            }

        Api.ApiSuccess { body } ->
            let
                -- Check if this is a completion-report result by tool name
                -- and update the accumulated data accordingly.
                updatedAccumulatedData =
                    if toolCallResult.toolName == "completion-report" then
                        when state.accumulatedData is
                            UserAgentData userData ->
                                -- Parse the completion report from the original request body.
                                -- If decode succeeds, store the report. If it fails (which
                                -- should not happen since the tool already validated the
                                -- input), keep the existing report.
                                when Decode.decodeString ToolExecution.completionReportInputDecoder toolCallResult.requestBody is
                                    Ok report ->
                                        UserAgentData { userData | completionReport = Just report }

                                    Err _ ->
                                        state.accumulatedData

                            TaskValidatorData _ ->
                                -- completion-report is not valid for task validators;
                                -- leave data unchanged.
                                state.accumulatedData
                    else
                        state.accumulatedData

                toolResult =
                    { toolCallId = toolCallResult.toolCallId
                    , toolName = toolCallResult.toolName
                    , output = body
                    , isError = False
                    }

                updatedState =
                    { state
                        | accumulatedData = updatedAccumulatedData
                    }
            in
            collectResultAndCheckBatch toolResult remainingPending updatedState

        Api.ApiError { message } ->
            let
                toolResult =
                    { toolCallId = toolCallResult.toolCallId
                    , toolName = toolCallResult.toolName
                    , output = message
                    , isError = True
                    }
            in
            collectResultAndCheckBatch toolResult remainingPending state


{-| Collect a tool result and check whether all pending tools are done.

If all pending tools are complete, resets `completedResults` and emits
`DeliverToolResults` so Main.gren can send them to the Provider. Otherwise,
accumulates the result and waits for more completions.

-}
collectResultAndCheckBatch :
    ToolResult
    -> Dict String PendingTool
    -> { pendingToolCalls : Dict String PendingTool
       , completedResults : Array ToolResult
       , accumulatedData : AccumulatedData
       }
    -> { model : Model, cmd : Cmd msg, effect : UpdateEffect }
collectResultAndCheckBatch toolResult remainingPending state =
    let
        newResults =
            Array.pushLast toolResult state.completedResults
    in
    if Dict.isEmpty remainingPending then
        -- All pending tools done. Reset completedResults since
        -- they are being delivered via the effect.
        { model =
            Running
                { state
                    | pendingToolCalls = remainingPending
                    , completedResults = []
                }
        , cmd = Cmd.none
        , effect = DeliverToolResults newResults
        }
    else
        { model =
            Running
                { state
                    | pendingToolCalls = remainingPending
                    , completedResults = newResults
                }
        , cmd = Cmd.none
        , effect = NoEffect
        }
