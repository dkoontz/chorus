module Provider.ClaudeCode exposing
    ( provider
    , Config
    , CliArgs
    , buildShellCommand
    , toolCliFlagFromAllowedTools
    , chorusToolsToCliFlags
    )

{-| Claude Code provider implementation.

This provider spawns the Claude CLI directly to communicate with Claude.
It implements the Provider interface for LLM communication.
-}

import Bytes
import ChildProcess
import Dict
import HttpServer.Response as HttpResponse
import Json.Decode as Decode
import Json.Encode as Encode
import Provider
    exposing
        ( AgentSpec
        , HttpToolCallContext
        , Provider
        , ProviderError(..)
        , ProviderEvent(..)
        , ProviderKind(..)
        , ProviderState(..)
        , StartConfig
        , ToolCall
        , ToolResult
        )
import Task


-- CONFIGURATION


{-| Configuration for the Claude Code provider.
-}
type alias Config =
    { childProcessPermission : ChildProcess.Permission
    , chorusToolsPath : String
    , baseUrl : String
    }



-- PROVIDER


{-| The Claude Code provider.

This implements the `Provider` interface. For CLI providers:

- `startAgent` spawns the CLI process. On exit, emits `AgentCompleted` or
  `AgentFailed` via the `onEvent` callback.
- `handleHttpToolCall` stores the HTTP response handle in `CliProviderState`
  and emits `ToolCallReceived` so the Executor can process the tool call.
- `deliverToolResults` sends HTTP responses to the stored response handles,
  one per tool result.

-}
provider : Config -> Provider msg
provider config =
    { kind = CliProvider
    , validateEnvironment = validateEnvironment config
    , startAgent = startAgent config
    , deliverToolResults = deliverToolResults
    , handleHttpToolCall = handleHttpToolCall
    , initState = CliProviderState { pendingHttpResponses = Dict.empty }
    }


{-| Start an agent by spawning the CLI process.

Builds the shell command, spawns the process, and on exit emits
`AgentCompleted` or `AgentFailed` via `onEvent`.
-}
startAgent :
    Config
    -> ProviderState
    -> StartConfig msg
    -> { state : ProviderState, cmd : Cmd msg }
startAgent config state startConfig =
    let
        agentSpec =
            startConfig.agentSpec

        cliArgs =
            { systemPrompt =
                when startConfig.resumeSessionId is
                    Just _ ->
                        Nothing

                    Nothing ->
                        Just agentSpec.systemPrompt
            , resumeSessionId = startConfig.resumeSessionId
            , workspaceRoot = startConfig.workspaceRoot
            , chorusToolsPath = config.chorusToolsPath
            , message = startConfig.message
            , allowedTools = startConfig.allowedTools
            , taskId = startConfig.taskId
            , baseUrl = Just config.baseUrl
            }

        shellCommand =
            buildShellCommand cliArgs

        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
            , runDuration = ChildProcess.Milliseconds 600000
            }

        cmd =
            ChildProcess.run config.childProcessPermission "bash" [ "-c", shellCommand ] options
                |> Task.map
                    (\cliResult ->
                        let
                            output =
                                cliResult.stdout
                                    |> Bytes.toString
                                    |> Maybe.withDefault ""

                            resultText =
                                when Decode.decodeString (Decode.field "result" Decode.string) output is
                                    Ok text ->
                                        text

                                    Err _ ->
                                        output

                            sessionId =
                                when Decode.decodeString (Decode.field "session_id" Decode.string) output is
                                    Ok sid ->
                                        Just sid

                                    Err _ ->
                                        Nothing
                        in
                        startConfig.onEvent (AgentCompleted { output = resultText, sessionId = sessionId })
                    )
                |> Task.onError
                    (\runError ->
                        let
                            errMsg =
                                when runError is
                                    ChildProcess.InitError { errorCode } ->
                                        "Failed to start agent CLI: " ++ errorCode

                                    ChildProcess.ProgramError { exitCode, stderr } ->
                                        let
                                            stderrStr =
                                                stderr
                                                    |> Bytes.toString
                                                    |> Maybe.withDefault ""
                                        in
                                        if String.isEmpty (String.trim stderrStr) then
                                            "Agent CLI exited with code " ++ String.fromInt exitCode ++ " (no stderr output — process may have been killed by signal or timeout)"
                                        else
                                            "Agent CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                        in
                        Task.succeed (startConfig.onEvent (AgentFailed errMsg))
                    )
                |> Task.perform identity
    in
    { state = state
    , cmd = cmd
    }


{-| Deliver tool results back to the agent by sending HTTP responses.

For each tool result, looks up the stored HTTP response handle by tool call ID
and sends the response. Removes handled responses from state.
-}
deliverToolResults :
    ProviderState
    -> Array ToolResult
    -> { state : ProviderState, cmd : Cmd msg }
deliverToolResults state results =
    when state is
        CliProviderState cliState ->
            let
                foldResult =
                    Array.foldl
                        (\toolResult acc ->
                            when Dict.get toolResult.toolCallId acc.pending is
                                Just httpResponse ->
                                    let
                                        responseBody =
                                            if toolResult.isError then
                                                Encode.object
                                                    [ { key = "error"
                                                      , value =
                                                            Encode.object
                                                                [ { key = "code", value = Encode.string "TOOL_ERROR" }
                                                                , { key = "message", value = Encode.string toolResult.output }
                                                                ]
                                                      }
                                                    ]
                                                    |> Encode.encode 0
                                            else
                                                toolResult.output

                                        statusCode =
                                            if toolResult.isError then
                                                500
                                            else
                                                200

                                        sendCmd =
                                            httpResponse
                                                |> HttpResponse.setStatus statusCode
                                                |> HttpResponse.setHeader "Content-Type" "application/json"
                                                |> HttpResponse.setBody responseBody
                                                |> HttpResponse.send
                                    in
                                    { pending = Dict.remove toolResult.toolCallId acc.pending
                                    , cmds = Array.pushLast sendCmd acc.cmds
                                    }

                                Nothing ->
                                    -- No pending response for this tool call ID; skip
                                    acc
                        )
                        { pending = cliState.pendingHttpResponses, cmds = [] }
                        results
            in
            { state = CliProviderState { pendingHttpResponses = foldResult.pending }
            , cmd = Cmd.batch foldResult.cmds
            }

        ApiProviderState _ ->
            -- API providers do not use HTTP response handles
            { state = state
            , cmd = Cmd.none
            }


{-| Handle an incoming chorus-tools HTTP callback.

Stores the HTTP response handle in state (keyed by tool call ID). The caller
is responsible for emitting the `ToolCallReceived` event to the Executor.
-}
handleHttpToolCall :
    ProviderState
    -> HttpToolCallContext
    -> { state : ProviderState, cmd : Cmd msg }
handleHttpToolCall state context =
    when state is
        CliProviderState cliState ->
            let
                updatedPending =
                    Dict.set context.toolCall.id context.httpResponse cliState.pendingHttpResponses
            in
            { state = CliProviderState { pendingHttpResponses = updatedPending }
            , cmd = Cmd.none
            }

        ApiProviderState _ ->
            -- API providers do not use HTTP response handles
            { state = state
            , cmd = Cmd.none
            }



-- ENVIRONMENT VALIDATION


{-| Validate that required prerequisites are available.

Checks:
- claude CLI is installed and accessible
- file-tools binary exists at configured path
-}
validateEnvironment :
    Config
    -> (Result ProviderError {} -> msg)
    -> Cmd msg
validateEnvironment config toMsg =
    -- Check claude CLI by running "claude --version" with stdin redirected
    -- We use bash -c to redirect stdin from /dev/null to prevent hanging
    let
        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 1024
            , runDuration = ChildProcess.Milliseconds 5000
            }

        claudeCmd =
            "claude --version </dev/null"

        fileToolsCmd =
            config.chorusToolsPath ++ " --help </dev/null"
    in
    ChildProcess.run config.childProcessPermission "bash" [ "-c", claudeCmd ] options
        |> Task.andThen
            (\_ ->
                -- Claude CLI found, now check file-tools
                ChildProcess.run config.childProcessPermission "bash" [ "-c", fileToolsCmd ] options
                    |> Task.map (\_ -> {})
            )
        |> Task.mapError
            (\runError ->
                when runError is
                    ChildProcess.InitError { errorCode } ->
                        if String.contains "ENOENT" errorCode then
                            EnvironmentError
                                { message = "claude CLI not found in PATH. Install from https://claude.ai/code"
                                }
                        else
                            EnvironmentError
                                { message = "Failed to run claude CLI: " ++ errorCode
                                }

                    ChildProcess.ProgramError { exitCode, stderr } ->
                        let
                            stderrStr =
                                stderr |> Bytes.toString |> Maybe.withDefault ""
                        in
                        EnvironmentError
                            { message = "claude CLI check failed (exit " ++ String.fromInt exitCode ++ "): " ++ stderrStr
                            }
            )
        |> Task.attempt toMsg



-- CLI ARGUMENT BUILDING


{-| Arguments for building CLI command.
-}
type alias CliArgs =
    { systemPrompt : Maybe String
    , resumeSessionId : Maybe String
    , workspaceRoot : String
    , chorusToolsPath : String
    , message : String
    , allowedTools : Maybe String
    , taskId : Maybe String
    , baseUrl : Maybe String
    }


{-| Build a shell command string for the claude CLI.

This builds a command that redirects stdin from /dev/null to prevent
the CLI from hanging when waiting for input. Arguments are properly
escaped for shell execution.
-}
buildShellCommand : CliArgs -> String
buildShellCommand args =
    let
        -- Escape a string for use in single quotes
        -- Single quotes prevent all expansion except for single quotes themselves
        -- To include a single quote, we: end the single-quoted string, add an escaped single quote, start a new single-quoted string
        escapeForShell : String -> String
        escapeForShell str =
            "'" ++ String.replace "'" "'\\''" str ++ "'"

        baseArgs =
            "claude -p --output-format json"

        sessionArgs =
            when args.resumeSessionId is
                Just sessionId ->
                    " --resume " ++ escapeForShell sessionId

                Nothing ->
                    ""

        promptArgs =
            when args.systemPrompt is
                Just prompt ->
                    " --system-prompt " ++ escapeForShell prompt

                Nothing ->
                    ""

        cliFlags =
            when args.allowedTools is
                Just chorusToolNames ->
                    chorusToolsToCliFlags args.chorusToolsPath chorusToolNames

                Nothing ->
                    let
                        defaultValue =
                            "Bash(" ++ args.chorusToolsPath ++ " *)"
                    in
                    { tools = toolCliFlagFromAllowedTools defaultValue
                    , allowedTools = defaultValue
                    }

        toolArgs =
            " --tools " ++ escapeForShell cliFlags.tools ++ " --allowedTools " ++ escapeForShell cliFlags.allowedTools

        dirArgs =
            if String.isEmpty args.workspaceRoot then
                ""
            else
                " --add-dir " ++ escapeForShell args.workspaceRoot

        messageArg =
            " -- " ++ escapeForShell args.message

        -- Redirect stdin from /dev/null to prevent hanging
        stdinRedirect =
            " </dev/null"

        -- Prepend environment variables for chorus-tools
        envVars =
            let
                taskIdVar =
                    when args.taskId is
                        Just taskId ->
                            "CHORUS_TASK_ID=" ++ escapeForShell taskId ++ " "

                        Nothing ->
                            ""

                baseUrlVar =
                    when args.baseUrl is
                        Just url ->
                            "CHORUS_BASE_URL=" ++ escapeForShell url ++ " "

                        Nothing ->
                            ""
            in
            taskIdVar ++ baseUrlVar
    in
    envVars ++ "exec " ++ baseArgs ++ sessionArgs ++ promptArgs ++ toolArgs ++ dirArgs ++ messageArg ++ stdinRedirect


{-| Map Chorus tool names to Claude CLI --tools and --allowedTools flags.

Chorus tool names (file.read, web.search, handoff, etc.) are internal names
that the Claude CLI does not recognize. This function translates them into
the correct CLI flag values:

  - File tools and handoff → Bash(chorusToolsPath *)
  - web.search → WebSearch
  - Unrecognized names → ignored (not passed through)
  - Empty result → falls back to Bash(chorusToolsPath *)

-}
chorusToolsToCliFlags : String -> String -> { tools : String, allowedTools : String }
chorusToolsToCliFlags chorusToolsPath chorusToolNames =
    let
        bashValue =
            "Bash(" ++ chorusToolsPath ++ " *)"

        names =
            chorusToolNames
                |> String.split " "
                |> Array.keepIf (\s -> not (String.isEmpty (String.trim s)))

        mapped =
            names
                |> Array.mapAndKeepJust
                    (\name ->
                        when name is
                            "file.read" ->
                                Just bashValue

                            "file.write" ->
                                Just bashValue

                            "file.create" ->
                                Just bashValue

                            "file.patch" ->
                                Just bashValue

                            "file.delete" ->
                                Just bashValue

                            "file.list" ->
                                Just bashValue

                            "file.search" ->
                                Just bashValue

                            "handoff" ->
                                Just bashValue

                            "web.search" ->
                                Just "WebSearch"

                            _ ->
                                Nothing
                    )
                |> deduplicateStrings

        allowedToolsValue =
            if Array.isEmpty mapped then
                bashValue
            else
                String.join " " mapped

        toolsFlag =
            toolCliFlagFromAllowedTools allowedToolsValue
    in
    { tools = toolsFlag
    , allowedTools = allowedToolsValue
    }


{-| Derive the --tools flag value from an allowedTools string.

Extracts tool category names by removing all parenthesized content
(tracking depth to handle nested parens), then splitting on whitespace.

Example: "Bash(file-tools *) Edit Read(*)" produces "Bash Edit Read"
Example: "Bash(file-tools * scripts/agent/*)" produces "Bash"
-}
toolCliFlagFromAllowedTools : String -> String
toolCliFlagFromAllowedTools allowedTools =
    allowedTools
        |> stripParenthesizedContent
        |> String.split " "
        |> Array.keepIf (\s -> not (String.isEmpty (String.trim s)))
        |> Array.map String.trim
        |> deduplicateStrings
        |> String.join " "


{-| Remove all content between parentheses (inclusive), handling nested parens.

"Bash(file-tools * scripts/agent/*)" becomes "Bash"
"Bash(file-tools *) Edit Read(*)" becomes "Bash Edit Read"
-}
stripParenthesizedContent : String -> String
stripParenthesizedContent input =
    let
        result =
            input
                |> String.toArray
                |> Array.foldl
                    (\char acc ->
                        if char == '(' then
                            { acc | depth = acc.depth + 1 }
                        else if char == ')' then
                            { acc | depth = max 0 (acc.depth - 1) }
                        else if acc.depth == 0 then
                            { acc | chars = Array.pushLast char acc.chars }
                        else
                            acc
                    )
                    { depth = 0, chars = [] }
    in
    String.fromArray result.chars


{-| Remove duplicate strings while preserving order.
-}
deduplicateStrings : Array String -> Array String
deduplicateStrings arr =
    arr
        |> Array.foldl
            (\item { seen, result } ->
                if Array.member item seen then
                    { seen = seen, result = result }
                else
                    { seen = Array.pushLast item seen, result = Array.pushLast item result }
            )
            { seen = [], result = [] }
        |> .result



