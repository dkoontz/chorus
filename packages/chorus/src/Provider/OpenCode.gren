module Provider.OpenCode exposing
    ( provider
    , Config
    , CliArgs
    , buildShellCommand
    )

{-| OpenCode provider implementation.

This provider spawns the opencode CLI to communicate with LLMs.
It implements the Provider interface for LLM communication.

OpenCode uses AGENTS.md files for system prompts (no --system-prompt flag),
and supports JSON output via --format json.
-}

import Bytes
import ChildProcess
import Dict
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpServer.Response as HttpResponse
import Json.Decode as Decode
import Json.Encode as Encode
import Provider
    exposing
        ( AgentSpec
        , HttpToolCallContext
        , Provider
        , ProviderError(..)
        , ProviderEvent(..)
        , ProviderKind(..)
        , ProviderState(..)
        , StartConfig
        , ToolCall
        , ToolResult
        )
import Task


-- CONFIGURATION


{-| Configuration for the OpenCode provider.
-}
type alias Config =
    { childProcessPermission : ChildProcess.Permission
    , filesystemPermission : FileSystem.Permission
    , chorusToolsPath : String
    , baseUrl : String
    }



-- PROVIDER


{-| The OpenCode provider.

This implements the `Provider` interface. For CLI providers:

- `startAgent` writes AGENTS.md (system prompt) and spawns the CLI process.
  On exit, emits `AgentCompleted` or `AgentFailed`.
- `handleHttpToolCall` stores the HTTP response handle in `CliProviderState`
  and emits `ToolCallReceived` so the Executor can process the tool call.
- `deliverToolResults` sends HTTP responses to the stored response handles.

-}
provider : Config -> Provider msg
provider config =
    { kind = CliProvider
    , validateEnvironment = validateEnvironment config
    , startAgent = startAgent config
    , deliverToolResults = deliverToolResults
    , handleHttpToolCall = handleHttpToolCall
    , initState = CliProviderState { pendingHttpResponses = Dict.empty }
    }


{-| Start an agent by writing AGENTS.md and spawning the CLI process.
-}
startAgent :
    Config
    -> ProviderState
    -> StartConfig msg
    -> { state : ProviderState, cmd : Cmd msg }
startAgent config state startConfig =
    let
        agentSpec =
            startConfig.agentSpec

        -- Write system prompt to AGENTS.md, then spawn the CLI process
        agentsPath =
            Path.append (Path.fromPosixString "AGENTS.md") (Path.fromPosixString startConfig.workspaceRoot)

        cliArgs =
            { sessionId = Nothing
            , workspaceRoot = startConfig.workspaceRoot
            , message = startConfig.message
            , chorusToolsPath = config.chorusToolsPath
            , taskId = startConfig.taskId
            , baseUrl = Just config.baseUrl
            }

        shellCommand =
            buildShellCommand cliArgs

        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 10 * 1024 * 1024
            , runDuration = ChildProcess.Milliseconds 600000
            }

        cmd =
            FileSystem.writeFile config.filesystemPermission (Bytes.fromString agentSpec.systemPrompt) agentsPath
                |> Task.mapError (\fsErr -> "Failed to write AGENTS.md: " ++ FileSystem.errorToString fsErr)
                |> Task.andThen
                    (\_ ->
                        ChildProcess.run config.childProcessPermission "bash" [ "-c", shellCommand ] options
                            |> Task.map
                                (\cliResult ->
                                    let
                                        output =
                                            cliResult.stdout
                                                |> Bytes.toString
                                                |> Maybe.withDefault ""

                                        resultText =
                                            when Decode.decodeString (Decode.field "result" Decode.string) output is
                                                Ok text ->
                                                    text

                                                Err _ ->
                                                    output
                                    in
                                    startConfig.onEvent (AgentCompleted resultText)
                                )
                            |> Task.onError
                                (\runError ->
                                    let
                                        errMsg =
                                            when runError is
                                                ChildProcess.InitError { errorCode } ->
                                                    "Failed to start agent CLI: " ++ errorCode

                                                ChildProcess.ProgramError { exitCode, stderr } ->
                                                    let
                                                        stderrStr =
                                                            stderr
                                                                |> Bytes.toString
                                                                |> Maybe.withDefault ""
                                                    in
                                                    "Agent CLI exited with code " ++ String.fromInt exitCode ++ ": " ++ stderrStr
                                    in
                                    Task.succeed (startConfig.onEvent (AgentFailed errMsg))
                                )
                    )
                |> Task.onError
                    (\errMsg ->
                        Task.succeed (startConfig.onEvent (AgentFailed errMsg))
                    )
                |> Task.perform identity
    in
    { state = state
    , cmd = cmd
    }


{-| Deliver tool results back to the agent by sending HTTP responses.

Same implementation as ClaudeCode since both are CLI providers.
-}
deliverToolResults :
    ProviderState
    -> Array ToolResult
    -> { state : ProviderState, cmd : Cmd msg }
deliverToolResults state results =
    when state is
        CliProviderState cliState ->
            let
                foldResult =
                    Array.foldl
                        (\toolResult acc ->
                            when Dict.get toolResult.toolCallId acc.pending is
                                Just httpResponse ->
                                    let
                                        responseBody =
                                            if toolResult.isError then
                                                Encode.object
                                                    [ { key = "error"
                                                      , value =
                                                            Encode.object
                                                                [ { key = "code", value = Encode.string "TOOL_ERROR" }
                                                                , { key = "message", value = Encode.string toolResult.output }
                                                                ]
                                                      }
                                                    ]
                                                    |> Encode.encode 0
                                            else
                                                toolResult.output

                                        statusCode =
                                            if toolResult.isError then
                                                500
                                            else
                                                200

                                        sendCmd =
                                            httpResponse
                                                |> HttpResponse.setStatus statusCode
                                                |> HttpResponse.setHeader "Content-Type" "application/json"
                                                |> HttpResponse.setBody responseBody
                                                |> HttpResponse.send
                                    in
                                    { pending = Dict.remove toolResult.toolCallId acc.pending
                                    , cmds = Array.pushLast sendCmd acc.cmds
                                    }

                                Nothing ->
                                    acc
                        )
                        { pending = cliState.pendingHttpResponses, cmds = [] }
                        results
            in
            { state = CliProviderState { pendingHttpResponses = foldResult.pending }
            , cmd = Cmd.batch foldResult.cmds
            }

        _ ->
            { state = state
            , cmd = Cmd.none
            }


{-| Handle an incoming chorus-tools HTTP callback.

Stores the HTTP response handle in state (keyed by tool call ID). The caller
is responsible for emitting the `ToolCallReceived` event to the Executor.
-}
handleHttpToolCall :
    ProviderState
    -> HttpToolCallContext
    -> { state : ProviderState, cmd : Cmd msg }
handleHttpToolCall state context =
    when state is
        CliProviderState cliState ->
            let
                updatedPending =
                    Dict.set context.toolCall.id context.httpResponse cliState.pendingHttpResponses
            in
            { state = CliProviderState { pendingHttpResponses = updatedPending }
            , cmd = Cmd.none
            }

        _ ->
            { state = state
            , cmd = Cmd.none
            }



-- ENVIRONMENT VALIDATION


{-| Validate that the opencode CLI is installed.
-}
validateEnvironment :
    Config
    -> (Result ProviderError {} -> msg)
    -> Cmd msg
validateEnvironment config toMsg =
    let
        options =
            { shell = ChildProcess.NoShell
            , workingDirectory = ChildProcess.InheritWorkingDirectory
            , environmentVariables = ChildProcess.InheritEnvironmentVariables
            , maximumBytesWrittenToStreams = 1024
            , runDuration = ChildProcess.Milliseconds 5000
            }
    in
    ChildProcess.run config.childProcessPermission "bash" [ "-c", "opencode --version </dev/null" ] options
        |> Task.map (\_ -> {})
        |> Task.mapError
            (\runError ->
                when runError is
                    ChildProcess.InitError { errorCode } ->
                        if String.contains "ENOENT" errorCode then
                            EnvironmentError
                                { message = "opencode CLI not found in PATH. Install from https://opencode.ai" }
                        else
                            EnvironmentError
                                { message = "Failed to run opencode CLI: " ++ errorCode }

                    ChildProcess.ProgramError { exitCode, stderr } ->
                        let
                            stderrStr =
                                stderr |> Bytes.toString |> Maybe.withDefault ""
                        in
                        EnvironmentError
                            { message = "opencode CLI check failed (exit " ++ String.fromInt exitCode ++ "): " ++ stderrStr }
            )
        |> Task.attempt toMsg



-- CLI COMMAND BUILDING


type alias CliArgs =
    { sessionId : Maybe String
    , workspaceRoot : String
    , message : String
    , chorusToolsPath : String
    , taskId : Maybe String
    , baseUrl : Maybe String
    }


{-| Build a shell command for the opencode CLI.
-}
buildShellCommand : CliArgs -> String
buildShellCommand args =
    let
        escapeForShell : String -> String
        escapeForShell str =
            "'" ++ String.replace "'" "'\\''" str ++ "'"

        baseCmd =
            "opencode -p --format json"

        sessionArgs =
            when args.sessionId is
                Just sid ->
                    " --session " ++ escapeForShell sid

                Nothing ->
                    ""

        cwdArgs =
            if String.isEmpty args.workspaceRoot then
                ""
            else
                " --cwd " ++ escapeForShell args.workspaceRoot

        messageArg =
            " " ++ escapeForShell args.message

        stdinRedirect =
            " </dev/null"

        envVars =
            let
                taskIdVar =
                    when args.taskId is
                        Just taskId ->
                            "CHORUS_TASK_ID=" ++ escapeForShell taskId ++ " "

                        Nothing ->
                            ""

                baseUrlVar =
                    when args.baseUrl is
                        Just url ->
                            "CHORUS_BASE_URL=" ++ escapeForShell url ++ " "

                        Nothing ->
                            ""
            in
            taskIdVar ++ baseUrlVar
    in
    envVars ++ baseCmd ++ sessionArgs ++ cwdArgs ++ messageArg ++ stdinRedirect



