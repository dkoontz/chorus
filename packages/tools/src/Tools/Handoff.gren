module Tools.Handoff exposing
    ( HandoffInput
    , HandoffOutput
    , HandoffError(..)
    , handoffErrorToString
    , run
    )

{-| Handoff tool for starting an agent handoff via the Chorus API and polling
until the agent completes.

This tool uses curl via ChildProcess since Gren's Node platform does not
provide a built-in HTTP client.
-}

import Bytes exposing (Bytes)
import ChildProcess
import Json.Decode as Decode
import Json.Encode as Encode
import Process
import Task exposing (Task)


-- TYPES


{-| Input for the handoff operation.
-}
type alias HandoffInput =
    { taskId : String
    , agentName : String
    , prompt : String
    , baseUrl : String
    , pollIntervalMs : Int
    , maxWaitMs : Int
    }


{-| Output from a successful handoff.
-}
type alias HandoffOutput =
    { agentName : String
    , output : String
    }


{-| Errors that can occur during a handoff.
-}
type HandoffError
    = HttpError { statusCode : Int, body : String }
    | CurlFailed { reason : String }
    | JsonParseError { reason : String }
    | Timeout { elapsedMs : Int, maxWaitMs : Int }
    | AgentConflict { existingAgent : String }


{-| Convert a handoff error to a human-readable string.
-}
handoffErrorToString : HandoffError -> String
handoffErrorToString error =
    when error is
        HttpError { statusCode, body } ->
            "HTTP error " ++ String.fromInt statusCode ++ ": " ++ body

        CurlFailed { reason } ->
            "curl failed: " ++ reason

        JsonParseError { reason } ->
            "JSON parse error: " ++ reason

        Timeout { elapsedMs, maxWaitMs } ->
            "Timed out after " ++ String.fromInt (elapsedMs // 1000) ++ "s (max " ++ String.fromInt (maxWaitMs // 1000) ++ "s)"

        AgentConflict { existingAgent } ->
            "Agent already active on task: " ++ existingAgent


-- PUBLIC API


{-| Start a handoff and poll until the agent completes.

Makes a POST to /api/tasks/:id/handoff to start, then polls
GET /api/tasks/:id until currentAgent is null.
-}
run : ChildProcess.Permission -> HandoffInput -> Task HandoffError HandoffOutput
run cpPermission input =
    startHandoff cpPermission input
        |> Task.andThen (\_ -> pollForCompletion cpPermission input 0)



-- INTERNAL


{-| Start the handoff by POSTing to the Chorus API.
-}
startHandoff : ChildProcess.Permission -> HandoffInput -> Task HandoffError {}
startHandoff cpPermission input =
    let
        url =
            input.baseUrl ++ "/api/tasks/" ++ input.taskId ++ "/handoff"

        bodyJson =
            Encode.object
                [ { key = "agentName", value = Encode.string input.agentName }
                , { key = "prompt", value = Encode.string input.prompt }
                ]
                |> Encode.encode 0

        args =
            [ "-s"
            , "-w"
            , "\n%{http_code}"
            , "-X"
            , "POST"
            , "-H"
            , "Content-Type: application/json"
            , "-d"
            , bodyJson
            , url
            ]

    in
    ChildProcess.run cpPermission "curl" args defaultCurlOptions
        |> Task.mapError (\failedRun -> curlFailedRunToError failedRun)
        |> Task.andThen
            (\result ->
                when parseHttpResponse result.stdout is
                    Err httpErr ->
                        Task.fail httpErr

                    Ok { statusCode, body } ->
                        if statusCode >= 400 then
                            if statusCode == 409 then
                                Task.fail (AgentConflict { existingAgent = extractErrorMessage body })
                            else
                                Task.fail (HttpError { statusCode = statusCode, body = body })
                        else
                            Task.succeed {}
            )


{-| Poll the task endpoint until the agent completes or timeout is reached.
-}
pollForCompletion : ChildProcess.Permission -> HandoffInput -> Int -> Task HandoffError HandoffOutput
pollForCompletion cpPermission input elapsedMs =
    if elapsedMs >= input.maxWaitMs then
        Task.fail (Timeout { elapsedMs = elapsedMs, maxWaitMs = input.maxWaitMs })
    else
        Process.sleep (toFloat input.pollIntervalMs)
            |> Task.mapError (\_ -> CurlFailed { reason = "sleep failed" })
            |> Task.andThen
                (\_ ->
                    let
                        newElapsed =
                            elapsedMs + input.pollIntervalMs
                    in
                    fetchTask cpPermission input
                        |> Task.andThen
                            (\taskJson ->
                                let
                                    currentAgentResult =
                                        taskJson
                                            |> Decode.decodeString
                                                (Decode.field "data"
                                                    (Decode.maybe (Decode.field "currentAgent" Decode.string))
                                                )
                                in
                                when currentAgentResult is
                                    Err decodeErr ->
                                        Task.fail (JsonParseError { reason = "Could not parse task status from API response: " ++ Decode.errorToString decodeErr })

                                    Ok (Just _) ->
                                        -- Agent still running, keep polling
                                        pollForCompletion cpPermission input newElapsed

                                    Ok Nothing ->
                                        -- Agent completed; extract output from the last agentChain entry
                                        extractAgentOutput taskJson input.agentName
                            )
                )


{-| Fetch the task JSON from the Chorus API.
-}
fetchTask : ChildProcess.Permission -> HandoffInput -> Task HandoffError String
fetchTask cpPermission input =
    let
        url =
            input.baseUrl ++ "/api/tasks/" ++ input.taskId

        args =
            [ "-s"
            , "-w"
            , "\n%{http_code}"
            , url
            ]
    in
    ChildProcess.run cpPermission "curl" args defaultCurlOptions
        |> Task.mapError (\failedRun -> curlFailedRunToError failedRun)
        |> Task.andThen
            (\result ->
                when parseHttpResponse result.stdout is
                    Err httpErr ->
                        Task.fail httpErr

                    Ok { statusCode, body } ->
                        if statusCode >= 400 then
                            Task.fail (HttpError { statusCode = statusCode, body = body })
                        else
                            Task.succeed body
            )


{-| Extract the agent output from the last entry in the agentChain array.

Fails with JsonParseError if the agentChain cannot be decoded or is empty.
-}
extractAgentOutput : String -> String -> Task HandoffError HandoffOutput
extractAgentOutput taskJson agentName =
    let
        outputResult =
            taskJson
                |> Decode.decodeString
                    (Decode.field "data"
                        (Decode.field "agentChain"
                            (Decode.array
                                (Decode.field "output" Decode.string)
                            )
                        )
                    )
    in
    when outputResult is
        Err decodeErr ->
            Task.fail (JsonParseError { reason = "Could not extract agent output: " ++ Decode.errorToString decodeErr })

        Ok outputs ->
            when Array.last outputs is
                Nothing ->
                    Task.fail (JsonParseError { reason = "Agent chain is empty; expected at least one entry" })

                Just lastOutput ->
                    Task.succeed
                        { agentName = agentName
                        , output = lastOutput
                        }


-- HELPERS


{-| Default options for curl ChildProcess runs.
-}
defaultCurlOptions : ChildProcess.RunOptions
defaultCurlOptions =
    { shell = ChildProcess.NoShell
    , workingDirectory = ChildProcess.InheritWorkingDirectory
    , environmentVariables = ChildProcess.InheritEnvironmentVariables
    , maximumBytesWrittenToStreams = 1024 * 1024
    , runDuration = ChildProcess.Milliseconds 30000
    }


{-| Parse an HTTP response from curl -w "\n%{http_code}" format.

The output has the response body followed by a newline and the HTTP status code.
-}
parseHttpResponse : Bytes -> Result HandoffError { statusCode : Int, body : String }
parseHttpResponse bytes =
    when Bytes.toString bytes is
        Nothing ->
            Err (CurlFailed { reason = "Response was not valid UTF-8" })

        Just raw ->
            let
                lines =
                    String.split "\n" raw

                statusCodeStr =
                    lines
                        |> Array.last
                        |> Maybe.withDefault "0"

                statusCode =
                    statusCodeStr
                        |> String.toInt
                        |> Maybe.withDefault 0

                body =
                    lines
                        |> Array.dropLast 1
                        |> String.join "\n"
            in
            Ok
                { statusCode = statusCode
                , body = body
                }


{-| Extract an error message from a JSON error response body.
-}
extractErrorMessage : String -> String
extractErrorMessage body =
    body
        |> Decode.decodeString
            (Decode.field "error"
                (Decode.field "message" Decode.string)
            )
        |> Result.withDefault body


{-| Convert a ChildProcess.FailedRun to a HandoffError.
-}
curlFailedRunToError : ChildProcess.FailedRun -> HandoffError
curlFailedRunToError failedRun =
    when failedRun is
        ChildProcess.ProgramError { exitCode, stderr } ->
            let
                stderrStr =
                    stderr
                        |> Bytes.toString
                        |> Maybe.withDefault ""
                        |> String.trim

                reason =
                    if String.isEmpty stderrStr then
                        "curl exited with code " ++ String.fromInt exitCode
                    else
                        stderrStr
            in
            CurlFailed { reason = reason }

        ChildProcess.InitError { errorCode } ->
            CurlFailed { reason = "curl not available: " ++ errorCode }
