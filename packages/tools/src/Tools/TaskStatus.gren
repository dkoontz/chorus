module Tools.TaskStatus exposing
    ( TaskGetInput
    , TaskGetOutput
    , TaskListInput
    , TaskListOutput
    , TaskSummary
    , AgentChainEntry
    , TaskStatusError(..)
    , taskStatusErrorToString
    , getTask
    , listTasks
    )

{-| Task status tool for querying task data from the Chorus API.

This tool uses curl via ChildProcess since Gren's Node platform does not
provide a built-in HTTP client.
-}

import Bytes exposing (Bytes)
import ChildProcess
import Json.Decode as Decode
import Json.Encode as Encode
import Task exposing (Task)


-- TYPES


{-| Input for the task.get operation.
-}
type alias TaskGetInput =
    { taskId : String
    , baseUrl : String
    }


{-| Output from a successful task.get operation.
Contains the full task record.
-}
type alias TaskGetOutput =
    { id : String
    , description : String
    , status : String
    , statusMessage : Maybe String
    , taskType : String
    , currentAgent : Maybe String
    , agentChain : Array AgentChainEntry
    , createdAt : Int
    , updatedAt : Int
    , summary : Maybe String
    , requirements : Maybe (Array String)
    , acceptanceCriteria : Maybe (Array String)
    , plan : Maybe (Array String)
    }


{-| An entry in the agent hand-off chain.
-}
type alias AgentChainEntry =
    { agentName : String
    , startedAt : Int
    , completedAt : Maybe Int
    , output : String
    }


{-| Input for the task.list operation.
-}
type alias TaskListInput =
    { status : Maybe String
    , baseUrl : String
    }


{-| Output from a successful task.list operation.
-}
type alias TaskListOutput =
    { tasks : Array TaskSummary
    }


{-| Summary of a task for the list operation.
-}
type alias TaskSummary =
    { id : String
    , description : String
    , status : String
    , statusMessage : Maybe String
    , currentAgent : Maybe String
    }


{-| Errors that can occur during task status operations.
-}
type TaskStatusError
    = HttpError { statusCode : Int, body : String }
    | CurlFailed { reason : String }
    | JsonParseError { reason : String }
    | TaskNotFound { taskId : String }


{-| Convert a task status error to a human-readable string.
-}
taskStatusErrorToString : TaskStatusError -> String
taskStatusErrorToString error =
    when error is
        HttpError { statusCode, body } ->
            "HTTP error " ++ String.fromInt statusCode ++ ": " ++ body

        CurlFailed { reason } ->
            "curl failed: " ++ reason

        JsonParseError { reason } ->
            "JSON parse error: " ++ reason

        TaskNotFound { taskId } ->
            "Task not found: " ++ taskId



-- PUBLIC API


{-| Get the full details of a task by ID.

Makes a GET request to /api/tasks/:id and decodes the response.
-}
getTask : ChildProcess.Permission -> TaskGetInput -> Task TaskStatusError TaskGetOutput
getTask childProcessPermission input =
    let
        url =
            input.baseUrl ++ "/api/tasks/" ++ input.taskId

        args =
            [ "-s"
            , "-w"
            , "\n%{http_code}"
            , url
            ]
    in
    ChildProcess.run childProcessPermission "curl" args defaultCurlOptions
        |> Task.mapError curlFailedRunToError
        |> Task.andThen
            (\result ->
                when parseHttpResponse result.stdout is
                    Err httpErr ->
                        Task.fail httpErr

                    Ok { statusCode, body } ->
                        if statusCode == 404 then
                            Task.fail (TaskNotFound { taskId = input.taskId })
                        else if statusCode >= 400 then
                            Task.fail (HttpError { statusCode = statusCode, body = body })
                        else
                            when Decode.decodeString taskGetOutputDecoder body is
                                Err decodeErr ->
                                    Task.fail (JsonParseError { reason = Decode.errorToString decodeErr })

                                Ok output ->
                                    Task.succeed output
            )


{-| List tasks, optionally filtered by status.

Makes a GET request to /api/tasks?status=... and decodes the response.
-}
listTasks : ChildProcess.Permission -> TaskListInput -> Task TaskStatusError TaskListOutput
listTasks childProcessPermission input =
    let
        queryString =
            when input.status is
                Just status ->
                    "?status=" ++ status

                Nothing ->
                    ""

        url =
            input.baseUrl ++ "/api/tasks" ++ queryString

        args =
            [ "-s"
            , "-w"
            , "\n%{http_code}"
            , url
            ]
    in
    ChildProcess.run childProcessPermission "curl" args defaultCurlOptions
        |> Task.mapError curlFailedRunToError
        |> Task.andThen
            (\result ->
                when parseHttpResponse result.stdout is
                    Err httpErr ->
                        Task.fail httpErr

                    Ok { statusCode, body } ->
                        if statusCode >= 400 then
                            Task.fail (HttpError { statusCode = statusCode, body = body })
                        else
                            when Decode.decodeString taskListOutputDecoder body is
                                Err decodeErr ->
                                    Task.fail (JsonParseError { reason = Decode.errorToString decodeErr })

                                Ok output ->
                                    Task.succeed output
            )



-- DECODERS


{-| Decode the full task response from the API.

The API wraps the task data in a `{ "data": ... }` envelope.
-}
taskGetOutputDecoder : Decode.Decoder TaskGetOutput
taskGetOutputDecoder =
    Decode.field "data" taskDataDecoder


{-| Decode a single task data object.

All required fields must be present; missing required fields produce a decode error.
Optional fields (summary, requirements, acceptanceCriteria, plan) decode as Nothing when absent.
-}
taskDataDecoder : Decode.Decoder TaskGetOutput
taskDataDecoder =
    Decode.map
        (\id description statusInfo taskType currentAgent agentChain createdAt updatedAt summary requirements acceptanceCriteria plan ->
            { id = id
            , description = description
            , status = statusInfo.statusType
            , statusMessage = statusInfo.statusMessage
            , taskType = taskType
            , currentAgent = currentAgent
            , agentChain = agentChain
            , createdAt = createdAt
            , updatedAt = updatedAt
            , summary = summary
            , requirements = requirements
            , acceptanceCriteria = acceptanceCriteria
            , plan = plan
            }
        )
        (Decode.field "id" Decode.string)
        |> andMap (Decode.field "description" Decode.string)
        |> andMap (Decode.field "status" statusInfoDecoder)
        |> andMap (Decode.field "taskType" Decode.string)
        |> andMap (Decode.field "currentAgent" (Decode.maybe Decode.string))
        |> andMap (Decode.field "agentChain" (Decode.array agentChainEntryDecoder))
        |> andMap (Decode.field "createdAt" Decode.int)
        |> andMap (Decode.field "updatedAt" Decode.int)
        |> andMap (Decode.maybe (Decode.field "summary" Decode.string))
        |> andMap (Decode.maybe (Decode.field "requirements" (Decode.array Decode.string)))
        |> andMap (Decode.maybe (Decode.field "acceptanceCriteria" (Decode.array Decode.string)))
        |> andMap (Decode.maybe (Decode.field "plan" (Decode.array Decode.string)))


{-| Apply a decoder to a decoder of a function, enabling decoders with any number of fields.
-}
andMap : Decode.Decoder a -> Decode.Decoder (a -> b) -> Decode.Decoder b
andMap da dfn =
    Decode.map2 (\fn a -> fn a) dfn da


{-| Decode status information from the status object.

Status is encoded as `{"type": "pending"}` or `{"type": "failed", "message": "..."}`.
The optional message field is always decoded regardless of status type.
-}
statusInfoDecoder : Decode.Decoder { statusType : String, statusMessage : Maybe String }
statusInfoDecoder =
    Decode.map2
        (\statusType statusMessage ->
            { statusType = statusType
            , statusMessage = statusMessage
            }
        )
        (Decode.field "type" Decode.string)
        (Decode.maybe (Decode.field "message" Decode.string))


{-| Decode an agent chain entry.
-}
agentChainEntryDecoder : Decode.Decoder AgentChainEntry
agentChainEntryDecoder =
    Decode.map4
        (\agentName startedAt completedAt output ->
            { agentName = agentName
            , startedAt = startedAt
            , completedAt = completedAt
            , output = output
            }
        )
        (Decode.field "agentName" Decode.string)
        (Decode.field "startedAt" Decode.int)
        (Decode.field "completedAt" (Decode.maybe Decode.int))
        (Decode.field "output" Decode.string)


{-| Decode the task list response from the API.

The API wraps the task array in a `{ "data": [...] }` envelope.
-}
taskListOutputDecoder : Decode.Decoder TaskListOutput
taskListOutputDecoder =
    Decode.field "data" (Decode.array taskSummaryDecoder)
        |> Decode.map (\tasks -> { tasks = tasks })


{-| Decode a task summary from a list response entry.
-}
taskSummaryDecoder : Decode.Decoder TaskSummary
taskSummaryDecoder =
    Decode.map4
        (\id description statusInfo currentAgent ->
            { id = id
            , description = description
            , status = statusInfo.statusType
            , statusMessage = statusInfo.statusMessage
            , currentAgent = currentAgent
            }
        )
        (Decode.field "id" Decode.string)
        (Decode.field "description" Decode.string)
        (Decode.field "status" statusInfoDecoder)
        (Decode.field "currentAgent" (Decode.maybe Decode.string))



-- HELPERS


{-| Default options for curl ChildProcess runs.
-}
defaultCurlOptions : ChildProcess.RunOptions
defaultCurlOptions =
    { shell = ChildProcess.NoShell
    , workingDirectory = ChildProcess.InheritWorkingDirectory
    , environmentVariables = ChildProcess.InheritEnvironmentVariables
    , maximumBytesWrittenToStreams = 1024 * 1024
    , runDuration = ChildProcess.Milliseconds 30000
    }


{-| Parse an HTTP response from curl -w "\n%{http_code}" format.

The output has the response body followed by a newline and the HTTP status code.
-}
parseHttpResponse : Bytes -> Result TaskStatusError { statusCode : Int, body : String }
parseHttpResponse bytes =
    when Bytes.toString bytes is
        Nothing ->
            Err (CurlFailed { reason = "Response was not valid UTF-8" })

        Just raw ->
            let
                lines =
                    String.split "\n" raw

                maybeStatusCode =
                    lines
                        |> Array.last
                        |> Maybe.andThen String.toInt

                body =
                    lines
                        |> Array.dropLast 1
                        |> String.join "\n"
            in
            when maybeStatusCode is
                Nothing ->
                    Err (CurlFailed { reason = "Could not parse HTTP status code from curl output" })

                Just statusCode ->
                    Ok
                        { statusCode = statusCode
                        , body = body
                        }


{-| Convert a ChildProcess.FailedRun to a TaskStatusError.
-}
curlFailedRunToError : ChildProcess.FailedRun -> TaskStatusError
curlFailedRunToError failedRun =
    when failedRun is
        ChildProcess.ProgramError { exitCode, stderr } ->
            let
                stderrStr =
                    stderr
                        |> Bytes.toString
                        |> Maybe.withDefault ""
                        |> String.trim

                reason =
                    if String.isEmpty stderrStr then
                        "curl exited with code " ++ String.fromInt exitCode
                    else
                        stderrStr
            in
            CurlFailed { reason = reason }

        ChildProcess.InitError { errorCode } ->
            CurlFailed { reason = "curl not available: " ++ errorCode }
